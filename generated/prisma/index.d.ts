
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model CAHoldings
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CAHoldings = $Result.DefaultSelection<Prisma.$CAHoldingsPayload>
/**
 * Model CAMarketCards
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CAMarketCards = $Result.DefaultSelection<Prisma.$CAMarketCardsPayload>
/**
 * Model CAPieChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CAPieChart = $Result.DefaultSelection<Prisma.$CAPieChartPayload>
/**
 * Model CAPriceChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CAPriceChart = $Result.DefaultSelection<Prisma.$CAPriceChartPayload>
/**
 * Model CBComparisonChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CBComparisonChart = $Result.DefaultSelection<Prisma.$CBComparisonChartPayload>
/**
 * Model CBMonthlyDetails
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CBMonthlyDetails = $Result.DefaultSelection<Prisma.$CBMonthlyDetailsPayload>
/**
 * Model CBSummaryCards
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CBSummaryCards = $Result.DefaultSelection<Prisma.$CBSummaryCardsPayload>
/**
 * Model CFDetails
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CFDetails = $Result.DefaultSelection<Prisma.$CFDetailsPayload>
/**
 * Model CFPieChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CFPieChart = $Result.DefaultSelection<Prisma.$CFPieChartPayload>
/**
 * Model CFTrendChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type CFTrendChart = $Result.DefaultSelection<Prisma.$CFTrendChartPayload>
/**
 * Model EAConsumptionTrend
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EAConsumptionTrend = $Result.DefaultSelection<Prisma.$EAConsumptionTrendPayload>
/**
 * Model EAMonthSummary
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EAMonthSummary = $Result.DefaultSelection<Prisma.$EAMonthSummaryPayload>
/**
 * Model EAStrategy
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EAStrategy = $Result.DefaultSelection<Prisma.$EAStrategyPayload>
/**
 * Model EATypeComparison
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EATypeComparison = $Result.DefaultSelection<Prisma.$EATypeComparisonPayload>
/**
 * Model EBParamCards
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EBParamCards = $Result.DefaultSelection<Prisma.$EBParamCardsPayload>
/**
 * Model EBPieChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EBPieChart = $Result.DefaultSelection<Prisma.$EBPieChartPayload>
/**
 * Model EBResults
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EBResults = $Result.DefaultSelection<Prisma.$EBResultsPayload>
/**
 * Model EBTrendChart
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EBTrendChart = $Result.DefaultSelection<Prisma.$EBTrendChartPayload>
/**
 * Model ECenergyFlowRealTime
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ECenergyFlowRealTime = $Result.DefaultSelection<Prisma.$ECenergyFlowRealTimePayload>
/**
 * Model ECenergyTypes
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ECenergyTypes = $Result.DefaultSelection<Prisma.$ECenergyTypesPayload>
/**
 * Model EChistory
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EChistory = $Result.DefaultSelection<Prisma.$EChistoryPayload>
/**
 * Model ECrealTime
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type ECrealTime = $Result.DefaultSelection<Prisma.$ECrealTimePayload>
/**
 * Model EEBenchmarkRankCards
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EEBenchmarkRankCards = $Result.DefaultSelection<Prisma.$EEBenchmarkRankCardsPayload>
/**
 * Model EEGaugeMetrics
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EEGaugeMetrics = $Result.DefaultSelection<Prisma.$EEGaugeMetricsPayload>
/**
 * Model EERankingList
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EERankingList = $Result.DefaultSelection<Prisma.$EERankingListPayload>
/**
 * Model EETrendChartData
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EETrendChartData = $Result.DefaultSelection<Prisma.$EETrendChartDataPayload>
/**
 * Model EFSankeyLinks
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EFSankeyLinks = $Result.DefaultSelection<Prisma.$EFSankeyLinksPayload>
/**
 * Model EFSankeyNodes
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EFSankeyNodes = $Result.DefaultSelection<Prisma.$EFSankeyNodesPayload>
/**
 * Model EFSummaryTable
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type EFSummaryTable = $Result.DefaultSelection<Prisma.$EFSummaryTablePayload>
/**
 * Model SCRanking
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type SCRanking = $Result.DefaultSelection<Prisma.$SCRankingPayload>
/**
 * Model SCSankeyData
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type SCSankeyData = $Result.DefaultSelection<Prisma.$SCSankeyDataPayload>
/**
 * Model receiptfc
 * 
 */
export type receiptfc = $Result.DefaultSelection<Prisma.$receiptfcPayload>
/**
 * Model receiptfg
 * 
 */
export type receiptfg = $Result.DefaultSelection<Prisma.$receiptfgPayload>

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more CAHoldings
 * const cAHoldings = await prisma.cAHoldings.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more CAHoldings
   * const cAHoldings = await prisma.cAHoldings.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.cAHoldings`: Exposes CRUD operations for the **CAHoldings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CAHoldings
    * const cAHoldings = await prisma.cAHoldings.findMany()
    * ```
    */
  get cAHoldings(): Prisma.CAHoldingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cAMarketCards`: Exposes CRUD operations for the **CAMarketCards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CAMarketCards
    * const cAMarketCards = await prisma.cAMarketCards.findMany()
    * ```
    */
  get cAMarketCards(): Prisma.CAMarketCardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cAPieChart`: Exposes CRUD operations for the **CAPieChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CAPieCharts
    * const cAPieCharts = await prisma.cAPieChart.findMany()
    * ```
    */
  get cAPieChart(): Prisma.CAPieChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cAPriceChart`: Exposes CRUD operations for the **CAPriceChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CAPriceCharts
    * const cAPriceCharts = await prisma.cAPriceChart.findMany()
    * ```
    */
  get cAPriceChart(): Prisma.CAPriceChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cBComparisonChart`: Exposes CRUD operations for the **CBComparisonChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CBComparisonCharts
    * const cBComparisonCharts = await prisma.cBComparisonChart.findMany()
    * ```
    */
  get cBComparisonChart(): Prisma.CBComparisonChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cBMonthlyDetails`: Exposes CRUD operations for the **CBMonthlyDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CBMonthlyDetails
    * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findMany()
    * ```
    */
  get cBMonthlyDetails(): Prisma.CBMonthlyDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cBSummaryCards`: Exposes CRUD operations for the **CBSummaryCards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CBSummaryCards
    * const cBSummaryCards = await prisma.cBSummaryCards.findMany()
    * ```
    */
  get cBSummaryCards(): Prisma.CBSummaryCardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cFDetails`: Exposes CRUD operations for the **CFDetails** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CFDetails
    * const cFDetails = await prisma.cFDetails.findMany()
    * ```
    */
  get cFDetails(): Prisma.CFDetailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cFPieChart`: Exposes CRUD operations for the **CFPieChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CFPieCharts
    * const cFPieCharts = await prisma.cFPieChart.findMany()
    * ```
    */
  get cFPieChart(): Prisma.CFPieChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cFTrendChart`: Exposes CRUD operations for the **CFTrendChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CFTrendCharts
    * const cFTrendCharts = await prisma.cFTrendChart.findMany()
    * ```
    */
  get cFTrendChart(): Prisma.CFTrendChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eAConsumptionTrend`: Exposes CRUD operations for the **EAConsumptionTrend** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EAConsumptionTrends
    * const eAConsumptionTrends = await prisma.eAConsumptionTrend.findMany()
    * ```
    */
  get eAConsumptionTrend(): Prisma.EAConsumptionTrendDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eAMonthSummary`: Exposes CRUD operations for the **EAMonthSummary** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EAMonthSummaries
    * const eAMonthSummaries = await prisma.eAMonthSummary.findMany()
    * ```
    */
  get eAMonthSummary(): Prisma.EAMonthSummaryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eAStrategy`: Exposes CRUD operations for the **EAStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EAStrategies
    * const eAStrategies = await prisma.eAStrategy.findMany()
    * ```
    */
  get eAStrategy(): Prisma.EAStrategyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eATypeComparison`: Exposes CRUD operations for the **EATypeComparison** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EATypeComparisons
    * const eATypeComparisons = await prisma.eATypeComparison.findMany()
    * ```
    */
  get eATypeComparison(): Prisma.EATypeComparisonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eBParamCards`: Exposes CRUD operations for the **EBParamCards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EBParamCards
    * const eBParamCards = await prisma.eBParamCards.findMany()
    * ```
    */
  get eBParamCards(): Prisma.EBParamCardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eBPieChart`: Exposes CRUD operations for the **EBPieChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EBPieCharts
    * const eBPieCharts = await prisma.eBPieChart.findMany()
    * ```
    */
  get eBPieChart(): Prisma.EBPieChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eBResults`: Exposes CRUD operations for the **EBResults** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EBResults
    * const eBResults = await prisma.eBResults.findMany()
    * ```
    */
  get eBResults(): Prisma.EBResultsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eBTrendChart`: Exposes CRUD operations for the **EBTrendChart** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EBTrendCharts
    * const eBTrendCharts = await prisma.eBTrendChart.findMany()
    * ```
    */
  get eBTrendChart(): Prisma.EBTrendChartDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eCenergyFlowRealTime`: Exposes CRUD operations for the **ECenergyFlowRealTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ECenergyFlowRealTimes
    * const eCenergyFlowRealTimes = await prisma.eCenergyFlowRealTime.findMany()
    * ```
    */
  get eCenergyFlowRealTime(): Prisma.ECenergyFlowRealTimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eCenergyTypes`: Exposes CRUD operations for the **ECenergyTypes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ECenergyTypes
    * const eCenergyTypes = await prisma.eCenergyTypes.findMany()
    * ```
    */
  get eCenergyTypes(): Prisma.ECenergyTypesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eChistory`: Exposes CRUD operations for the **EChistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EChistories
    * const eChistories = await prisma.eChistory.findMany()
    * ```
    */
  get eChistory(): Prisma.EChistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eCrealTime`: Exposes CRUD operations for the **ECrealTime** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ECrealTimes
    * const eCrealTimes = await prisma.eCrealTime.findMany()
    * ```
    */
  get eCrealTime(): Prisma.ECrealTimeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eEBenchmarkRankCards`: Exposes CRUD operations for the **EEBenchmarkRankCards** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EEBenchmarkRankCards
    * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findMany()
    * ```
    */
  get eEBenchmarkRankCards(): Prisma.EEBenchmarkRankCardsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eEGaugeMetrics`: Exposes CRUD operations for the **EEGaugeMetrics** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EEGaugeMetrics
    * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findMany()
    * ```
    */
  get eEGaugeMetrics(): Prisma.EEGaugeMetricsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eERankingList`: Exposes CRUD operations for the **EERankingList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EERankingLists
    * const eERankingLists = await prisma.eERankingList.findMany()
    * ```
    */
  get eERankingList(): Prisma.EERankingListDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eETrendChartData`: Exposes CRUD operations for the **EETrendChartData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EETrendChartData
    * const eETrendChartData = await prisma.eETrendChartData.findMany()
    * ```
    */
  get eETrendChartData(): Prisma.EETrendChartDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eFSankeyLinks`: Exposes CRUD operations for the **EFSankeyLinks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EFSankeyLinks
    * const eFSankeyLinks = await prisma.eFSankeyLinks.findMany()
    * ```
    */
  get eFSankeyLinks(): Prisma.EFSankeyLinksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eFSankeyNodes`: Exposes CRUD operations for the **EFSankeyNodes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EFSankeyNodes
    * const eFSankeyNodes = await prisma.eFSankeyNodes.findMany()
    * ```
    */
  get eFSankeyNodes(): Prisma.EFSankeyNodesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eFSummaryTable`: Exposes CRUD operations for the **EFSummaryTable** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EFSummaryTables
    * const eFSummaryTables = await prisma.eFSummaryTable.findMany()
    * ```
    */
  get eFSummaryTable(): Prisma.EFSummaryTableDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sCRanking`: Exposes CRUD operations for the **SCRanking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SCRankings
    * const sCRankings = await prisma.sCRanking.findMany()
    * ```
    */
  get sCRanking(): Prisma.SCRankingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sCSankeyData`: Exposes CRUD operations for the **SCSankeyData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SCSankeyData
    * const sCSankeyData = await prisma.sCSankeyData.findMany()
    * ```
    */
  get sCSankeyData(): Prisma.SCSankeyDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receiptfc`: Exposes CRUD operations for the **receiptfc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receiptfcs
    * const receiptfcs = await prisma.receiptfc.findMany()
    * ```
    */
  get receiptfc(): Prisma.receiptfcDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.receiptfg`: Exposes CRUD operations for the **receiptfg** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Receiptfgs
    * const receiptfgs = await prisma.receiptfg.findMany()
    * ```
    */
  get receiptfg(): Prisma.receiptfgDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    CAHoldings: 'CAHoldings',
    CAMarketCards: 'CAMarketCards',
    CAPieChart: 'CAPieChart',
    CAPriceChart: 'CAPriceChart',
    CBComparisonChart: 'CBComparisonChart',
    CBMonthlyDetails: 'CBMonthlyDetails',
    CBSummaryCards: 'CBSummaryCards',
    CFDetails: 'CFDetails',
    CFPieChart: 'CFPieChart',
    CFTrendChart: 'CFTrendChart',
    EAConsumptionTrend: 'EAConsumptionTrend',
    EAMonthSummary: 'EAMonthSummary',
    EAStrategy: 'EAStrategy',
    EATypeComparison: 'EATypeComparison',
    EBParamCards: 'EBParamCards',
    EBPieChart: 'EBPieChart',
    EBResults: 'EBResults',
    EBTrendChart: 'EBTrendChart',
    ECenergyFlowRealTime: 'ECenergyFlowRealTime',
    ECenergyTypes: 'ECenergyTypes',
    EChistory: 'EChistory',
    ECrealTime: 'ECrealTime',
    EEBenchmarkRankCards: 'EEBenchmarkRankCards',
    EEGaugeMetrics: 'EEGaugeMetrics',
    EERankingList: 'EERankingList',
    EETrendChartData: 'EETrendChartData',
    EFSankeyLinks: 'EFSankeyLinks',
    EFSankeyNodes: 'EFSankeyNodes',
    EFSummaryTable: 'EFSummaryTable',
    SCRanking: 'SCRanking',
    SCSankeyData: 'SCSankeyData',
    receiptfc: 'receiptfc',
    receiptfg: 'receiptfg'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "cAHoldings" | "cAMarketCards" | "cAPieChart" | "cAPriceChart" | "cBComparisonChart" | "cBMonthlyDetails" | "cBSummaryCards" | "cFDetails" | "cFPieChart" | "cFTrendChart" | "eAConsumptionTrend" | "eAMonthSummary" | "eAStrategy" | "eATypeComparison" | "eBParamCards" | "eBPieChart" | "eBResults" | "eBTrendChart" | "eCenergyFlowRealTime" | "eCenergyTypes" | "eChistory" | "eCrealTime" | "eEBenchmarkRankCards" | "eEGaugeMetrics" | "eERankingList" | "eETrendChartData" | "eFSankeyLinks" | "eFSankeyNodes" | "eFSummaryTable" | "sCRanking" | "sCSankeyData" | "receiptfc" | "receiptfg"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      CAHoldings: {
        payload: Prisma.$CAHoldingsPayload<ExtArgs>
        fields: Prisma.CAHoldingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CAHoldingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CAHoldingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>
          }
          findFirst: {
            args: Prisma.CAHoldingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CAHoldingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>
          }
          findMany: {
            args: Prisma.CAHoldingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>[]
          }
          create: {
            args: Prisma.CAHoldingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>
          }
          createMany: {
            args: Prisma.CAHoldingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CAHoldingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>
          }
          update: {
            args: Prisma.CAHoldingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>
          }
          deleteMany: {
            args: Prisma.CAHoldingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CAHoldingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CAHoldingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAHoldingsPayload>
          }
          aggregate: {
            args: Prisma.CAHoldingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCAHoldings>
          }
          groupBy: {
            args: Prisma.CAHoldingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CAHoldingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CAHoldingsCountArgs<ExtArgs>
            result: $Utils.Optional<CAHoldingsCountAggregateOutputType> | number
          }
        }
      }
      CAMarketCards: {
        payload: Prisma.$CAMarketCardsPayload<ExtArgs>
        fields: Prisma.CAMarketCardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CAMarketCardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CAMarketCardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>
          }
          findFirst: {
            args: Prisma.CAMarketCardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CAMarketCardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>
          }
          findMany: {
            args: Prisma.CAMarketCardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>[]
          }
          create: {
            args: Prisma.CAMarketCardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>
          }
          createMany: {
            args: Prisma.CAMarketCardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CAMarketCardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>
          }
          update: {
            args: Prisma.CAMarketCardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>
          }
          deleteMany: {
            args: Prisma.CAMarketCardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CAMarketCardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CAMarketCardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAMarketCardsPayload>
          }
          aggregate: {
            args: Prisma.CAMarketCardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCAMarketCards>
          }
          groupBy: {
            args: Prisma.CAMarketCardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CAMarketCardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CAMarketCardsCountArgs<ExtArgs>
            result: $Utils.Optional<CAMarketCardsCountAggregateOutputType> | number
          }
        }
      }
      CAPieChart: {
        payload: Prisma.$CAPieChartPayload<ExtArgs>
        fields: Prisma.CAPieChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CAPieChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CAPieChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>
          }
          findFirst: {
            args: Prisma.CAPieChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CAPieChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>
          }
          findMany: {
            args: Prisma.CAPieChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>[]
          }
          create: {
            args: Prisma.CAPieChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>
          }
          createMany: {
            args: Prisma.CAPieChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CAPieChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>
          }
          update: {
            args: Prisma.CAPieChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>
          }
          deleteMany: {
            args: Prisma.CAPieChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CAPieChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CAPieChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPieChartPayload>
          }
          aggregate: {
            args: Prisma.CAPieChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCAPieChart>
          }
          groupBy: {
            args: Prisma.CAPieChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CAPieChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CAPieChartCountArgs<ExtArgs>
            result: $Utils.Optional<CAPieChartCountAggregateOutputType> | number
          }
        }
      }
      CAPriceChart: {
        payload: Prisma.$CAPriceChartPayload<ExtArgs>
        fields: Prisma.CAPriceChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CAPriceChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CAPriceChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>
          }
          findFirst: {
            args: Prisma.CAPriceChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CAPriceChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>
          }
          findMany: {
            args: Prisma.CAPriceChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>[]
          }
          create: {
            args: Prisma.CAPriceChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>
          }
          createMany: {
            args: Prisma.CAPriceChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CAPriceChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>
          }
          update: {
            args: Prisma.CAPriceChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>
          }
          deleteMany: {
            args: Prisma.CAPriceChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CAPriceChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CAPriceChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CAPriceChartPayload>
          }
          aggregate: {
            args: Prisma.CAPriceChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCAPriceChart>
          }
          groupBy: {
            args: Prisma.CAPriceChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CAPriceChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CAPriceChartCountArgs<ExtArgs>
            result: $Utils.Optional<CAPriceChartCountAggregateOutputType> | number
          }
        }
      }
      CBComparisonChart: {
        payload: Prisma.$CBComparisonChartPayload<ExtArgs>
        fields: Prisma.CBComparisonChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CBComparisonChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CBComparisonChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>
          }
          findFirst: {
            args: Prisma.CBComparisonChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CBComparisonChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>
          }
          findMany: {
            args: Prisma.CBComparisonChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>[]
          }
          create: {
            args: Prisma.CBComparisonChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>
          }
          createMany: {
            args: Prisma.CBComparisonChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CBComparisonChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>
          }
          update: {
            args: Prisma.CBComparisonChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>
          }
          deleteMany: {
            args: Prisma.CBComparisonChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CBComparisonChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CBComparisonChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBComparisonChartPayload>
          }
          aggregate: {
            args: Prisma.CBComparisonChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCBComparisonChart>
          }
          groupBy: {
            args: Prisma.CBComparisonChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CBComparisonChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CBComparisonChartCountArgs<ExtArgs>
            result: $Utils.Optional<CBComparisonChartCountAggregateOutputType> | number
          }
        }
      }
      CBMonthlyDetails: {
        payload: Prisma.$CBMonthlyDetailsPayload<ExtArgs>
        fields: Prisma.CBMonthlyDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CBMonthlyDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CBMonthlyDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>
          }
          findFirst: {
            args: Prisma.CBMonthlyDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CBMonthlyDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>
          }
          findMany: {
            args: Prisma.CBMonthlyDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>[]
          }
          create: {
            args: Prisma.CBMonthlyDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>
          }
          createMany: {
            args: Prisma.CBMonthlyDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CBMonthlyDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>
          }
          update: {
            args: Prisma.CBMonthlyDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>
          }
          deleteMany: {
            args: Prisma.CBMonthlyDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CBMonthlyDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CBMonthlyDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBMonthlyDetailsPayload>
          }
          aggregate: {
            args: Prisma.CBMonthlyDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCBMonthlyDetails>
          }
          groupBy: {
            args: Prisma.CBMonthlyDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CBMonthlyDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CBMonthlyDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<CBMonthlyDetailsCountAggregateOutputType> | number
          }
        }
      }
      CBSummaryCards: {
        payload: Prisma.$CBSummaryCardsPayload<ExtArgs>
        fields: Prisma.CBSummaryCardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CBSummaryCardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CBSummaryCardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>
          }
          findFirst: {
            args: Prisma.CBSummaryCardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CBSummaryCardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>
          }
          findMany: {
            args: Prisma.CBSummaryCardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>[]
          }
          create: {
            args: Prisma.CBSummaryCardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>
          }
          createMany: {
            args: Prisma.CBSummaryCardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CBSummaryCardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>
          }
          update: {
            args: Prisma.CBSummaryCardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>
          }
          deleteMany: {
            args: Prisma.CBSummaryCardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CBSummaryCardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CBSummaryCardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CBSummaryCardsPayload>
          }
          aggregate: {
            args: Prisma.CBSummaryCardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCBSummaryCards>
          }
          groupBy: {
            args: Prisma.CBSummaryCardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CBSummaryCardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CBSummaryCardsCountArgs<ExtArgs>
            result: $Utils.Optional<CBSummaryCardsCountAggregateOutputType> | number
          }
        }
      }
      CFDetails: {
        payload: Prisma.$CFDetailsPayload<ExtArgs>
        fields: Prisma.CFDetailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CFDetailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CFDetailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>
          }
          findFirst: {
            args: Prisma.CFDetailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CFDetailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>
          }
          findMany: {
            args: Prisma.CFDetailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>[]
          }
          create: {
            args: Prisma.CFDetailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>
          }
          createMany: {
            args: Prisma.CFDetailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CFDetailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>
          }
          update: {
            args: Prisma.CFDetailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>
          }
          deleteMany: {
            args: Prisma.CFDetailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CFDetailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CFDetailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFDetailsPayload>
          }
          aggregate: {
            args: Prisma.CFDetailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCFDetails>
          }
          groupBy: {
            args: Prisma.CFDetailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<CFDetailsGroupByOutputType>[]
          }
          count: {
            args: Prisma.CFDetailsCountArgs<ExtArgs>
            result: $Utils.Optional<CFDetailsCountAggregateOutputType> | number
          }
        }
      }
      CFPieChart: {
        payload: Prisma.$CFPieChartPayload<ExtArgs>
        fields: Prisma.CFPieChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CFPieChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CFPieChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>
          }
          findFirst: {
            args: Prisma.CFPieChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CFPieChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>
          }
          findMany: {
            args: Prisma.CFPieChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>[]
          }
          create: {
            args: Prisma.CFPieChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>
          }
          createMany: {
            args: Prisma.CFPieChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CFPieChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>
          }
          update: {
            args: Prisma.CFPieChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>
          }
          deleteMany: {
            args: Prisma.CFPieChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CFPieChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CFPieChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFPieChartPayload>
          }
          aggregate: {
            args: Prisma.CFPieChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCFPieChart>
          }
          groupBy: {
            args: Prisma.CFPieChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CFPieChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CFPieChartCountArgs<ExtArgs>
            result: $Utils.Optional<CFPieChartCountAggregateOutputType> | number
          }
        }
      }
      CFTrendChart: {
        payload: Prisma.$CFTrendChartPayload<ExtArgs>
        fields: Prisma.CFTrendChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CFTrendChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CFTrendChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>
          }
          findFirst: {
            args: Prisma.CFTrendChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CFTrendChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>
          }
          findMany: {
            args: Prisma.CFTrendChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>[]
          }
          create: {
            args: Prisma.CFTrendChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>
          }
          createMany: {
            args: Prisma.CFTrendChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CFTrendChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>
          }
          update: {
            args: Prisma.CFTrendChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>
          }
          deleteMany: {
            args: Prisma.CFTrendChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CFTrendChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CFTrendChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CFTrendChartPayload>
          }
          aggregate: {
            args: Prisma.CFTrendChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCFTrendChart>
          }
          groupBy: {
            args: Prisma.CFTrendChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<CFTrendChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.CFTrendChartCountArgs<ExtArgs>
            result: $Utils.Optional<CFTrendChartCountAggregateOutputType> | number
          }
        }
      }
      EAConsumptionTrend: {
        payload: Prisma.$EAConsumptionTrendPayload<ExtArgs>
        fields: Prisma.EAConsumptionTrendFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EAConsumptionTrendFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EAConsumptionTrendFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>
          }
          findFirst: {
            args: Prisma.EAConsumptionTrendFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EAConsumptionTrendFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>
          }
          findMany: {
            args: Prisma.EAConsumptionTrendFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>[]
          }
          create: {
            args: Prisma.EAConsumptionTrendCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>
          }
          createMany: {
            args: Prisma.EAConsumptionTrendCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EAConsumptionTrendDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>
          }
          update: {
            args: Prisma.EAConsumptionTrendUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>
          }
          deleteMany: {
            args: Prisma.EAConsumptionTrendDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EAConsumptionTrendUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EAConsumptionTrendUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAConsumptionTrendPayload>
          }
          aggregate: {
            args: Prisma.EAConsumptionTrendAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEAConsumptionTrend>
          }
          groupBy: {
            args: Prisma.EAConsumptionTrendGroupByArgs<ExtArgs>
            result: $Utils.Optional<EAConsumptionTrendGroupByOutputType>[]
          }
          count: {
            args: Prisma.EAConsumptionTrendCountArgs<ExtArgs>
            result: $Utils.Optional<EAConsumptionTrendCountAggregateOutputType> | number
          }
        }
      }
      EAMonthSummary: {
        payload: Prisma.$EAMonthSummaryPayload<ExtArgs>
        fields: Prisma.EAMonthSummaryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EAMonthSummaryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EAMonthSummaryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>
          }
          findFirst: {
            args: Prisma.EAMonthSummaryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EAMonthSummaryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>
          }
          findMany: {
            args: Prisma.EAMonthSummaryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>[]
          }
          create: {
            args: Prisma.EAMonthSummaryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>
          }
          createMany: {
            args: Prisma.EAMonthSummaryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EAMonthSummaryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>
          }
          update: {
            args: Prisma.EAMonthSummaryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>
          }
          deleteMany: {
            args: Prisma.EAMonthSummaryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EAMonthSummaryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EAMonthSummaryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAMonthSummaryPayload>
          }
          aggregate: {
            args: Prisma.EAMonthSummaryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEAMonthSummary>
          }
          groupBy: {
            args: Prisma.EAMonthSummaryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EAMonthSummaryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EAMonthSummaryCountArgs<ExtArgs>
            result: $Utils.Optional<EAMonthSummaryCountAggregateOutputType> | number
          }
        }
      }
      EAStrategy: {
        payload: Prisma.$EAStrategyPayload<ExtArgs>
        fields: Prisma.EAStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EAStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EAStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>
          }
          findFirst: {
            args: Prisma.EAStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EAStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>
          }
          findMany: {
            args: Prisma.EAStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>[]
          }
          create: {
            args: Prisma.EAStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>
          }
          createMany: {
            args: Prisma.EAStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EAStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>
          }
          update: {
            args: Prisma.EAStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>
          }
          deleteMany: {
            args: Prisma.EAStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EAStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EAStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EAStrategyPayload>
          }
          aggregate: {
            args: Prisma.EAStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEAStrategy>
          }
          groupBy: {
            args: Prisma.EAStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<EAStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.EAStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<EAStrategyCountAggregateOutputType> | number
          }
        }
      }
      EATypeComparison: {
        payload: Prisma.$EATypeComparisonPayload<ExtArgs>
        fields: Prisma.EATypeComparisonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EATypeComparisonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EATypeComparisonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>
          }
          findFirst: {
            args: Prisma.EATypeComparisonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EATypeComparisonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>
          }
          findMany: {
            args: Prisma.EATypeComparisonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>[]
          }
          create: {
            args: Prisma.EATypeComparisonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>
          }
          createMany: {
            args: Prisma.EATypeComparisonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EATypeComparisonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>
          }
          update: {
            args: Prisma.EATypeComparisonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>
          }
          deleteMany: {
            args: Prisma.EATypeComparisonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EATypeComparisonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EATypeComparisonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EATypeComparisonPayload>
          }
          aggregate: {
            args: Prisma.EATypeComparisonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEATypeComparison>
          }
          groupBy: {
            args: Prisma.EATypeComparisonGroupByArgs<ExtArgs>
            result: $Utils.Optional<EATypeComparisonGroupByOutputType>[]
          }
          count: {
            args: Prisma.EATypeComparisonCountArgs<ExtArgs>
            result: $Utils.Optional<EATypeComparisonCountAggregateOutputType> | number
          }
        }
      }
      EBParamCards: {
        payload: Prisma.$EBParamCardsPayload<ExtArgs>
        fields: Prisma.EBParamCardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EBParamCardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EBParamCardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>
          }
          findFirst: {
            args: Prisma.EBParamCardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EBParamCardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>
          }
          findMany: {
            args: Prisma.EBParamCardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>[]
          }
          create: {
            args: Prisma.EBParamCardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>
          }
          createMany: {
            args: Prisma.EBParamCardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EBParamCardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>
          }
          update: {
            args: Prisma.EBParamCardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>
          }
          deleteMany: {
            args: Prisma.EBParamCardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EBParamCardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EBParamCardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBParamCardsPayload>
          }
          aggregate: {
            args: Prisma.EBParamCardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEBParamCards>
          }
          groupBy: {
            args: Prisma.EBParamCardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EBParamCardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EBParamCardsCountArgs<ExtArgs>
            result: $Utils.Optional<EBParamCardsCountAggregateOutputType> | number
          }
        }
      }
      EBPieChart: {
        payload: Prisma.$EBPieChartPayload<ExtArgs>
        fields: Prisma.EBPieChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EBPieChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EBPieChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>
          }
          findFirst: {
            args: Prisma.EBPieChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EBPieChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>
          }
          findMany: {
            args: Prisma.EBPieChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>[]
          }
          create: {
            args: Prisma.EBPieChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>
          }
          createMany: {
            args: Prisma.EBPieChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EBPieChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>
          }
          update: {
            args: Prisma.EBPieChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>
          }
          deleteMany: {
            args: Prisma.EBPieChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EBPieChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EBPieChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBPieChartPayload>
          }
          aggregate: {
            args: Prisma.EBPieChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEBPieChart>
          }
          groupBy: {
            args: Prisma.EBPieChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<EBPieChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.EBPieChartCountArgs<ExtArgs>
            result: $Utils.Optional<EBPieChartCountAggregateOutputType> | number
          }
        }
      }
      EBResults: {
        payload: Prisma.$EBResultsPayload<ExtArgs>
        fields: Prisma.EBResultsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EBResultsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EBResultsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>
          }
          findFirst: {
            args: Prisma.EBResultsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EBResultsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>
          }
          findMany: {
            args: Prisma.EBResultsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>[]
          }
          create: {
            args: Prisma.EBResultsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>
          }
          createMany: {
            args: Prisma.EBResultsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EBResultsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>
          }
          update: {
            args: Prisma.EBResultsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>
          }
          deleteMany: {
            args: Prisma.EBResultsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EBResultsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EBResultsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBResultsPayload>
          }
          aggregate: {
            args: Prisma.EBResultsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEBResults>
          }
          groupBy: {
            args: Prisma.EBResultsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EBResultsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EBResultsCountArgs<ExtArgs>
            result: $Utils.Optional<EBResultsCountAggregateOutputType> | number
          }
        }
      }
      EBTrendChart: {
        payload: Prisma.$EBTrendChartPayload<ExtArgs>
        fields: Prisma.EBTrendChartFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EBTrendChartFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EBTrendChartFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>
          }
          findFirst: {
            args: Prisma.EBTrendChartFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EBTrendChartFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>
          }
          findMany: {
            args: Prisma.EBTrendChartFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>[]
          }
          create: {
            args: Prisma.EBTrendChartCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>
          }
          createMany: {
            args: Prisma.EBTrendChartCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EBTrendChartDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>
          }
          update: {
            args: Prisma.EBTrendChartUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>
          }
          deleteMany: {
            args: Prisma.EBTrendChartDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EBTrendChartUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EBTrendChartUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EBTrendChartPayload>
          }
          aggregate: {
            args: Prisma.EBTrendChartAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEBTrendChart>
          }
          groupBy: {
            args: Prisma.EBTrendChartGroupByArgs<ExtArgs>
            result: $Utils.Optional<EBTrendChartGroupByOutputType>[]
          }
          count: {
            args: Prisma.EBTrendChartCountArgs<ExtArgs>
            result: $Utils.Optional<EBTrendChartCountAggregateOutputType> | number
          }
        }
      }
      ECenergyFlowRealTime: {
        payload: Prisma.$ECenergyFlowRealTimePayload<ExtArgs>
        fields: Prisma.ECenergyFlowRealTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ECenergyFlowRealTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ECenergyFlowRealTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>
          }
          findFirst: {
            args: Prisma.ECenergyFlowRealTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ECenergyFlowRealTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>
          }
          findMany: {
            args: Prisma.ECenergyFlowRealTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>[]
          }
          create: {
            args: Prisma.ECenergyFlowRealTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>
          }
          createMany: {
            args: Prisma.ECenergyFlowRealTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ECenergyFlowRealTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>
          }
          update: {
            args: Prisma.ECenergyFlowRealTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>
          }
          deleteMany: {
            args: Prisma.ECenergyFlowRealTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ECenergyFlowRealTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ECenergyFlowRealTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyFlowRealTimePayload>
          }
          aggregate: {
            args: Prisma.ECenergyFlowRealTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateECenergyFlowRealTime>
          }
          groupBy: {
            args: Prisma.ECenergyFlowRealTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ECenergyFlowRealTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ECenergyFlowRealTimeCountArgs<ExtArgs>
            result: $Utils.Optional<ECenergyFlowRealTimeCountAggregateOutputType> | number
          }
        }
      }
      ECenergyTypes: {
        payload: Prisma.$ECenergyTypesPayload<ExtArgs>
        fields: Prisma.ECenergyTypesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ECenergyTypesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ECenergyTypesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>
          }
          findFirst: {
            args: Prisma.ECenergyTypesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ECenergyTypesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>
          }
          findMany: {
            args: Prisma.ECenergyTypesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>[]
          }
          create: {
            args: Prisma.ECenergyTypesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>
          }
          createMany: {
            args: Prisma.ECenergyTypesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ECenergyTypesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>
          }
          update: {
            args: Prisma.ECenergyTypesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>
          }
          deleteMany: {
            args: Prisma.ECenergyTypesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ECenergyTypesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ECenergyTypesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECenergyTypesPayload>
          }
          aggregate: {
            args: Prisma.ECenergyTypesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateECenergyTypes>
          }
          groupBy: {
            args: Prisma.ECenergyTypesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ECenergyTypesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ECenergyTypesCountArgs<ExtArgs>
            result: $Utils.Optional<ECenergyTypesCountAggregateOutputType> | number
          }
        }
      }
      EChistory: {
        payload: Prisma.$EChistoryPayload<ExtArgs>
        fields: Prisma.EChistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EChistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EChistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>
          }
          findFirst: {
            args: Prisma.EChistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EChistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>
          }
          findMany: {
            args: Prisma.EChistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>[]
          }
          create: {
            args: Prisma.EChistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>
          }
          createMany: {
            args: Prisma.EChistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EChistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>
          }
          update: {
            args: Prisma.EChistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>
          }
          deleteMany: {
            args: Prisma.EChistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EChistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EChistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EChistoryPayload>
          }
          aggregate: {
            args: Prisma.EChistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEChistory>
          }
          groupBy: {
            args: Prisma.EChistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EChistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EChistoryCountArgs<ExtArgs>
            result: $Utils.Optional<EChistoryCountAggregateOutputType> | number
          }
        }
      }
      ECrealTime: {
        payload: Prisma.$ECrealTimePayload<ExtArgs>
        fields: Prisma.ECrealTimeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ECrealTimeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ECrealTimeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>
          }
          findFirst: {
            args: Prisma.ECrealTimeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ECrealTimeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>
          }
          findMany: {
            args: Prisma.ECrealTimeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>[]
          }
          create: {
            args: Prisma.ECrealTimeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>
          }
          createMany: {
            args: Prisma.ECrealTimeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ECrealTimeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>
          }
          update: {
            args: Prisma.ECrealTimeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>
          }
          deleteMany: {
            args: Prisma.ECrealTimeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ECrealTimeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ECrealTimeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ECrealTimePayload>
          }
          aggregate: {
            args: Prisma.ECrealTimeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateECrealTime>
          }
          groupBy: {
            args: Prisma.ECrealTimeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ECrealTimeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ECrealTimeCountArgs<ExtArgs>
            result: $Utils.Optional<ECrealTimeCountAggregateOutputType> | number
          }
        }
      }
      EEBenchmarkRankCards: {
        payload: Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>
        fields: Prisma.EEBenchmarkRankCardsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EEBenchmarkRankCardsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EEBenchmarkRankCardsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>
          }
          findFirst: {
            args: Prisma.EEBenchmarkRankCardsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EEBenchmarkRankCardsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>
          }
          findMany: {
            args: Prisma.EEBenchmarkRankCardsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>[]
          }
          create: {
            args: Prisma.EEBenchmarkRankCardsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>
          }
          createMany: {
            args: Prisma.EEBenchmarkRankCardsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EEBenchmarkRankCardsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>
          }
          update: {
            args: Prisma.EEBenchmarkRankCardsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>
          }
          deleteMany: {
            args: Prisma.EEBenchmarkRankCardsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EEBenchmarkRankCardsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EEBenchmarkRankCardsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEBenchmarkRankCardsPayload>
          }
          aggregate: {
            args: Prisma.EEBenchmarkRankCardsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEEBenchmarkRankCards>
          }
          groupBy: {
            args: Prisma.EEBenchmarkRankCardsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EEBenchmarkRankCardsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EEBenchmarkRankCardsCountArgs<ExtArgs>
            result: $Utils.Optional<EEBenchmarkRankCardsCountAggregateOutputType> | number
          }
        }
      }
      EEGaugeMetrics: {
        payload: Prisma.$EEGaugeMetricsPayload<ExtArgs>
        fields: Prisma.EEGaugeMetricsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EEGaugeMetricsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EEGaugeMetricsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>
          }
          findFirst: {
            args: Prisma.EEGaugeMetricsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EEGaugeMetricsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>
          }
          findMany: {
            args: Prisma.EEGaugeMetricsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>[]
          }
          create: {
            args: Prisma.EEGaugeMetricsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>
          }
          createMany: {
            args: Prisma.EEGaugeMetricsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EEGaugeMetricsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>
          }
          update: {
            args: Prisma.EEGaugeMetricsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>
          }
          deleteMany: {
            args: Prisma.EEGaugeMetricsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EEGaugeMetricsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EEGaugeMetricsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EEGaugeMetricsPayload>
          }
          aggregate: {
            args: Prisma.EEGaugeMetricsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEEGaugeMetrics>
          }
          groupBy: {
            args: Prisma.EEGaugeMetricsGroupByArgs<ExtArgs>
            result: $Utils.Optional<EEGaugeMetricsGroupByOutputType>[]
          }
          count: {
            args: Prisma.EEGaugeMetricsCountArgs<ExtArgs>
            result: $Utils.Optional<EEGaugeMetricsCountAggregateOutputType> | number
          }
        }
      }
      EERankingList: {
        payload: Prisma.$EERankingListPayload<ExtArgs>
        fields: Prisma.EERankingListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EERankingListFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EERankingListFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>
          }
          findFirst: {
            args: Prisma.EERankingListFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EERankingListFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>
          }
          findMany: {
            args: Prisma.EERankingListFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>[]
          }
          create: {
            args: Prisma.EERankingListCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>
          }
          createMany: {
            args: Prisma.EERankingListCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EERankingListDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>
          }
          update: {
            args: Prisma.EERankingListUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>
          }
          deleteMany: {
            args: Prisma.EERankingListDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EERankingListUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EERankingListUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EERankingListPayload>
          }
          aggregate: {
            args: Prisma.EERankingListAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEERankingList>
          }
          groupBy: {
            args: Prisma.EERankingListGroupByArgs<ExtArgs>
            result: $Utils.Optional<EERankingListGroupByOutputType>[]
          }
          count: {
            args: Prisma.EERankingListCountArgs<ExtArgs>
            result: $Utils.Optional<EERankingListCountAggregateOutputType> | number
          }
        }
      }
      EETrendChartData: {
        payload: Prisma.$EETrendChartDataPayload<ExtArgs>
        fields: Prisma.EETrendChartDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EETrendChartDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EETrendChartDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>
          }
          findFirst: {
            args: Prisma.EETrendChartDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EETrendChartDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>
          }
          findMany: {
            args: Prisma.EETrendChartDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>[]
          }
          create: {
            args: Prisma.EETrendChartDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>
          }
          createMany: {
            args: Prisma.EETrendChartDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EETrendChartDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>
          }
          update: {
            args: Prisma.EETrendChartDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>
          }
          deleteMany: {
            args: Prisma.EETrendChartDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EETrendChartDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EETrendChartDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EETrendChartDataPayload>
          }
          aggregate: {
            args: Prisma.EETrendChartDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEETrendChartData>
          }
          groupBy: {
            args: Prisma.EETrendChartDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<EETrendChartDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.EETrendChartDataCountArgs<ExtArgs>
            result: $Utils.Optional<EETrendChartDataCountAggregateOutputType> | number
          }
        }
      }
      EFSankeyLinks: {
        payload: Prisma.$EFSankeyLinksPayload<ExtArgs>
        fields: Prisma.EFSankeyLinksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFSankeyLinksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFSankeyLinksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>
          }
          findFirst: {
            args: Prisma.EFSankeyLinksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFSankeyLinksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>
          }
          findMany: {
            args: Prisma.EFSankeyLinksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>[]
          }
          create: {
            args: Prisma.EFSankeyLinksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>
          }
          createMany: {
            args: Prisma.EFSankeyLinksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EFSankeyLinksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>
          }
          update: {
            args: Prisma.EFSankeyLinksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>
          }
          deleteMany: {
            args: Prisma.EFSankeyLinksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EFSankeyLinksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EFSankeyLinksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyLinksPayload>
          }
          aggregate: {
            args: Prisma.EFSankeyLinksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEFSankeyLinks>
          }
          groupBy: {
            args: Prisma.EFSankeyLinksGroupByArgs<ExtArgs>
            result: $Utils.Optional<EFSankeyLinksGroupByOutputType>[]
          }
          count: {
            args: Prisma.EFSankeyLinksCountArgs<ExtArgs>
            result: $Utils.Optional<EFSankeyLinksCountAggregateOutputType> | number
          }
        }
      }
      EFSankeyNodes: {
        payload: Prisma.$EFSankeyNodesPayload<ExtArgs>
        fields: Prisma.EFSankeyNodesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFSankeyNodesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFSankeyNodesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>
          }
          findFirst: {
            args: Prisma.EFSankeyNodesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFSankeyNodesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>
          }
          findMany: {
            args: Prisma.EFSankeyNodesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>[]
          }
          create: {
            args: Prisma.EFSankeyNodesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>
          }
          createMany: {
            args: Prisma.EFSankeyNodesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EFSankeyNodesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>
          }
          update: {
            args: Prisma.EFSankeyNodesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>
          }
          deleteMany: {
            args: Prisma.EFSankeyNodesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EFSankeyNodesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EFSankeyNodesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSankeyNodesPayload>
          }
          aggregate: {
            args: Prisma.EFSankeyNodesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEFSankeyNodes>
          }
          groupBy: {
            args: Prisma.EFSankeyNodesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EFSankeyNodesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EFSankeyNodesCountArgs<ExtArgs>
            result: $Utils.Optional<EFSankeyNodesCountAggregateOutputType> | number
          }
        }
      }
      EFSummaryTable: {
        payload: Prisma.$EFSummaryTablePayload<ExtArgs>
        fields: Prisma.EFSummaryTableFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EFSummaryTableFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EFSummaryTableFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>
          }
          findFirst: {
            args: Prisma.EFSummaryTableFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EFSummaryTableFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>
          }
          findMany: {
            args: Prisma.EFSummaryTableFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>[]
          }
          create: {
            args: Prisma.EFSummaryTableCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>
          }
          createMany: {
            args: Prisma.EFSummaryTableCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EFSummaryTableDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>
          }
          update: {
            args: Prisma.EFSummaryTableUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>
          }
          deleteMany: {
            args: Prisma.EFSummaryTableDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EFSummaryTableUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EFSummaryTableUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EFSummaryTablePayload>
          }
          aggregate: {
            args: Prisma.EFSummaryTableAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEFSummaryTable>
          }
          groupBy: {
            args: Prisma.EFSummaryTableGroupByArgs<ExtArgs>
            result: $Utils.Optional<EFSummaryTableGroupByOutputType>[]
          }
          count: {
            args: Prisma.EFSummaryTableCountArgs<ExtArgs>
            result: $Utils.Optional<EFSummaryTableCountAggregateOutputType> | number
          }
        }
      }
      SCRanking: {
        payload: Prisma.$SCRankingPayload<ExtArgs>
        fields: Prisma.SCRankingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SCRankingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SCRankingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>
          }
          findFirst: {
            args: Prisma.SCRankingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SCRankingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>
          }
          findMany: {
            args: Prisma.SCRankingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>[]
          }
          create: {
            args: Prisma.SCRankingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>
          }
          createMany: {
            args: Prisma.SCRankingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SCRankingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>
          }
          update: {
            args: Prisma.SCRankingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>
          }
          deleteMany: {
            args: Prisma.SCRankingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SCRankingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SCRankingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCRankingPayload>
          }
          aggregate: {
            args: Prisma.SCRankingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSCRanking>
          }
          groupBy: {
            args: Prisma.SCRankingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SCRankingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SCRankingCountArgs<ExtArgs>
            result: $Utils.Optional<SCRankingCountAggregateOutputType> | number
          }
        }
      }
      SCSankeyData: {
        payload: Prisma.$SCSankeyDataPayload<ExtArgs>
        fields: Prisma.SCSankeyDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SCSankeyDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SCSankeyDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>
          }
          findFirst: {
            args: Prisma.SCSankeyDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SCSankeyDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>
          }
          findMany: {
            args: Prisma.SCSankeyDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>[]
          }
          create: {
            args: Prisma.SCSankeyDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>
          }
          createMany: {
            args: Prisma.SCSankeyDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SCSankeyDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>
          }
          update: {
            args: Prisma.SCSankeyDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>
          }
          deleteMany: {
            args: Prisma.SCSankeyDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SCSankeyDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SCSankeyDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SCSankeyDataPayload>
          }
          aggregate: {
            args: Prisma.SCSankeyDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSCSankeyData>
          }
          groupBy: {
            args: Prisma.SCSankeyDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<SCSankeyDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.SCSankeyDataCountArgs<ExtArgs>
            result: $Utils.Optional<SCSankeyDataCountAggregateOutputType> | number
          }
        }
      }
      receiptfc: {
        payload: Prisma.$receiptfcPayload<ExtArgs>
        fields: Prisma.receiptfcFieldRefs
        operations: {
          findUnique: {
            args: Prisma.receiptfcFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.receiptfcFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>
          }
          findFirst: {
            args: Prisma.receiptfcFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.receiptfcFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>
          }
          findMany: {
            args: Prisma.receiptfcFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>[]
          }
          create: {
            args: Prisma.receiptfcCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>
          }
          createMany: {
            args: Prisma.receiptfcCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.receiptfcDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>
          }
          update: {
            args: Prisma.receiptfcUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>
          }
          deleteMany: {
            args: Prisma.receiptfcDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.receiptfcUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.receiptfcUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfcPayload>
          }
          aggregate: {
            args: Prisma.ReceiptfcAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceiptfc>
          }
          groupBy: {
            args: Prisma.receiptfcGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptfcGroupByOutputType>[]
          }
          count: {
            args: Prisma.receiptfcCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptfcCountAggregateOutputType> | number
          }
        }
      }
      receiptfg: {
        payload: Prisma.$receiptfgPayload<ExtArgs>
        fields: Prisma.receiptfgFieldRefs
        operations: {
          findUnique: {
            args: Prisma.receiptfgFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.receiptfgFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>
          }
          findFirst: {
            args: Prisma.receiptfgFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.receiptfgFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>
          }
          findMany: {
            args: Prisma.receiptfgFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>[]
          }
          create: {
            args: Prisma.receiptfgCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>
          }
          createMany: {
            args: Prisma.receiptfgCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.receiptfgDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>
          }
          update: {
            args: Prisma.receiptfgUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>
          }
          deleteMany: {
            args: Prisma.receiptfgDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.receiptfgUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.receiptfgUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$receiptfgPayload>
          }
          aggregate: {
            args: Prisma.ReceiptfgAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReceiptfg>
          }
          groupBy: {
            args: Prisma.receiptfgGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReceiptfgGroupByOutputType>[]
          }
          count: {
            args: Prisma.receiptfgCountArgs<ExtArgs>
            result: $Utils.Optional<ReceiptfgCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    cAHoldings?: CAHoldingsOmit
    cAMarketCards?: CAMarketCardsOmit
    cAPieChart?: CAPieChartOmit
    cAPriceChart?: CAPriceChartOmit
    cBComparisonChart?: CBComparisonChartOmit
    cBMonthlyDetails?: CBMonthlyDetailsOmit
    cBSummaryCards?: CBSummaryCardsOmit
    cFDetails?: CFDetailsOmit
    cFPieChart?: CFPieChartOmit
    cFTrendChart?: CFTrendChartOmit
    eAConsumptionTrend?: EAConsumptionTrendOmit
    eAMonthSummary?: EAMonthSummaryOmit
    eAStrategy?: EAStrategyOmit
    eATypeComparison?: EATypeComparisonOmit
    eBParamCards?: EBParamCardsOmit
    eBPieChart?: EBPieChartOmit
    eBResults?: EBResultsOmit
    eBTrendChart?: EBTrendChartOmit
    eCenergyFlowRealTime?: ECenergyFlowRealTimeOmit
    eCenergyTypes?: ECenergyTypesOmit
    eChistory?: EChistoryOmit
    eCrealTime?: ECrealTimeOmit
    eEBenchmarkRankCards?: EEBenchmarkRankCardsOmit
    eEGaugeMetrics?: EEGaugeMetricsOmit
    eERankingList?: EERankingListOmit
    eETrendChartData?: EETrendChartDataOmit
    eFSankeyLinks?: EFSankeyLinksOmit
    eFSankeyNodes?: EFSankeyNodesOmit
    eFSummaryTable?: EFSummaryTableOmit
    sCRanking?: SCRankingOmit
    sCSankeyData?: SCSankeyDataOmit
    receiptfc?: receiptfcOmit
    receiptfg?: receiptfgOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */



  /**
   * Models
   */

  /**
   * Model CAHoldings
   */

  export type AggregateCAHoldings = {
    _count: CAHoldingsCountAggregateOutputType | null
    _avg: CAHoldingsAvgAggregateOutputType | null
    _sum: CAHoldingsSumAggregateOutputType | null
    _min: CAHoldingsMinAggregateOutputType | null
    _max: CAHoldingsMaxAggregateOutputType | null
  }

  export type CAHoldingsAvgAggregateOutputType = {
    id: number | null
  }

  export type CAHoldingsSumAggregateOutputType = {
    id: number | null
  }

  export type CAHoldingsMinAggregateOutputType = {
    id: number | null
    asset: string | null
    quantity: string | null
    value: string | null
    status: string | null
  }

  export type CAHoldingsMaxAggregateOutputType = {
    id: number | null
    asset: string | null
    quantity: string | null
    value: string | null
    status: string | null
  }

  export type CAHoldingsCountAggregateOutputType = {
    id: number
    asset: number
    quantity: number
    value: number
    status: number
    _all: number
  }


  export type CAHoldingsAvgAggregateInputType = {
    id?: true
  }

  export type CAHoldingsSumAggregateInputType = {
    id?: true
  }

  export type CAHoldingsMinAggregateInputType = {
    id?: true
    asset?: true
    quantity?: true
    value?: true
    status?: true
  }

  export type CAHoldingsMaxAggregateInputType = {
    id?: true
    asset?: true
    quantity?: true
    value?: true
    status?: true
  }

  export type CAHoldingsCountAggregateInputType = {
    id?: true
    asset?: true
    quantity?: true
    value?: true
    status?: true
    _all?: true
  }

  export type CAHoldingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAHoldings to aggregate.
     */
    where?: CAHoldingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAHoldings to fetch.
     */
    orderBy?: CAHoldingsOrderByWithRelationInput | CAHoldingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CAHoldingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CAHoldings
    **/
    _count?: true | CAHoldingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CAHoldingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CAHoldingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CAHoldingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CAHoldingsMaxAggregateInputType
  }

  export type GetCAHoldingsAggregateType<T extends CAHoldingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCAHoldings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCAHoldings[P]>
      : GetScalarType<T[P], AggregateCAHoldings[P]>
  }




  export type CAHoldingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CAHoldingsWhereInput
    orderBy?: CAHoldingsOrderByWithAggregationInput | CAHoldingsOrderByWithAggregationInput[]
    by: CAHoldingsScalarFieldEnum[] | CAHoldingsScalarFieldEnum
    having?: CAHoldingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CAHoldingsCountAggregateInputType | true
    _avg?: CAHoldingsAvgAggregateInputType
    _sum?: CAHoldingsSumAggregateInputType
    _min?: CAHoldingsMinAggregateInputType
    _max?: CAHoldingsMaxAggregateInputType
  }

  export type CAHoldingsGroupByOutputType = {
    id: number
    asset: string | null
    quantity: string | null
    value: string | null
    status: string | null
    _count: CAHoldingsCountAggregateOutputType | null
    _avg: CAHoldingsAvgAggregateOutputType | null
    _sum: CAHoldingsSumAggregateOutputType | null
    _min: CAHoldingsMinAggregateOutputType | null
    _max: CAHoldingsMaxAggregateOutputType | null
  }

  type GetCAHoldingsGroupByPayload<T extends CAHoldingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CAHoldingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CAHoldingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CAHoldingsGroupByOutputType[P]>
            : GetScalarType<T[P], CAHoldingsGroupByOutputType[P]>
        }
      >
    >


  export type CAHoldingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    asset?: boolean
    quantity?: boolean
    value?: boolean
    status?: boolean
  }, ExtArgs["result"]["cAHoldings"]>



  export type CAHoldingsSelectScalar = {
    id?: boolean
    asset?: boolean
    quantity?: boolean
    value?: boolean
    status?: boolean
  }

  export type CAHoldingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "asset" | "quantity" | "value" | "status", ExtArgs["result"]["cAHoldings"]>

  export type $CAHoldingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CAHoldings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      asset: string | null
      quantity: string | null
      value: string | null
      status: string | null
    }, ExtArgs["result"]["cAHoldings"]>
    composites: {}
  }

  type CAHoldingsGetPayload<S extends boolean | null | undefined | CAHoldingsDefaultArgs> = $Result.GetResult<Prisma.$CAHoldingsPayload, S>

  type CAHoldingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CAHoldingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CAHoldingsCountAggregateInputType | true
    }

  export interface CAHoldingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CAHoldings'], meta: { name: 'CAHoldings' } }
    /**
     * Find zero or one CAHoldings that matches the filter.
     * @param {CAHoldingsFindUniqueArgs} args - Arguments to find a CAHoldings
     * @example
     * // Get one CAHoldings
     * const cAHoldings = await prisma.cAHoldings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CAHoldingsFindUniqueArgs>(args: SelectSubset<T, CAHoldingsFindUniqueArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CAHoldings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CAHoldingsFindUniqueOrThrowArgs} args - Arguments to find a CAHoldings
     * @example
     * // Get one CAHoldings
     * const cAHoldings = await prisma.cAHoldings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CAHoldingsFindUniqueOrThrowArgs>(args: SelectSubset<T, CAHoldingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsFindFirstArgs} args - Arguments to find a CAHoldings
     * @example
     * // Get one CAHoldings
     * const cAHoldings = await prisma.cAHoldings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CAHoldingsFindFirstArgs>(args?: SelectSubset<T, CAHoldingsFindFirstArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAHoldings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsFindFirstOrThrowArgs} args - Arguments to find a CAHoldings
     * @example
     * // Get one CAHoldings
     * const cAHoldings = await prisma.cAHoldings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CAHoldingsFindFirstOrThrowArgs>(args?: SelectSubset<T, CAHoldingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CAHoldings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CAHoldings
     * const cAHoldings = await prisma.cAHoldings.findMany()
     * 
     * // Get first 10 CAHoldings
     * const cAHoldings = await prisma.cAHoldings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cAHoldingsWithIdOnly = await prisma.cAHoldings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CAHoldingsFindManyArgs>(args?: SelectSubset<T, CAHoldingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CAHoldings.
     * @param {CAHoldingsCreateArgs} args - Arguments to create a CAHoldings.
     * @example
     * // Create one CAHoldings
     * const CAHoldings = await prisma.cAHoldings.create({
     *   data: {
     *     // ... data to create a CAHoldings
     *   }
     * })
     * 
     */
    create<T extends CAHoldingsCreateArgs>(args: SelectSubset<T, CAHoldingsCreateArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CAHoldings.
     * @param {CAHoldingsCreateManyArgs} args - Arguments to create many CAHoldings.
     * @example
     * // Create many CAHoldings
     * const cAHoldings = await prisma.cAHoldings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CAHoldingsCreateManyArgs>(args?: SelectSubset<T, CAHoldingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CAHoldings.
     * @param {CAHoldingsDeleteArgs} args - Arguments to delete one CAHoldings.
     * @example
     * // Delete one CAHoldings
     * const CAHoldings = await prisma.cAHoldings.delete({
     *   where: {
     *     // ... filter to delete one CAHoldings
     *   }
     * })
     * 
     */
    delete<T extends CAHoldingsDeleteArgs>(args: SelectSubset<T, CAHoldingsDeleteArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CAHoldings.
     * @param {CAHoldingsUpdateArgs} args - Arguments to update one CAHoldings.
     * @example
     * // Update one CAHoldings
     * const cAHoldings = await prisma.cAHoldings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CAHoldingsUpdateArgs>(args: SelectSubset<T, CAHoldingsUpdateArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CAHoldings.
     * @param {CAHoldingsDeleteManyArgs} args - Arguments to filter CAHoldings to delete.
     * @example
     * // Delete a few CAHoldings
     * const { count } = await prisma.cAHoldings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CAHoldingsDeleteManyArgs>(args?: SelectSubset<T, CAHoldingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CAHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CAHoldings
     * const cAHoldings = await prisma.cAHoldings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CAHoldingsUpdateManyArgs>(args: SelectSubset<T, CAHoldingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CAHoldings.
     * @param {CAHoldingsUpsertArgs} args - Arguments to update or create a CAHoldings.
     * @example
     * // Update or create a CAHoldings
     * const cAHoldings = await prisma.cAHoldings.upsert({
     *   create: {
     *     // ... data to create a CAHoldings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CAHoldings we want to update
     *   }
     * })
     */
    upsert<T extends CAHoldingsUpsertArgs>(args: SelectSubset<T, CAHoldingsUpsertArgs<ExtArgs>>): Prisma__CAHoldingsClient<$Result.GetResult<Prisma.$CAHoldingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CAHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsCountArgs} args - Arguments to filter CAHoldings to count.
     * @example
     * // Count the number of CAHoldings
     * const count = await prisma.cAHoldings.count({
     *   where: {
     *     // ... the filter for the CAHoldings we want to count
     *   }
     * })
    **/
    count<T extends CAHoldingsCountArgs>(
      args?: Subset<T, CAHoldingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CAHoldingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CAHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CAHoldingsAggregateArgs>(args: Subset<T, CAHoldingsAggregateArgs>): Prisma.PrismaPromise<GetCAHoldingsAggregateType<T>>

    /**
     * Group by CAHoldings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAHoldingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CAHoldingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CAHoldingsGroupByArgs['orderBy'] }
        : { orderBy?: CAHoldingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CAHoldingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCAHoldingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CAHoldings model
   */
  readonly fields: CAHoldingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CAHoldings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CAHoldingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CAHoldings model
   */
  interface CAHoldingsFieldRefs {
    readonly id: FieldRef<"CAHoldings", 'Int'>
    readonly asset: FieldRef<"CAHoldings", 'String'>
    readonly quantity: FieldRef<"CAHoldings", 'String'>
    readonly value: FieldRef<"CAHoldings", 'String'>
    readonly status: FieldRef<"CAHoldings", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CAHoldings findUnique
   */
  export type CAHoldingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * Filter, which CAHoldings to fetch.
     */
    where: CAHoldingsWhereUniqueInput
  }

  /**
   * CAHoldings findUniqueOrThrow
   */
  export type CAHoldingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * Filter, which CAHoldings to fetch.
     */
    where: CAHoldingsWhereUniqueInput
  }

  /**
   * CAHoldings findFirst
   */
  export type CAHoldingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * Filter, which CAHoldings to fetch.
     */
    where?: CAHoldingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAHoldings to fetch.
     */
    orderBy?: CAHoldingsOrderByWithRelationInput | CAHoldingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAHoldings.
     */
    cursor?: CAHoldingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAHoldings.
     */
    distinct?: CAHoldingsScalarFieldEnum | CAHoldingsScalarFieldEnum[]
  }

  /**
   * CAHoldings findFirstOrThrow
   */
  export type CAHoldingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * Filter, which CAHoldings to fetch.
     */
    where?: CAHoldingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAHoldings to fetch.
     */
    orderBy?: CAHoldingsOrderByWithRelationInput | CAHoldingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAHoldings.
     */
    cursor?: CAHoldingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAHoldings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAHoldings.
     */
    distinct?: CAHoldingsScalarFieldEnum | CAHoldingsScalarFieldEnum[]
  }

  /**
   * CAHoldings findMany
   */
  export type CAHoldingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * Filter, which CAHoldings to fetch.
     */
    where?: CAHoldingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAHoldings to fetch.
     */
    orderBy?: CAHoldingsOrderByWithRelationInput | CAHoldingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CAHoldings.
     */
    cursor?: CAHoldingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAHoldings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAHoldings.
     */
    skip?: number
    distinct?: CAHoldingsScalarFieldEnum | CAHoldingsScalarFieldEnum[]
  }

  /**
   * CAHoldings create
   */
  export type CAHoldingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * The data needed to create a CAHoldings.
     */
    data?: XOR<CAHoldingsCreateInput, CAHoldingsUncheckedCreateInput>
  }

  /**
   * CAHoldings createMany
   */
  export type CAHoldingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CAHoldings.
     */
    data: CAHoldingsCreateManyInput | CAHoldingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CAHoldings update
   */
  export type CAHoldingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * The data needed to update a CAHoldings.
     */
    data: XOR<CAHoldingsUpdateInput, CAHoldingsUncheckedUpdateInput>
    /**
     * Choose, which CAHoldings to update.
     */
    where: CAHoldingsWhereUniqueInput
  }

  /**
   * CAHoldings updateMany
   */
  export type CAHoldingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CAHoldings.
     */
    data: XOR<CAHoldingsUpdateManyMutationInput, CAHoldingsUncheckedUpdateManyInput>
    /**
     * Filter which CAHoldings to update
     */
    where?: CAHoldingsWhereInput
    /**
     * Limit how many CAHoldings to update.
     */
    limit?: number
  }

  /**
   * CAHoldings upsert
   */
  export type CAHoldingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * The filter to search for the CAHoldings to update in case it exists.
     */
    where: CAHoldingsWhereUniqueInput
    /**
     * In case the CAHoldings found by the `where` argument doesn't exist, create a new CAHoldings with this data.
     */
    create: XOR<CAHoldingsCreateInput, CAHoldingsUncheckedCreateInput>
    /**
     * In case the CAHoldings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CAHoldingsUpdateInput, CAHoldingsUncheckedUpdateInput>
  }

  /**
   * CAHoldings delete
   */
  export type CAHoldingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
    /**
     * Filter which CAHoldings to delete.
     */
    where: CAHoldingsWhereUniqueInput
  }

  /**
   * CAHoldings deleteMany
   */
  export type CAHoldingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAHoldings to delete
     */
    where?: CAHoldingsWhereInput
    /**
     * Limit how many CAHoldings to delete.
     */
    limit?: number
  }

  /**
   * CAHoldings without action
   */
  export type CAHoldingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAHoldings
     */
    select?: CAHoldingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAHoldings
     */
    omit?: CAHoldingsOmit<ExtArgs> | null
  }


  /**
   * Model CAMarketCards
   */

  export type AggregateCAMarketCards = {
    _count: CAMarketCardsCountAggregateOutputType | null
    _avg: CAMarketCardsAvgAggregateOutputType | null
    _sum: CAMarketCardsSumAggregateOutputType | null
    _min: CAMarketCardsMinAggregateOutputType | null
    _max: CAMarketCardsMaxAggregateOutputType | null
  }

  export type CAMarketCardsAvgAggregateOutputType = {
    id: number | null
  }

  export type CAMarketCardsSumAggregateOutputType = {
    id: number | null
  }

  export type CAMarketCardsMinAggregateOutputType = {
    id: number | null
    price: string | null
    volume: string | null
    change: string | null
    unit: string | null
  }

  export type CAMarketCardsMaxAggregateOutputType = {
    id: number | null
    price: string | null
    volume: string | null
    change: string | null
    unit: string | null
  }

  export type CAMarketCardsCountAggregateOutputType = {
    id: number
    price: number
    volume: number
    change: number
    unit: number
    _all: number
  }


  export type CAMarketCardsAvgAggregateInputType = {
    id?: true
  }

  export type CAMarketCardsSumAggregateInputType = {
    id?: true
  }

  export type CAMarketCardsMinAggregateInputType = {
    id?: true
    price?: true
    volume?: true
    change?: true
    unit?: true
  }

  export type CAMarketCardsMaxAggregateInputType = {
    id?: true
    price?: true
    volume?: true
    change?: true
    unit?: true
  }

  export type CAMarketCardsCountAggregateInputType = {
    id?: true
    price?: true
    volume?: true
    change?: true
    unit?: true
    _all?: true
  }

  export type CAMarketCardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAMarketCards to aggregate.
     */
    where?: CAMarketCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAMarketCards to fetch.
     */
    orderBy?: CAMarketCardsOrderByWithRelationInput | CAMarketCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CAMarketCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAMarketCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAMarketCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CAMarketCards
    **/
    _count?: true | CAMarketCardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CAMarketCardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CAMarketCardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CAMarketCardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CAMarketCardsMaxAggregateInputType
  }

  export type GetCAMarketCardsAggregateType<T extends CAMarketCardsAggregateArgs> = {
        [P in keyof T & keyof AggregateCAMarketCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCAMarketCards[P]>
      : GetScalarType<T[P], AggregateCAMarketCards[P]>
  }




  export type CAMarketCardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CAMarketCardsWhereInput
    orderBy?: CAMarketCardsOrderByWithAggregationInput | CAMarketCardsOrderByWithAggregationInput[]
    by: CAMarketCardsScalarFieldEnum[] | CAMarketCardsScalarFieldEnum
    having?: CAMarketCardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CAMarketCardsCountAggregateInputType | true
    _avg?: CAMarketCardsAvgAggregateInputType
    _sum?: CAMarketCardsSumAggregateInputType
    _min?: CAMarketCardsMinAggregateInputType
    _max?: CAMarketCardsMaxAggregateInputType
  }

  export type CAMarketCardsGroupByOutputType = {
    id: number
    price: string | null
    volume: string | null
    change: string | null
    unit: string | null
    _count: CAMarketCardsCountAggregateOutputType | null
    _avg: CAMarketCardsAvgAggregateOutputType | null
    _sum: CAMarketCardsSumAggregateOutputType | null
    _min: CAMarketCardsMinAggregateOutputType | null
    _max: CAMarketCardsMaxAggregateOutputType | null
  }

  type GetCAMarketCardsGroupByPayload<T extends CAMarketCardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CAMarketCardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CAMarketCardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CAMarketCardsGroupByOutputType[P]>
            : GetScalarType<T[P], CAMarketCardsGroupByOutputType[P]>
        }
      >
    >


  export type CAMarketCardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    price?: boolean
    volume?: boolean
    change?: boolean
    unit?: boolean
  }, ExtArgs["result"]["cAMarketCards"]>



  export type CAMarketCardsSelectScalar = {
    id?: boolean
    price?: boolean
    volume?: boolean
    change?: boolean
    unit?: boolean
  }

  export type CAMarketCardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "price" | "volume" | "change" | "unit", ExtArgs["result"]["cAMarketCards"]>

  export type $CAMarketCardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CAMarketCards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      price: string | null
      volume: string | null
      change: string | null
      unit: string | null
    }, ExtArgs["result"]["cAMarketCards"]>
    composites: {}
  }

  type CAMarketCardsGetPayload<S extends boolean | null | undefined | CAMarketCardsDefaultArgs> = $Result.GetResult<Prisma.$CAMarketCardsPayload, S>

  type CAMarketCardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CAMarketCardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CAMarketCardsCountAggregateInputType | true
    }

  export interface CAMarketCardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CAMarketCards'], meta: { name: 'CAMarketCards' } }
    /**
     * Find zero or one CAMarketCards that matches the filter.
     * @param {CAMarketCardsFindUniqueArgs} args - Arguments to find a CAMarketCards
     * @example
     * // Get one CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CAMarketCardsFindUniqueArgs>(args: SelectSubset<T, CAMarketCardsFindUniqueArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CAMarketCards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CAMarketCardsFindUniqueOrThrowArgs} args - Arguments to find a CAMarketCards
     * @example
     * // Get one CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CAMarketCardsFindUniqueOrThrowArgs>(args: SelectSubset<T, CAMarketCardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAMarketCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsFindFirstArgs} args - Arguments to find a CAMarketCards
     * @example
     * // Get one CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CAMarketCardsFindFirstArgs>(args?: SelectSubset<T, CAMarketCardsFindFirstArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAMarketCards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsFindFirstOrThrowArgs} args - Arguments to find a CAMarketCards
     * @example
     * // Get one CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CAMarketCardsFindFirstOrThrowArgs>(args?: SelectSubset<T, CAMarketCardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CAMarketCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.findMany()
     * 
     * // Get first 10 CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cAMarketCardsWithIdOnly = await prisma.cAMarketCards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CAMarketCardsFindManyArgs>(args?: SelectSubset<T, CAMarketCardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CAMarketCards.
     * @param {CAMarketCardsCreateArgs} args - Arguments to create a CAMarketCards.
     * @example
     * // Create one CAMarketCards
     * const CAMarketCards = await prisma.cAMarketCards.create({
     *   data: {
     *     // ... data to create a CAMarketCards
     *   }
     * })
     * 
     */
    create<T extends CAMarketCardsCreateArgs>(args: SelectSubset<T, CAMarketCardsCreateArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CAMarketCards.
     * @param {CAMarketCardsCreateManyArgs} args - Arguments to create many CAMarketCards.
     * @example
     * // Create many CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CAMarketCardsCreateManyArgs>(args?: SelectSubset<T, CAMarketCardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CAMarketCards.
     * @param {CAMarketCardsDeleteArgs} args - Arguments to delete one CAMarketCards.
     * @example
     * // Delete one CAMarketCards
     * const CAMarketCards = await prisma.cAMarketCards.delete({
     *   where: {
     *     // ... filter to delete one CAMarketCards
     *   }
     * })
     * 
     */
    delete<T extends CAMarketCardsDeleteArgs>(args: SelectSubset<T, CAMarketCardsDeleteArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CAMarketCards.
     * @param {CAMarketCardsUpdateArgs} args - Arguments to update one CAMarketCards.
     * @example
     * // Update one CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CAMarketCardsUpdateArgs>(args: SelectSubset<T, CAMarketCardsUpdateArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CAMarketCards.
     * @param {CAMarketCardsDeleteManyArgs} args - Arguments to filter CAMarketCards to delete.
     * @example
     * // Delete a few CAMarketCards
     * const { count } = await prisma.cAMarketCards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CAMarketCardsDeleteManyArgs>(args?: SelectSubset<T, CAMarketCardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CAMarketCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CAMarketCardsUpdateManyArgs>(args: SelectSubset<T, CAMarketCardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CAMarketCards.
     * @param {CAMarketCardsUpsertArgs} args - Arguments to update or create a CAMarketCards.
     * @example
     * // Update or create a CAMarketCards
     * const cAMarketCards = await prisma.cAMarketCards.upsert({
     *   create: {
     *     // ... data to create a CAMarketCards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CAMarketCards we want to update
     *   }
     * })
     */
    upsert<T extends CAMarketCardsUpsertArgs>(args: SelectSubset<T, CAMarketCardsUpsertArgs<ExtArgs>>): Prisma__CAMarketCardsClient<$Result.GetResult<Prisma.$CAMarketCardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CAMarketCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsCountArgs} args - Arguments to filter CAMarketCards to count.
     * @example
     * // Count the number of CAMarketCards
     * const count = await prisma.cAMarketCards.count({
     *   where: {
     *     // ... the filter for the CAMarketCards we want to count
     *   }
     * })
    **/
    count<T extends CAMarketCardsCountArgs>(
      args?: Subset<T, CAMarketCardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CAMarketCardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CAMarketCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CAMarketCardsAggregateArgs>(args: Subset<T, CAMarketCardsAggregateArgs>): Prisma.PrismaPromise<GetCAMarketCardsAggregateType<T>>

    /**
     * Group by CAMarketCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAMarketCardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CAMarketCardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CAMarketCardsGroupByArgs['orderBy'] }
        : { orderBy?: CAMarketCardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CAMarketCardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCAMarketCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CAMarketCards model
   */
  readonly fields: CAMarketCardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CAMarketCards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CAMarketCardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CAMarketCards model
   */
  interface CAMarketCardsFieldRefs {
    readonly id: FieldRef<"CAMarketCards", 'Int'>
    readonly price: FieldRef<"CAMarketCards", 'String'>
    readonly volume: FieldRef<"CAMarketCards", 'String'>
    readonly change: FieldRef<"CAMarketCards", 'String'>
    readonly unit: FieldRef<"CAMarketCards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CAMarketCards findUnique
   */
  export type CAMarketCardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * Filter, which CAMarketCards to fetch.
     */
    where: CAMarketCardsWhereUniqueInput
  }

  /**
   * CAMarketCards findUniqueOrThrow
   */
  export type CAMarketCardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * Filter, which CAMarketCards to fetch.
     */
    where: CAMarketCardsWhereUniqueInput
  }

  /**
   * CAMarketCards findFirst
   */
  export type CAMarketCardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * Filter, which CAMarketCards to fetch.
     */
    where?: CAMarketCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAMarketCards to fetch.
     */
    orderBy?: CAMarketCardsOrderByWithRelationInput | CAMarketCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAMarketCards.
     */
    cursor?: CAMarketCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAMarketCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAMarketCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAMarketCards.
     */
    distinct?: CAMarketCardsScalarFieldEnum | CAMarketCardsScalarFieldEnum[]
  }

  /**
   * CAMarketCards findFirstOrThrow
   */
  export type CAMarketCardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * Filter, which CAMarketCards to fetch.
     */
    where?: CAMarketCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAMarketCards to fetch.
     */
    orderBy?: CAMarketCardsOrderByWithRelationInput | CAMarketCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAMarketCards.
     */
    cursor?: CAMarketCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAMarketCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAMarketCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAMarketCards.
     */
    distinct?: CAMarketCardsScalarFieldEnum | CAMarketCardsScalarFieldEnum[]
  }

  /**
   * CAMarketCards findMany
   */
  export type CAMarketCardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * Filter, which CAMarketCards to fetch.
     */
    where?: CAMarketCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAMarketCards to fetch.
     */
    orderBy?: CAMarketCardsOrderByWithRelationInput | CAMarketCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CAMarketCards.
     */
    cursor?: CAMarketCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAMarketCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAMarketCards.
     */
    skip?: number
    distinct?: CAMarketCardsScalarFieldEnum | CAMarketCardsScalarFieldEnum[]
  }

  /**
   * CAMarketCards create
   */
  export type CAMarketCardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * The data needed to create a CAMarketCards.
     */
    data?: XOR<CAMarketCardsCreateInput, CAMarketCardsUncheckedCreateInput>
  }

  /**
   * CAMarketCards createMany
   */
  export type CAMarketCardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CAMarketCards.
     */
    data: CAMarketCardsCreateManyInput | CAMarketCardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CAMarketCards update
   */
  export type CAMarketCardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * The data needed to update a CAMarketCards.
     */
    data: XOR<CAMarketCardsUpdateInput, CAMarketCardsUncheckedUpdateInput>
    /**
     * Choose, which CAMarketCards to update.
     */
    where: CAMarketCardsWhereUniqueInput
  }

  /**
   * CAMarketCards updateMany
   */
  export type CAMarketCardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CAMarketCards.
     */
    data: XOR<CAMarketCardsUpdateManyMutationInput, CAMarketCardsUncheckedUpdateManyInput>
    /**
     * Filter which CAMarketCards to update
     */
    where?: CAMarketCardsWhereInput
    /**
     * Limit how many CAMarketCards to update.
     */
    limit?: number
  }

  /**
   * CAMarketCards upsert
   */
  export type CAMarketCardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * The filter to search for the CAMarketCards to update in case it exists.
     */
    where: CAMarketCardsWhereUniqueInput
    /**
     * In case the CAMarketCards found by the `where` argument doesn't exist, create a new CAMarketCards with this data.
     */
    create: XOR<CAMarketCardsCreateInput, CAMarketCardsUncheckedCreateInput>
    /**
     * In case the CAMarketCards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CAMarketCardsUpdateInput, CAMarketCardsUncheckedUpdateInput>
  }

  /**
   * CAMarketCards delete
   */
  export type CAMarketCardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
    /**
     * Filter which CAMarketCards to delete.
     */
    where: CAMarketCardsWhereUniqueInput
  }

  /**
   * CAMarketCards deleteMany
   */
  export type CAMarketCardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAMarketCards to delete
     */
    where?: CAMarketCardsWhereInput
    /**
     * Limit how many CAMarketCards to delete.
     */
    limit?: number
  }

  /**
   * CAMarketCards without action
   */
  export type CAMarketCardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAMarketCards
     */
    select?: CAMarketCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAMarketCards
     */
    omit?: CAMarketCardsOmit<ExtArgs> | null
  }


  /**
   * Model CAPieChart
   */

  export type AggregateCAPieChart = {
    _count: CAPieChartCountAggregateOutputType | null
    _avg: CAPieChartAvgAggregateOutputType | null
    _sum: CAPieChartSumAggregateOutputType | null
    _min: CAPieChartMinAggregateOutputType | null
    _max: CAPieChartMaxAggregateOutputType | null
  }

  export type CAPieChartAvgAggregateOutputType = {
    id: number | null
  }

  export type CAPieChartSumAggregateOutputType = {
    id: number | null
  }

  export type CAPieChartMinAggregateOutputType = {
    id: number | null
    type: string | null
    value: string | null
    percentage: string | null
  }

  export type CAPieChartMaxAggregateOutputType = {
    id: number | null
    type: string | null
    value: string | null
    percentage: string | null
  }

  export type CAPieChartCountAggregateOutputType = {
    id: number
    type: number
    value: number
    percentage: number
    _all: number
  }


  export type CAPieChartAvgAggregateInputType = {
    id?: true
  }

  export type CAPieChartSumAggregateInputType = {
    id?: true
  }

  export type CAPieChartMinAggregateInputType = {
    id?: true
    type?: true
    value?: true
    percentage?: true
  }

  export type CAPieChartMaxAggregateInputType = {
    id?: true
    type?: true
    value?: true
    percentage?: true
  }

  export type CAPieChartCountAggregateInputType = {
    id?: true
    type?: true
    value?: true
    percentage?: true
    _all?: true
  }

  export type CAPieChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAPieChart to aggregate.
     */
    where?: CAPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPieCharts to fetch.
     */
    orderBy?: CAPieChartOrderByWithRelationInput | CAPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CAPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CAPieCharts
    **/
    _count?: true | CAPieChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CAPieChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CAPieChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CAPieChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CAPieChartMaxAggregateInputType
  }

  export type GetCAPieChartAggregateType<T extends CAPieChartAggregateArgs> = {
        [P in keyof T & keyof AggregateCAPieChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCAPieChart[P]>
      : GetScalarType<T[P], AggregateCAPieChart[P]>
  }




  export type CAPieChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CAPieChartWhereInput
    orderBy?: CAPieChartOrderByWithAggregationInput | CAPieChartOrderByWithAggregationInput[]
    by: CAPieChartScalarFieldEnum[] | CAPieChartScalarFieldEnum
    having?: CAPieChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CAPieChartCountAggregateInputType | true
    _avg?: CAPieChartAvgAggregateInputType
    _sum?: CAPieChartSumAggregateInputType
    _min?: CAPieChartMinAggregateInputType
    _max?: CAPieChartMaxAggregateInputType
  }

  export type CAPieChartGroupByOutputType = {
    id: number
    type: string | null
    value: string | null
    percentage: string | null
    _count: CAPieChartCountAggregateOutputType | null
    _avg: CAPieChartAvgAggregateOutputType | null
    _sum: CAPieChartSumAggregateOutputType | null
    _min: CAPieChartMinAggregateOutputType | null
    _max: CAPieChartMaxAggregateOutputType | null
  }

  type GetCAPieChartGroupByPayload<T extends CAPieChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CAPieChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CAPieChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CAPieChartGroupByOutputType[P]>
            : GetScalarType<T[P], CAPieChartGroupByOutputType[P]>
        }
      >
    >


  export type CAPieChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    percentage?: boolean
  }, ExtArgs["result"]["cAPieChart"]>



  export type CAPieChartSelectScalar = {
    id?: boolean
    type?: boolean
    value?: boolean
    percentage?: boolean
  }

  export type CAPieChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "value" | "percentage", ExtArgs["result"]["cAPieChart"]>

  export type $CAPieChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CAPieChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      value: string | null
      percentage: string | null
    }, ExtArgs["result"]["cAPieChart"]>
    composites: {}
  }

  type CAPieChartGetPayload<S extends boolean | null | undefined | CAPieChartDefaultArgs> = $Result.GetResult<Prisma.$CAPieChartPayload, S>

  type CAPieChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CAPieChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CAPieChartCountAggregateInputType | true
    }

  export interface CAPieChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CAPieChart'], meta: { name: 'CAPieChart' } }
    /**
     * Find zero or one CAPieChart that matches the filter.
     * @param {CAPieChartFindUniqueArgs} args - Arguments to find a CAPieChart
     * @example
     * // Get one CAPieChart
     * const cAPieChart = await prisma.cAPieChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CAPieChartFindUniqueArgs>(args: SelectSubset<T, CAPieChartFindUniqueArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CAPieChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CAPieChartFindUniqueOrThrowArgs} args - Arguments to find a CAPieChart
     * @example
     * // Get one CAPieChart
     * const cAPieChart = await prisma.cAPieChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CAPieChartFindUniqueOrThrowArgs>(args: SelectSubset<T, CAPieChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAPieChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartFindFirstArgs} args - Arguments to find a CAPieChart
     * @example
     * // Get one CAPieChart
     * const cAPieChart = await prisma.cAPieChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CAPieChartFindFirstArgs>(args?: SelectSubset<T, CAPieChartFindFirstArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAPieChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartFindFirstOrThrowArgs} args - Arguments to find a CAPieChart
     * @example
     * // Get one CAPieChart
     * const cAPieChart = await prisma.cAPieChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CAPieChartFindFirstOrThrowArgs>(args?: SelectSubset<T, CAPieChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CAPieCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CAPieCharts
     * const cAPieCharts = await prisma.cAPieChart.findMany()
     * 
     * // Get first 10 CAPieCharts
     * const cAPieCharts = await prisma.cAPieChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cAPieChartWithIdOnly = await prisma.cAPieChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CAPieChartFindManyArgs>(args?: SelectSubset<T, CAPieChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CAPieChart.
     * @param {CAPieChartCreateArgs} args - Arguments to create a CAPieChart.
     * @example
     * // Create one CAPieChart
     * const CAPieChart = await prisma.cAPieChart.create({
     *   data: {
     *     // ... data to create a CAPieChart
     *   }
     * })
     * 
     */
    create<T extends CAPieChartCreateArgs>(args: SelectSubset<T, CAPieChartCreateArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CAPieCharts.
     * @param {CAPieChartCreateManyArgs} args - Arguments to create many CAPieCharts.
     * @example
     * // Create many CAPieCharts
     * const cAPieChart = await prisma.cAPieChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CAPieChartCreateManyArgs>(args?: SelectSubset<T, CAPieChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CAPieChart.
     * @param {CAPieChartDeleteArgs} args - Arguments to delete one CAPieChart.
     * @example
     * // Delete one CAPieChart
     * const CAPieChart = await prisma.cAPieChart.delete({
     *   where: {
     *     // ... filter to delete one CAPieChart
     *   }
     * })
     * 
     */
    delete<T extends CAPieChartDeleteArgs>(args: SelectSubset<T, CAPieChartDeleteArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CAPieChart.
     * @param {CAPieChartUpdateArgs} args - Arguments to update one CAPieChart.
     * @example
     * // Update one CAPieChart
     * const cAPieChart = await prisma.cAPieChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CAPieChartUpdateArgs>(args: SelectSubset<T, CAPieChartUpdateArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CAPieCharts.
     * @param {CAPieChartDeleteManyArgs} args - Arguments to filter CAPieCharts to delete.
     * @example
     * // Delete a few CAPieCharts
     * const { count } = await prisma.cAPieChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CAPieChartDeleteManyArgs>(args?: SelectSubset<T, CAPieChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CAPieCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CAPieCharts
     * const cAPieChart = await prisma.cAPieChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CAPieChartUpdateManyArgs>(args: SelectSubset<T, CAPieChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CAPieChart.
     * @param {CAPieChartUpsertArgs} args - Arguments to update or create a CAPieChart.
     * @example
     * // Update or create a CAPieChart
     * const cAPieChart = await prisma.cAPieChart.upsert({
     *   create: {
     *     // ... data to create a CAPieChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CAPieChart we want to update
     *   }
     * })
     */
    upsert<T extends CAPieChartUpsertArgs>(args: SelectSubset<T, CAPieChartUpsertArgs<ExtArgs>>): Prisma__CAPieChartClient<$Result.GetResult<Prisma.$CAPieChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CAPieCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartCountArgs} args - Arguments to filter CAPieCharts to count.
     * @example
     * // Count the number of CAPieCharts
     * const count = await prisma.cAPieChart.count({
     *   where: {
     *     // ... the filter for the CAPieCharts we want to count
     *   }
     * })
    **/
    count<T extends CAPieChartCountArgs>(
      args?: Subset<T, CAPieChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CAPieChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CAPieChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CAPieChartAggregateArgs>(args: Subset<T, CAPieChartAggregateArgs>): Prisma.PrismaPromise<GetCAPieChartAggregateType<T>>

    /**
     * Group by CAPieChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPieChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CAPieChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CAPieChartGroupByArgs['orderBy'] }
        : { orderBy?: CAPieChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CAPieChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCAPieChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CAPieChart model
   */
  readonly fields: CAPieChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CAPieChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CAPieChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CAPieChart model
   */
  interface CAPieChartFieldRefs {
    readonly id: FieldRef<"CAPieChart", 'Int'>
    readonly type: FieldRef<"CAPieChart", 'String'>
    readonly value: FieldRef<"CAPieChart", 'String'>
    readonly percentage: FieldRef<"CAPieChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CAPieChart findUnique
   */
  export type CAPieChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPieChart to fetch.
     */
    where: CAPieChartWhereUniqueInput
  }

  /**
   * CAPieChart findUniqueOrThrow
   */
  export type CAPieChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPieChart to fetch.
     */
    where: CAPieChartWhereUniqueInput
  }

  /**
   * CAPieChart findFirst
   */
  export type CAPieChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPieChart to fetch.
     */
    where?: CAPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPieCharts to fetch.
     */
    orderBy?: CAPieChartOrderByWithRelationInput | CAPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAPieCharts.
     */
    cursor?: CAPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAPieCharts.
     */
    distinct?: CAPieChartScalarFieldEnum | CAPieChartScalarFieldEnum[]
  }

  /**
   * CAPieChart findFirstOrThrow
   */
  export type CAPieChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPieChart to fetch.
     */
    where?: CAPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPieCharts to fetch.
     */
    orderBy?: CAPieChartOrderByWithRelationInput | CAPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAPieCharts.
     */
    cursor?: CAPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAPieCharts.
     */
    distinct?: CAPieChartScalarFieldEnum | CAPieChartScalarFieldEnum[]
  }

  /**
   * CAPieChart findMany
   */
  export type CAPieChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPieCharts to fetch.
     */
    where?: CAPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPieCharts to fetch.
     */
    orderBy?: CAPieChartOrderByWithRelationInput | CAPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CAPieCharts.
     */
    cursor?: CAPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPieCharts.
     */
    skip?: number
    distinct?: CAPieChartScalarFieldEnum | CAPieChartScalarFieldEnum[]
  }

  /**
   * CAPieChart create
   */
  export type CAPieChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * The data needed to create a CAPieChart.
     */
    data?: XOR<CAPieChartCreateInput, CAPieChartUncheckedCreateInput>
  }

  /**
   * CAPieChart createMany
   */
  export type CAPieChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CAPieCharts.
     */
    data: CAPieChartCreateManyInput | CAPieChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CAPieChart update
   */
  export type CAPieChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * The data needed to update a CAPieChart.
     */
    data: XOR<CAPieChartUpdateInput, CAPieChartUncheckedUpdateInput>
    /**
     * Choose, which CAPieChart to update.
     */
    where: CAPieChartWhereUniqueInput
  }

  /**
   * CAPieChart updateMany
   */
  export type CAPieChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CAPieCharts.
     */
    data: XOR<CAPieChartUpdateManyMutationInput, CAPieChartUncheckedUpdateManyInput>
    /**
     * Filter which CAPieCharts to update
     */
    where?: CAPieChartWhereInput
    /**
     * Limit how many CAPieCharts to update.
     */
    limit?: number
  }

  /**
   * CAPieChart upsert
   */
  export type CAPieChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * The filter to search for the CAPieChart to update in case it exists.
     */
    where: CAPieChartWhereUniqueInput
    /**
     * In case the CAPieChart found by the `where` argument doesn't exist, create a new CAPieChart with this data.
     */
    create: XOR<CAPieChartCreateInput, CAPieChartUncheckedCreateInput>
    /**
     * In case the CAPieChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CAPieChartUpdateInput, CAPieChartUncheckedUpdateInput>
  }

  /**
   * CAPieChart delete
   */
  export type CAPieChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
    /**
     * Filter which CAPieChart to delete.
     */
    where: CAPieChartWhereUniqueInput
  }

  /**
   * CAPieChart deleteMany
   */
  export type CAPieChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAPieCharts to delete
     */
    where?: CAPieChartWhereInput
    /**
     * Limit how many CAPieCharts to delete.
     */
    limit?: number
  }

  /**
   * CAPieChart without action
   */
  export type CAPieChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPieChart
     */
    select?: CAPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPieChart
     */
    omit?: CAPieChartOmit<ExtArgs> | null
  }


  /**
   * Model CAPriceChart
   */

  export type AggregateCAPriceChart = {
    _count: CAPriceChartCountAggregateOutputType | null
    _avg: CAPriceChartAvgAggregateOutputType | null
    _sum: CAPriceChartSumAggregateOutputType | null
    _min: CAPriceChartMinAggregateOutputType | null
    _max: CAPriceChartMaxAggregateOutputType | null
  }

  export type CAPriceChartAvgAggregateOutputType = {
    id: number | null
  }

  export type CAPriceChartSumAggregateOutputType = {
    id: number | null
  }

  export type CAPriceChartMinAggregateOutputType = {
    id: number | null
    date: string | null
    price: string | null
    volume: string | null
  }

  export type CAPriceChartMaxAggregateOutputType = {
    id: number | null
    date: string | null
    price: string | null
    volume: string | null
  }

  export type CAPriceChartCountAggregateOutputType = {
    id: number
    date: number
    price: number
    volume: number
    _all: number
  }


  export type CAPriceChartAvgAggregateInputType = {
    id?: true
  }

  export type CAPriceChartSumAggregateInputType = {
    id?: true
  }

  export type CAPriceChartMinAggregateInputType = {
    id?: true
    date?: true
    price?: true
    volume?: true
  }

  export type CAPriceChartMaxAggregateInputType = {
    id?: true
    date?: true
    price?: true
    volume?: true
  }

  export type CAPriceChartCountAggregateInputType = {
    id?: true
    date?: true
    price?: true
    volume?: true
    _all?: true
  }

  export type CAPriceChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAPriceChart to aggregate.
     */
    where?: CAPriceChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPriceCharts to fetch.
     */
    orderBy?: CAPriceChartOrderByWithRelationInput | CAPriceChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CAPriceChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPriceCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPriceCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CAPriceCharts
    **/
    _count?: true | CAPriceChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CAPriceChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CAPriceChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CAPriceChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CAPriceChartMaxAggregateInputType
  }

  export type GetCAPriceChartAggregateType<T extends CAPriceChartAggregateArgs> = {
        [P in keyof T & keyof AggregateCAPriceChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCAPriceChart[P]>
      : GetScalarType<T[P], AggregateCAPriceChart[P]>
  }




  export type CAPriceChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CAPriceChartWhereInput
    orderBy?: CAPriceChartOrderByWithAggregationInput | CAPriceChartOrderByWithAggregationInput[]
    by: CAPriceChartScalarFieldEnum[] | CAPriceChartScalarFieldEnum
    having?: CAPriceChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CAPriceChartCountAggregateInputType | true
    _avg?: CAPriceChartAvgAggregateInputType
    _sum?: CAPriceChartSumAggregateInputType
    _min?: CAPriceChartMinAggregateInputType
    _max?: CAPriceChartMaxAggregateInputType
  }

  export type CAPriceChartGroupByOutputType = {
    id: number
    date: string | null
    price: string | null
    volume: string | null
    _count: CAPriceChartCountAggregateOutputType | null
    _avg: CAPriceChartAvgAggregateOutputType | null
    _sum: CAPriceChartSumAggregateOutputType | null
    _min: CAPriceChartMinAggregateOutputType | null
    _max: CAPriceChartMaxAggregateOutputType | null
  }

  type GetCAPriceChartGroupByPayload<T extends CAPriceChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CAPriceChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CAPriceChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CAPriceChartGroupByOutputType[P]>
            : GetScalarType<T[P], CAPriceChartGroupByOutputType[P]>
        }
      >
    >


  export type CAPriceChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    price?: boolean
    volume?: boolean
  }, ExtArgs["result"]["cAPriceChart"]>



  export type CAPriceChartSelectScalar = {
    id?: boolean
    date?: boolean
    price?: boolean
    volume?: boolean
  }

  export type CAPriceChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "price" | "volume", ExtArgs["result"]["cAPriceChart"]>

  export type $CAPriceChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CAPriceChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: string | null
      price: string | null
      volume: string | null
    }, ExtArgs["result"]["cAPriceChart"]>
    composites: {}
  }

  type CAPriceChartGetPayload<S extends boolean | null | undefined | CAPriceChartDefaultArgs> = $Result.GetResult<Prisma.$CAPriceChartPayload, S>

  type CAPriceChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CAPriceChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CAPriceChartCountAggregateInputType | true
    }

  export interface CAPriceChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CAPriceChart'], meta: { name: 'CAPriceChart' } }
    /**
     * Find zero or one CAPriceChart that matches the filter.
     * @param {CAPriceChartFindUniqueArgs} args - Arguments to find a CAPriceChart
     * @example
     * // Get one CAPriceChart
     * const cAPriceChart = await prisma.cAPriceChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CAPriceChartFindUniqueArgs>(args: SelectSubset<T, CAPriceChartFindUniqueArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CAPriceChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CAPriceChartFindUniqueOrThrowArgs} args - Arguments to find a CAPriceChart
     * @example
     * // Get one CAPriceChart
     * const cAPriceChart = await prisma.cAPriceChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CAPriceChartFindUniqueOrThrowArgs>(args: SelectSubset<T, CAPriceChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAPriceChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartFindFirstArgs} args - Arguments to find a CAPriceChart
     * @example
     * // Get one CAPriceChart
     * const cAPriceChart = await prisma.cAPriceChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CAPriceChartFindFirstArgs>(args?: SelectSubset<T, CAPriceChartFindFirstArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CAPriceChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartFindFirstOrThrowArgs} args - Arguments to find a CAPriceChart
     * @example
     * // Get one CAPriceChart
     * const cAPriceChart = await prisma.cAPriceChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CAPriceChartFindFirstOrThrowArgs>(args?: SelectSubset<T, CAPriceChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CAPriceCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CAPriceCharts
     * const cAPriceCharts = await prisma.cAPriceChart.findMany()
     * 
     * // Get first 10 CAPriceCharts
     * const cAPriceCharts = await prisma.cAPriceChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cAPriceChartWithIdOnly = await prisma.cAPriceChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CAPriceChartFindManyArgs>(args?: SelectSubset<T, CAPriceChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CAPriceChart.
     * @param {CAPriceChartCreateArgs} args - Arguments to create a CAPriceChart.
     * @example
     * // Create one CAPriceChart
     * const CAPriceChart = await prisma.cAPriceChart.create({
     *   data: {
     *     // ... data to create a CAPriceChart
     *   }
     * })
     * 
     */
    create<T extends CAPriceChartCreateArgs>(args: SelectSubset<T, CAPriceChartCreateArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CAPriceCharts.
     * @param {CAPriceChartCreateManyArgs} args - Arguments to create many CAPriceCharts.
     * @example
     * // Create many CAPriceCharts
     * const cAPriceChart = await prisma.cAPriceChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CAPriceChartCreateManyArgs>(args?: SelectSubset<T, CAPriceChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CAPriceChart.
     * @param {CAPriceChartDeleteArgs} args - Arguments to delete one CAPriceChart.
     * @example
     * // Delete one CAPriceChart
     * const CAPriceChart = await prisma.cAPriceChart.delete({
     *   where: {
     *     // ... filter to delete one CAPriceChart
     *   }
     * })
     * 
     */
    delete<T extends CAPriceChartDeleteArgs>(args: SelectSubset<T, CAPriceChartDeleteArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CAPriceChart.
     * @param {CAPriceChartUpdateArgs} args - Arguments to update one CAPriceChart.
     * @example
     * // Update one CAPriceChart
     * const cAPriceChart = await prisma.cAPriceChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CAPriceChartUpdateArgs>(args: SelectSubset<T, CAPriceChartUpdateArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CAPriceCharts.
     * @param {CAPriceChartDeleteManyArgs} args - Arguments to filter CAPriceCharts to delete.
     * @example
     * // Delete a few CAPriceCharts
     * const { count } = await prisma.cAPriceChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CAPriceChartDeleteManyArgs>(args?: SelectSubset<T, CAPriceChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CAPriceCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CAPriceCharts
     * const cAPriceChart = await prisma.cAPriceChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CAPriceChartUpdateManyArgs>(args: SelectSubset<T, CAPriceChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CAPriceChart.
     * @param {CAPriceChartUpsertArgs} args - Arguments to update or create a CAPriceChart.
     * @example
     * // Update or create a CAPriceChart
     * const cAPriceChart = await prisma.cAPriceChart.upsert({
     *   create: {
     *     // ... data to create a CAPriceChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CAPriceChart we want to update
     *   }
     * })
     */
    upsert<T extends CAPriceChartUpsertArgs>(args: SelectSubset<T, CAPriceChartUpsertArgs<ExtArgs>>): Prisma__CAPriceChartClient<$Result.GetResult<Prisma.$CAPriceChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CAPriceCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartCountArgs} args - Arguments to filter CAPriceCharts to count.
     * @example
     * // Count the number of CAPriceCharts
     * const count = await prisma.cAPriceChart.count({
     *   where: {
     *     // ... the filter for the CAPriceCharts we want to count
     *   }
     * })
    **/
    count<T extends CAPriceChartCountArgs>(
      args?: Subset<T, CAPriceChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CAPriceChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CAPriceChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CAPriceChartAggregateArgs>(args: Subset<T, CAPriceChartAggregateArgs>): Prisma.PrismaPromise<GetCAPriceChartAggregateType<T>>

    /**
     * Group by CAPriceChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CAPriceChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CAPriceChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CAPriceChartGroupByArgs['orderBy'] }
        : { orderBy?: CAPriceChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CAPriceChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCAPriceChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CAPriceChart model
   */
  readonly fields: CAPriceChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CAPriceChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CAPriceChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CAPriceChart model
   */
  interface CAPriceChartFieldRefs {
    readonly id: FieldRef<"CAPriceChart", 'Int'>
    readonly date: FieldRef<"CAPriceChart", 'String'>
    readonly price: FieldRef<"CAPriceChart", 'String'>
    readonly volume: FieldRef<"CAPriceChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CAPriceChart findUnique
   */
  export type CAPriceChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPriceChart to fetch.
     */
    where: CAPriceChartWhereUniqueInput
  }

  /**
   * CAPriceChart findUniqueOrThrow
   */
  export type CAPriceChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPriceChart to fetch.
     */
    where: CAPriceChartWhereUniqueInput
  }

  /**
   * CAPriceChart findFirst
   */
  export type CAPriceChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPriceChart to fetch.
     */
    where?: CAPriceChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPriceCharts to fetch.
     */
    orderBy?: CAPriceChartOrderByWithRelationInput | CAPriceChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAPriceCharts.
     */
    cursor?: CAPriceChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPriceCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPriceCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAPriceCharts.
     */
    distinct?: CAPriceChartScalarFieldEnum | CAPriceChartScalarFieldEnum[]
  }

  /**
   * CAPriceChart findFirstOrThrow
   */
  export type CAPriceChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPriceChart to fetch.
     */
    where?: CAPriceChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPriceCharts to fetch.
     */
    orderBy?: CAPriceChartOrderByWithRelationInput | CAPriceChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CAPriceCharts.
     */
    cursor?: CAPriceChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPriceCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPriceCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CAPriceCharts.
     */
    distinct?: CAPriceChartScalarFieldEnum | CAPriceChartScalarFieldEnum[]
  }

  /**
   * CAPriceChart findMany
   */
  export type CAPriceChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * Filter, which CAPriceCharts to fetch.
     */
    where?: CAPriceChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CAPriceCharts to fetch.
     */
    orderBy?: CAPriceChartOrderByWithRelationInput | CAPriceChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CAPriceCharts.
     */
    cursor?: CAPriceChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CAPriceCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CAPriceCharts.
     */
    skip?: number
    distinct?: CAPriceChartScalarFieldEnum | CAPriceChartScalarFieldEnum[]
  }

  /**
   * CAPriceChart create
   */
  export type CAPriceChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * The data needed to create a CAPriceChart.
     */
    data?: XOR<CAPriceChartCreateInput, CAPriceChartUncheckedCreateInput>
  }

  /**
   * CAPriceChart createMany
   */
  export type CAPriceChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CAPriceCharts.
     */
    data: CAPriceChartCreateManyInput | CAPriceChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CAPriceChart update
   */
  export type CAPriceChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * The data needed to update a CAPriceChart.
     */
    data: XOR<CAPriceChartUpdateInput, CAPriceChartUncheckedUpdateInput>
    /**
     * Choose, which CAPriceChart to update.
     */
    where: CAPriceChartWhereUniqueInput
  }

  /**
   * CAPriceChart updateMany
   */
  export type CAPriceChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CAPriceCharts.
     */
    data: XOR<CAPriceChartUpdateManyMutationInput, CAPriceChartUncheckedUpdateManyInput>
    /**
     * Filter which CAPriceCharts to update
     */
    where?: CAPriceChartWhereInput
    /**
     * Limit how many CAPriceCharts to update.
     */
    limit?: number
  }

  /**
   * CAPriceChart upsert
   */
  export type CAPriceChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * The filter to search for the CAPriceChart to update in case it exists.
     */
    where: CAPriceChartWhereUniqueInput
    /**
     * In case the CAPriceChart found by the `where` argument doesn't exist, create a new CAPriceChart with this data.
     */
    create: XOR<CAPriceChartCreateInput, CAPriceChartUncheckedCreateInput>
    /**
     * In case the CAPriceChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CAPriceChartUpdateInput, CAPriceChartUncheckedUpdateInput>
  }

  /**
   * CAPriceChart delete
   */
  export type CAPriceChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
    /**
     * Filter which CAPriceChart to delete.
     */
    where: CAPriceChartWhereUniqueInput
  }

  /**
   * CAPriceChart deleteMany
   */
  export type CAPriceChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CAPriceCharts to delete
     */
    where?: CAPriceChartWhereInput
    /**
     * Limit how many CAPriceCharts to delete.
     */
    limit?: number
  }

  /**
   * CAPriceChart without action
   */
  export type CAPriceChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CAPriceChart
     */
    select?: CAPriceChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CAPriceChart
     */
    omit?: CAPriceChartOmit<ExtArgs> | null
  }


  /**
   * Model CBComparisonChart
   */

  export type AggregateCBComparisonChart = {
    _count: CBComparisonChartCountAggregateOutputType | null
    _avg: CBComparisonChartAvgAggregateOutputType | null
    _sum: CBComparisonChartSumAggregateOutputType | null
    _min: CBComparisonChartMinAggregateOutputType | null
    _max: CBComparisonChartMaxAggregateOutputType | null
  }

  export type CBComparisonChartAvgAggregateOutputType = {
    id: number | null
  }

  export type CBComparisonChartSumAggregateOutputType = {
    id: number | null
  }

  export type CBComparisonChartMinAggregateOutputType = {
    id: number | null
    month: string | null
    actual: string | null
    budget: string | null
  }

  export type CBComparisonChartMaxAggregateOutputType = {
    id: number | null
    month: string | null
    actual: string | null
    budget: string | null
  }

  export type CBComparisonChartCountAggregateOutputType = {
    id: number
    month: number
    actual: number
    budget: number
    _all: number
  }


  export type CBComparisonChartAvgAggregateInputType = {
    id?: true
  }

  export type CBComparisonChartSumAggregateInputType = {
    id?: true
  }

  export type CBComparisonChartMinAggregateInputType = {
    id?: true
    month?: true
    actual?: true
    budget?: true
  }

  export type CBComparisonChartMaxAggregateInputType = {
    id?: true
    month?: true
    actual?: true
    budget?: true
  }

  export type CBComparisonChartCountAggregateInputType = {
    id?: true
    month?: true
    actual?: true
    budget?: true
    _all?: true
  }

  export type CBComparisonChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CBComparisonChart to aggregate.
     */
    where?: CBComparisonChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBComparisonCharts to fetch.
     */
    orderBy?: CBComparisonChartOrderByWithRelationInput | CBComparisonChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CBComparisonChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBComparisonCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBComparisonCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CBComparisonCharts
    **/
    _count?: true | CBComparisonChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CBComparisonChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CBComparisonChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CBComparisonChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CBComparisonChartMaxAggregateInputType
  }

  export type GetCBComparisonChartAggregateType<T extends CBComparisonChartAggregateArgs> = {
        [P in keyof T & keyof AggregateCBComparisonChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCBComparisonChart[P]>
      : GetScalarType<T[P], AggregateCBComparisonChart[P]>
  }




  export type CBComparisonChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CBComparisonChartWhereInput
    orderBy?: CBComparisonChartOrderByWithAggregationInput | CBComparisonChartOrderByWithAggregationInput[]
    by: CBComparisonChartScalarFieldEnum[] | CBComparisonChartScalarFieldEnum
    having?: CBComparisonChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CBComparisonChartCountAggregateInputType | true
    _avg?: CBComparisonChartAvgAggregateInputType
    _sum?: CBComparisonChartSumAggregateInputType
    _min?: CBComparisonChartMinAggregateInputType
    _max?: CBComparisonChartMaxAggregateInputType
  }

  export type CBComparisonChartGroupByOutputType = {
    id: number
    month: string | null
    actual: string | null
    budget: string | null
    _count: CBComparisonChartCountAggregateOutputType | null
    _avg: CBComparisonChartAvgAggregateOutputType | null
    _sum: CBComparisonChartSumAggregateOutputType | null
    _min: CBComparisonChartMinAggregateOutputType | null
    _max: CBComparisonChartMaxAggregateOutputType | null
  }

  type GetCBComparisonChartGroupByPayload<T extends CBComparisonChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CBComparisonChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CBComparisonChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CBComparisonChartGroupByOutputType[P]>
            : GetScalarType<T[P], CBComparisonChartGroupByOutputType[P]>
        }
      >
    >


  export type CBComparisonChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    actual?: boolean
    budget?: boolean
  }, ExtArgs["result"]["cBComparisonChart"]>



  export type CBComparisonChartSelectScalar = {
    id?: boolean
    month?: boolean
    actual?: boolean
    budget?: boolean
  }

  export type CBComparisonChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "actual" | "budget", ExtArgs["result"]["cBComparisonChart"]>

  export type $CBComparisonChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CBComparisonChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string | null
      actual: string | null
      budget: string | null
    }, ExtArgs["result"]["cBComparisonChart"]>
    composites: {}
  }

  type CBComparisonChartGetPayload<S extends boolean | null | undefined | CBComparisonChartDefaultArgs> = $Result.GetResult<Prisma.$CBComparisonChartPayload, S>

  type CBComparisonChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CBComparisonChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CBComparisonChartCountAggregateInputType | true
    }

  export interface CBComparisonChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CBComparisonChart'], meta: { name: 'CBComparisonChart' } }
    /**
     * Find zero or one CBComparisonChart that matches the filter.
     * @param {CBComparisonChartFindUniqueArgs} args - Arguments to find a CBComparisonChart
     * @example
     * // Get one CBComparisonChart
     * const cBComparisonChart = await prisma.cBComparisonChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CBComparisonChartFindUniqueArgs>(args: SelectSubset<T, CBComparisonChartFindUniqueArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CBComparisonChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CBComparisonChartFindUniqueOrThrowArgs} args - Arguments to find a CBComparisonChart
     * @example
     * // Get one CBComparisonChart
     * const cBComparisonChart = await prisma.cBComparisonChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CBComparisonChartFindUniqueOrThrowArgs>(args: SelectSubset<T, CBComparisonChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CBComparisonChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartFindFirstArgs} args - Arguments to find a CBComparisonChart
     * @example
     * // Get one CBComparisonChart
     * const cBComparisonChart = await prisma.cBComparisonChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CBComparisonChartFindFirstArgs>(args?: SelectSubset<T, CBComparisonChartFindFirstArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CBComparisonChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartFindFirstOrThrowArgs} args - Arguments to find a CBComparisonChart
     * @example
     * // Get one CBComparisonChart
     * const cBComparisonChart = await prisma.cBComparisonChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CBComparisonChartFindFirstOrThrowArgs>(args?: SelectSubset<T, CBComparisonChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CBComparisonCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CBComparisonCharts
     * const cBComparisonCharts = await prisma.cBComparisonChart.findMany()
     * 
     * // Get first 10 CBComparisonCharts
     * const cBComparisonCharts = await prisma.cBComparisonChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cBComparisonChartWithIdOnly = await prisma.cBComparisonChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CBComparisonChartFindManyArgs>(args?: SelectSubset<T, CBComparisonChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CBComparisonChart.
     * @param {CBComparisonChartCreateArgs} args - Arguments to create a CBComparisonChart.
     * @example
     * // Create one CBComparisonChart
     * const CBComparisonChart = await prisma.cBComparisonChart.create({
     *   data: {
     *     // ... data to create a CBComparisonChart
     *   }
     * })
     * 
     */
    create<T extends CBComparisonChartCreateArgs>(args: SelectSubset<T, CBComparisonChartCreateArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CBComparisonCharts.
     * @param {CBComparisonChartCreateManyArgs} args - Arguments to create many CBComparisonCharts.
     * @example
     * // Create many CBComparisonCharts
     * const cBComparisonChart = await prisma.cBComparisonChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CBComparisonChartCreateManyArgs>(args?: SelectSubset<T, CBComparisonChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CBComparisonChart.
     * @param {CBComparisonChartDeleteArgs} args - Arguments to delete one CBComparisonChart.
     * @example
     * // Delete one CBComparisonChart
     * const CBComparisonChart = await prisma.cBComparisonChart.delete({
     *   where: {
     *     // ... filter to delete one CBComparisonChart
     *   }
     * })
     * 
     */
    delete<T extends CBComparisonChartDeleteArgs>(args: SelectSubset<T, CBComparisonChartDeleteArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CBComparisonChart.
     * @param {CBComparisonChartUpdateArgs} args - Arguments to update one CBComparisonChart.
     * @example
     * // Update one CBComparisonChart
     * const cBComparisonChart = await prisma.cBComparisonChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CBComparisonChartUpdateArgs>(args: SelectSubset<T, CBComparisonChartUpdateArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CBComparisonCharts.
     * @param {CBComparisonChartDeleteManyArgs} args - Arguments to filter CBComparisonCharts to delete.
     * @example
     * // Delete a few CBComparisonCharts
     * const { count } = await prisma.cBComparisonChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CBComparisonChartDeleteManyArgs>(args?: SelectSubset<T, CBComparisonChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CBComparisonCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CBComparisonCharts
     * const cBComparisonChart = await prisma.cBComparisonChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CBComparisonChartUpdateManyArgs>(args: SelectSubset<T, CBComparisonChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CBComparisonChart.
     * @param {CBComparisonChartUpsertArgs} args - Arguments to update or create a CBComparisonChart.
     * @example
     * // Update or create a CBComparisonChart
     * const cBComparisonChart = await prisma.cBComparisonChart.upsert({
     *   create: {
     *     // ... data to create a CBComparisonChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CBComparisonChart we want to update
     *   }
     * })
     */
    upsert<T extends CBComparisonChartUpsertArgs>(args: SelectSubset<T, CBComparisonChartUpsertArgs<ExtArgs>>): Prisma__CBComparisonChartClient<$Result.GetResult<Prisma.$CBComparisonChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CBComparisonCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartCountArgs} args - Arguments to filter CBComparisonCharts to count.
     * @example
     * // Count the number of CBComparisonCharts
     * const count = await prisma.cBComparisonChart.count({
     *   where: {
     *     // ... the filter for the CBComparisonCharts we want to count
     *   }
     * })
    **/
    count<T extends CBComparisonChartCountArgs>(
      args?: Subset<T, CBComparisonChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CBComparisonChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CBComparisonChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CBComparisonChartAggregateArgs>(args: Subset<T, CBComparisonChartAggregateArgs>): Prisma.PrismaPromise<GetCBComparisonChartAggregateType<T>>

    /**
     * Group by CBComparisonChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBComparisonChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CBComparisonChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CBComparisonChartGroupByArgs['orderBy'] }
        : { orderBy?: CBComparisonChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CBComparisonChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCBComparisonChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CBComparisonChart model
   */
  readonly fields: CBComparisonChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CBComparisonChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CBComparisonChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CBComparisonChart model
   */
  interface CBComparisonChartFieldRefs {
    readonly id: FieldRef<"CBComparisonChart", 'Int'>
    readonly month: FieldRef<"CBComparisonChart", 'String'>
    readonly actual: FieldRef<"CBComparisonChart", 'String'>
    readonly budget: FieldRef<"CBComparisonChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CBComparisonChart findUnique
   */
  export type CBComparisonChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * Filter, which CBComparisonChart to fetch.
     */
    where: CBComparisonChartWhereUniqueInput
  }

  /**
   * CBComparisonChart findUniqueOrThrow
   */
  export type CBComparisonChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * Filter, which CBComparisonChart to fetch.
     */
    where: CBComparisonChartWhereUniqueInput
  }

  /**
   * CBComparisonChart findFirst
   */
  export type CBComparisonChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * Filter, which CBComparisonChart to fetch.
     */
    where?: CBComparisonChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBComparisonCharts to fetch.
     */
    orderBy?: CBComparisonChartOrderByWithRelationInput | CBComparisonChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CBComparisonCharts.
     */
    cursor?: CBComparisonChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBComparisonCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBComparisonCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CBComparisonCharts.
     */
    distinct?: CBComparisonChartScalarFieldEnum | CBComparisonChartScalarFieldEnum[]
  }

  /**
   * CBComparisonChart findFirstOrThrow
   */
  export type CBComparisonChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * Filter, which CBComparisonChart to fetch.
     */
    where?: CBComparisonChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBComparisonCharts to fetch.
     */
    orderBy?: CBComparisonChartOrderByWithRelationInput | CBComparisonChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CBComparisonCharts.
     */
    cursor?: CBComparisonChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBComparisonCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBComparisonCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CBComparisonCharts.
     */
    distinct?: CBComparisonChartScalarFieldEnum | CBComparisonChartScalarFieldEnum[]
  }

  /**
   * CBComparisonChart findMany
   */
  export type CBComparisonChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * Filter, which CBComparisonCharts to fetch.
     */
    where?: CBComparisonChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBComparisonCharts to fetch.
     */
    orderBy?: CBComparisonChartOrderByWithRelationInput | CBComparisonChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CBComparisonCharts.
     */
    cursor?: CBComparisonChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBComparisonCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBComparisonCharts.
     */
    skip?: number
    distinct?: CBComparisonChartScalarFieldEnum | CBComparisonChartScalarFieldEnum[]
  }

  /**
   * CBComparisonChart create
   */
  export type CBComparisonChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * The data needed to create a CBComparisonChart.
     */
    data?: XOR<CBComparisonChartCreateInput, CBComparisonChartUncheckedCreateInput>
  }

  /**
   * CBComparisonChart createMany
   */
  export type CBComparisonChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CBComparisonCharts.
     */
    data: CBComparisonChartCreateManyInput | CBComparisonChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CBComparisonChart update
   */
  export type CBComparisonChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * The data needed to update a CBComparisonChart.
     */
    data: XOR<CBComparisonChartUpdateInput, CBComparisonChartUncheckedUpdateInput>
    /**
     * Choose, which CBComparisonChart to update.
     */
    where: CBComparisonChartWhereUniqueInput
  }

  /**
   * CBComparisonChart updateMany
   */
  export type CBComparisonChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CBComparisonCharts.
     */
    data: XOR<CBComparisonChartUpdateManyMutationInput, CBComparisonChartUncheckedUpdateManyInput>
    /**
     * Filter which CBComparisonCharts to update
     */
    where?: CBComparisonChartWhereInput
    /**
     * Limit how many CBComparisonCharts to update.
     */
    limit?: number
  }

  /**
   * CBComparisonChart upsert
   */
  export type CBComparisonChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * The filter to search for the CBComparisonChart to update in case it exists.
     */
    where: CBComparisonChartWhereUniqueInput
    /**
     * In case the CBComparisonChart found by the `where` argument doesn't exist, create a new CBComparisonChart with this data.
     */
    create: XOR<CBComparisonChartCreateInput, CBComparisonChartUncheckedCreateInput>
    /**
     * In case the CBComparisonChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CBComparisonChartUpdateInput, CBComparisonChartUncheckedUpdateInput>
  }

  /**
   * CBComparisonChart delete
   */
  export type CBComparisonChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
    /**
     * Filter which CBComparisonChart to delete.
     */
    where: CBComparisonChartWhereUniqueInput
  }

  /**
   * CBComparisonChart deleteMany
   */
  export type CBComparisonChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CBComparisonCharts to delete
     */
    where?: CBComparisonChartWhereInput
    /**
     * Limit how many CBComparisonCharts to delete.
     */
    limit?: number
  }

  /**
   * CBComparisonChart without action
   */
  export type CBComparisonChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBComparisonChart
     */
    select?: CBComparisonChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBComparisonChart
     */
    omit?: CBComparisonChartOmit<ExtArgs> | null
  }


  /**
   * Model CBMonthlyDetails
   */

  export type AggregateCBMonthlyDetails = {
    _count: CBMonthlyDetailsCountAggregateOutputType | null
    _avg: CBMonthlyDetailsAvgAggregateOutputType | null
    _sum: CBMonthlyDetailsSumAggregateOutputType | null
    _min: CBMonthlyDetailsMinAggregateOutputType | null
    _max: CBMonthlyDetailsMaxAggregateOutputType | null
  }

  export type CBMonthlyDetailsAvgAggregateOutputType = {
    id: number | null
  }

  export type CBMonthlyDetailsSumAggregateOutputType = {
    id: number | null
  }

  export type CBMonthlyDetailsMinAggregateOutputType = {
    id: number | null
    month: string | null
    energy_budget: string | null
    actual: string | null
    variance: string | null
    status: string | null
  }

  export type CBMonthlyDetailsMaxAggregateOutputType = {
    id: number | null
    month: string | null
    energy_budget: string | null
    actual: string | null
    variance: string | null
    status: string | null
  }

  export type CBMonthlyDetailsCountAggregateOutputType = {
    id: number
    month: number
    energy_budget: number
    actual: number
    variance: number
    status: number
    _all: number
  }


  export type CBMonthlyDetailsAvgAggregateInputType = {
    id?: true
  }

  export type CBMonthlyDetailsSumAggregateInputType = {
    id?: true
  }

  export type CBMonthlyDetailsMinAggregateInputType = {
    id?: true
    month?: true
    energy_budget?: true
    actual?: true
    variance?: true
    status?: true
  }

  export type CBMonthlyDetailsMaxAggregateInputType = {
    id?: true
    month?: true
    energy_budget?: true
    actual?: true
    variance?: true
    status?: true
  }

  export type CBMonthlyDetailsCountAggregateInputType = {
    id?: true
    month?: true
    energy_budget?: true
    actual?: true
    variance?: true
    status?: true
    _all?: true
  }

  export type CBMonthlyDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CBMonthlyDetails to aggregate.
     */
    where?: CBMonthlyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBMonthlyDetails to fetch.
     */
    orderBy?: CBMonthlyDetailsOrderByWithRelationInput | CBMonthlyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CBMonthlyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBMonthlyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBMonthlyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CBMonthlyDetails
    **/
    _count?: true | CBMonthlyDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CBMonthlyDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CBMonthlyDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CBMonthlyDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CBMonthlyDetailsMaxAggregateInputType
  }

  export type GetCBMonthlyDetailsAggregateType<T extends CBMonthlyDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateCBMonthlyDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCBMonthlyDetails[P]>
      : GetScalarType<T[P], AggregateCBMonthlyDetails[P]>
  }




  export type CBMonthlyDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CBMonthlyDetailsWhereInput
    orderBy?: CBMonthlyDetailsOrderByWithAggregationInput | CBMonthlyDetailsOrderByWithAggregationInput[]
    by: CBMonthlyDetailsScalarFieldEnum[] | CBMonthlyDetailsScalarFieldEnum
    having?: CBMonthlyDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CBMonthlyDetailsCountAggregateInputType | true
    _avg?: CBMonthlyDetailsAvgAggregateInputType
    _sum?: CBMonthlyDetailsSumAggregateInputType
    _min?: CBMonthlyDetailsMinAggregateInputType
    _max?: CBMonthlyDetailsMaxAggregateInputType
  }

  export type CBMonthlyDetailsGroupByOutputType = {
    id: number
    month: string | null
    energy_budget: string | null
    actual: string | null
    variance: string | null
    status: string | null
    _count: CBMonthlyDetailsCountAggregateOutputType | null
    _avg: CBMonthlyDetailsAvgAggregateOutputType | null
    _sum: CBMonthlyDetailsSumAggregateOutputType | null
    _min: CBMonthlyDetailsMinAggregateOutputType | null
    _max: CBMonthlyDetailsMaxAggregateOutputType | null
  }

  type GetCBMonthlyDetailsGroupByPayload<T extends CBMonthlyDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CBMonthlyDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CBMonthlyDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CBMonthlyDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], CBMonthlyDetailsGroupByOutputType[P]>
        }
      >
    >


  export type CBMonthlyDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    energy_budget?: boolean
    actual?: boolean
    variance?: boolean
    status?: boolean
  }, ExtArgs["result"]["cBMonthlyDetails"]>



  export type CBMonthlyDetailsSelectScalar = {
    id?: boolean
    month?: boolean
    energy_budget?: boolean
    actual?: boolean
    variance?: boolean
    status?: boolean
  }

  export type CBMonthlyDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "energy_budget" | "actual" | "variance" | "status", ExtArgs["result"]["cBMonthlyDetails"]>

  export type $CBMonthlyDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CBMonthlyDetails"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string | null
      energy_budget: string | null
      actual: string | null
      variance: string | null
      status: string | null
    }, ExtArgs["result"]["cBMonthlyDetails"]>
    composites: {}
  }

  type CBMonthlyDetailsGetPayload<S extends boolean | null | undefined | CBMonthlyDetailsDefaultArgs> = $Result.GetResult<Prisma.$CBMonthlyDetailsPayload, S>

  type CBMonthlyDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CBMonthlyDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CBMonthlyDetailsCountAggregateInputType | true
    }

  export interface CBMonthlyDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CBMonthlyDetails'], meta: { name: 'CBMonthlyDetails' } }
    /**
     * Find zero or one CBMonthlyDetails that matches the filter.
     * @param {CBMonthlyDetailsFindUniqueArgs} args - Arguments to find a CBMonthlyDetails
     * @example
     * // Get one CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CBMonthlyDetailsFindUniqueArgs>(args: SelectSubset<T, CBMonthlyDetailsFindUniqueArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CBMonthlyDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CBMonthlyDetailsFindUniqueOrThrowArgs} args - Arguments to find a CBMonthlyDetails
     * @example
     * // Get one CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CBMonthlyDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, CBMonthlyDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CBMonthlyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsFindFirstArgs} args - Arguments to find a CBMonthlyDetails
     * @example
     * // Get one CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CBMonthlyDetailsFindFirstArgs>(args?: SelectSubset<T, CBMonthlyDetailsFindFirstArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CBMonthlyDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsFindFirstOrThrowArgs} args - Arguments to find a CBMonthlyDetails
     * @example
     * // Get one CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CBMonthlyDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, CBMonthlyDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CBMonthlyDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findMany()
     * 
     * // Get first 10 CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cBMonthlyDetailsWithIdOnly = await prisma.cBMonthlyDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CBMonthlyDetailsFindManyArgs>(args?: SelectSubset<T, CBMonthlyDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CBMonthlyDetails.
     * @param {CBMonthlyDetailsCreateArgs} args - Arguments to create a CBMonthlyDetails.
     * @example
     * // Create one CBMonthlyDetails
     * const CBMonthlyDetails = await prisma.cBMonthlyDetails.create({
     *   data: {
     *     // ... data to create a CBMonthlyDetails
     *   }
     * })
     * 
     */
    create<T extends CBMonthlyDetailsCreateArgs>(args: SelectSubset<T, CBMonthlyDetailsCreateArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CBMonthlyDetails.
     * @param {CBMonthlyDetailsCreateManyArgs} args - Arguments to create many CBMonthlyDetails.
     * @example
     * // Create many CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CBMonthlyDetailsCreateManyArgs>(args?: SelectSubset<T, CBMonthlyDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CBMonthlyDetails.
     * @param {CBMonthlyDetailsDeleteArgs} args - Arguments to delete one CBMonthlyDetails.
     * @example
     * // Delete one CBMonthlyDetails
     * const CBMonthlyDetails = await prisma.cBMonthlyDetails.delete({
     *   where: {
     *     // ... filter to delete one CBMonthlyDetails
     *   }
     * })
     * 
     */
    delete<T extends CBMonthlyDetailsDeleteArgs>(args: SelectSubset<T, CBMonthlyDetailsDeleteArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CBMonthlyDetails.
     * @param {CBMonthlyDetailsUpdateArgs} args - Arguments to update one CBMonthlyDetails.
     * @example
     * // Update one CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CBMonthlyDetailsUpdateArgs>(args: SelectSubset<T, CBMonthlyDetailsUpdateArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CBMonthlyDetails.
     * @param {CBMonthlyDetailsDeleteManyArgs} args - Arguments to filter CBMonthlyDetails to delete.
     * @example
     * // Delete a few CBMonthlyDetails
     * const { count } = await prisma.cBMonthlyDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CBMonthlyDetailsDeleteManyArgs>(args?: SelectSubset<T, CBMonthlyDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CBMonthlyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CBMonthlyDetailsUpdateManyArgs>(args: SelectSubset<T, CBMonthlyDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CBMonthlyDetails.
     * @param {CBMonthlyDetailsUpsertArgs} args - Arguments to update or create a CBMonthlyDetails.
     * @example
     * // Update or create a CBMonthlyDetails
     * const cBMonthlyDetails = await prisma.cBMonthlyDetails.upsert({
     *   create: {
     *     // ... data to create a CBMonthlyDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CBMonthlyDetails we want to update
     *   }
     * })
     */
    upsert<T extends CBMonthlyDetailsUpsertArgs>(args: SelectSubset<T, CBMonthlyDetailsUpsertArgs<ExtArgs>>): Prisma__CBMonthlyDetailsClient<$Result.GetResult<Prisma.$CBMonthlyDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CBMonthlyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsCountArgs} args - Arguments to filter CBMonthlyDetails to count.
     * @example
     * // Count the number of CBMonthlyDetails
     * const count = await prisma.cBMonthlyDetails.count({
     *   where: {
     *     // ... the filter for the CBMonthlyDetails we want to count
     *   }
     * })
    **/
    count<T extends CBMonthlyDetailsCountArgs>(
      args?: Subset<T, CBMonthlyDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CBMonthlyDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CBMonthlyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CBMonthlyDetailsAggregateArgs>(args: Subset<T, CBMonthlyDetailsAggregateArgs>): Prisma.PrismaPromise<GetCBMonthlyDetailsAggregateType<T>>

    /**
     * Group by CBMonthlyDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBMonthlyDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CBMonthlyDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CBMonthlyDetailsGroupByArgs['orderBy'] }
        : { orderBy?: CBMonthlyDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CBMonthlyDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCBMonthlyDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CBMonthlyDetails model
   */
  readonly fields: CBMonthlyDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CBMonthlyDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CBMonthlyDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CBMonthlyDetails model
   */
  interface CBMonthlyDetailsFieldRefs {
    readonly id: FieldRef<"CBMonthlyDetails", 'Int'>
    readonly month: FieldRef<"CBMonthlyDetails", 'String'>
    readonly energy_budget: FieldRef<"CBMonthlyDetails", 'String'>
    readonly actual: FieldRef<"CBMonthlyDetails", 'String'>
    readonly variance: FieldRef<"CBMonthlyDetails", 'String'>
    readonly status: FieldRef<"CBMonthlyDetails", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CBMonthlyDetails findUnique
   */
  export type CBMonthlyDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CBMonthlyDetails to fetch.
     */
    where: CBMonthlyDetailsWhereUniqueInput
  }

  /**
   * CBMonthlyDetails findUniqueOrThrow
   */
  export type CBMonthlyDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CBMonthlyDetails to fetch.
     */
    where: CBMonthlyDetailsWhereUniqueInput
  }

  /**
   * CBMonthlyDetails findFirst
   */
  export type CBMonthlyDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CBMonthlyDetails to fetch.
     */
    where?: CBMonthlyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBMonthlyDetails to fetch.
     */
    orderBy?: CBMonthlyDetailsOrderByWithRelationInput | CBMonthlyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CBMonthlyDetails.
     */
    cursor?: CBMonthlyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBMonthlyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBMonthlyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CBMonthlyDetails.
     */
    distinct?: CBMonthlyDetailsScalarFieldEnum | CBMonthlyDetailsScalarFieldEnum[]
  }

  /**
   * CBMonthlyDetails findFirstOrThrow
   */
  export type CBMonthlyDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CBMonthlyDetails to fetch.
     */
    where?: CBMonthlyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBMonthlyDetails to fetch.
     */
    orderBy?: CBMonthlyDetailsOrderByWithRelationInput | CBMonthlyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CBMonthlyDetails.
     */
    cursor?: CBMonthlyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBMonthlyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBMonthlyDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CBMonthlyDetails.
     */
    distinct?: CBMonthlyDetailsScalarFieldEnum | CBMonthlyDetailsScalarFieldEnum[]
  }

  /**
   * CBMonthlyDetails findMany
   */
  export type CBMonthlyDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CBMonthlyDetails to fetch.
     */
    where?: CBMonthlyDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBMonthlyDetails to fetch.
     */
    orderBy?: CBMonthlyDetailsOrderByWithRelationInput | CBMonthlyDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CBMonthlyDetails.
     */
    cursor?: CBMonthlyDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBMonthlyDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBMonthlyDetails.
     */
    skip?: number
    distinct?: CBMonthlyDetailsScalarFieldEnum | CBMonthlyDetailsScalarFieldEnum[]
  }

  /**
   * CBMonthlyDetails create
   */
  export type CBMonthlyDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * The data needed to create a CBMonthlyDetails.
     */
    data?: XOR<CBMonthlyDetailsCreateInput, CBMonthlyDetailsUncheckedCreateInput>
  }

  /**
   * CBMonthlyDetails createMany
   */
  export type CBMonthlyDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CBMonthlyDetails.
     */
    data: CBMonthlyDetailsCreateManyInput | CBMonthlyDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CBMonthlyDetails update
   */
  export type CBMonthlyDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * The data needed to update a CBMonthlyDetails.
     */
    data: XOR<CBMonthlyDetailsUpdateInput, CBMonthlyDetailsUncheckedUpdateInput>
    /**
     * Choose, which CBMonthlyDetails to update.
     */
    where: CBMonthlyDetailsWhereUniqueInput
  }

  /**
   * CBMonthlyDetails updateMany
   */
  export type CBMonthlyDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CBMonthlyDetails.
     */
    data: XOR<CBMonthlyDetailsUpdateManyMutationInput, CBMonthlyDetailsUncheckedUpdateManyInput>
    /**
     * Filter which CBMonthlyDetails to update
     */
    where?: CBMonthlyDetailsWhereInput
    /**
     * Limit how many CBMonthlyDetails to update.
     */
    limit?: number
  }

  /**
   * CBMonthlyDetails upsert
   */
  export type CBMonthlyDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * The filter to search for the CBMonthlyDetails to update in case it exists.
     */
    where: CBMonthlyDetailsWhereUniqueInput
    /**
     * In case the CBMonthlyDetails found by the `where` argument doesn't exist, create a new CBMonthlyDetails with this data.
     */
    create: XOR<CBMonthlyDetailsCreateInput, CBMonthlyDetailsUncheckedCreateInput>
    /**
     * In case the CBMonthlyDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CBMonthlyDetailsUpdateInput, CBMonthlyDetailsUncheckedUpdateInput>
  }

  /**
   * CBMonthlyDetails delete
   */
  export type CBMonthlyDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
    /**
     * Filter which CBMonthlyDetails to delete.
     */
    where: CBMonthlyDetailsWhereUniqueInput
  }

  /**
   * CBMonthlyDetails deleteMany
   */
  export type CBMonthlyDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CBMonthlyDetails to delete
     */
    where?: CBMonthlyDetailsWhereInput
    /**
     * Limit how many CBMonthlyDetails to delete.
     */
    limit?: number
  }

  /**
   * CBMonthlyDetails without action
   */
  export type CBMonthlyDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBMonthlyDetails
     */
    select?: CBMonthlyDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBMonthlyDetails
     */
    omit?: CBMonthlyDetailsOmit<ExtArgs> | null
  }


  /**
   * Model CBSummaryCards
   */

  export type AggregateCBSummaryCards = {
    _count: CBSummaryCardsCountAggregateOutputType | null
    _avg: CBSummaryCardsAvgAggregateOutputType | null
    _sum: CBSummaryCardsSumAggregateOutputType | null
    _min: CBSummaryCardsMinAggregateOutputType | null
    _max: CBSummaryCardsMaxAggregateOutputType | null
  }

  export type CBSummaryCardsAvgAggregateOutputType = {
    id: number | null
  }

  export type CBSummaryCardsSumAggregateOutputType = {
    id: number | null
  }

  export type CBSummaryCardsMinAggregateOutputType = {
    id: number | null
    total_energy: string | null
    used: string | null
    remaining: string | null
    overrun_rate: string | null
    unit: string | null
  }

  export type CBSummaryCardsMaxAggregateOutputType = {
    id: number | null
    total_energy: string | null
    used: string | null
    remaining: string | null
    overrun_rate: string | null
    unit: string | null
  }

  export type CBSummaryCardsCountAggregateOutputType = {
    id: number
    total_energy: number
    used: number
    remaining: number
    overrun_rate: number
    unit: number
    _all: number
  }


  export type CBSummaryCardsAvgAggregateInputType = {
    id?: true
  }

  export type CBSummaryCardsSumAggregateInputType = {
    id?: true
  }

  export type CBSummaryCardsMinAggregateInputType = {
    id?: true
    total_energy?: true
    used?: true
    remaining?: true
    overrun_rate?: true
    unit?: true
  }

  export type CBSummaryCardsMaxAggregateInputType = {
    id?: true
    total_energy?: true
    used?: true
    remaining?: true
    overrun_rate?: true
    unit?: true
  }

  export type CBSummaryCardsCountAggregateInputType = {
    id?: true
    total_energy?: true
    used?: true
    remaining?: true
    overrun_rate?: true
    unit?: true
    _all?: true
  }

  export type CBSummaryCardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CBSummaryCards to aggregate.
     */
    where?: CBSummaryCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBSummaryCards to fetch.
     */
    orderBy?: CBSummaryCardsOrderByWithRelationInput | CBSummaryCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CBSummaryCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBSummaryCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBSummaryCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CBSummaryCards
    **/
    _count?: true | CBSummaryCardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CBSummaryCardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CBSummaryCardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CBSummaryCardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CBSummaryCardsMaxAggregateInputType
  }

  export type GetCBSummaryCardsAggregateType<T extends CBSummaryCardsAggregateArgs> = {
        [P in keyof T & keyof AggregateCBSummaryCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCBSummaryCards[P]>
      : GetScalarType<T[P], AggregateCBSummaryCards[P]>
  }




  export type CBSummaryCardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CBSummaryCardsWhereInput
    orderBy?: CBSummaryCardsOrderByWithAggregationInput | CBSummaryCardsOrderByWithAggregationInput[]
    by: CBSummaryCardsScalarFieldEnum[] | CBSummaryCardsScalarFieldEnum
    having?: CBSummaryCardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CBSummaryCardsCountAggregateInputType | true
    _avg?: CBSummaryCardsAvgAggregateInputType
    _sum?: CBSummaryCardsSumAggregateInputType
    _min?: CBSummaryCardsMinAggregateInputType
    _max?: CBSummaryCardsMaxAggregateInputType
  }

  export type CBSummaryCardsGroupByOutputType = {
    id: number
    total_energy: string | null
    used: string | null
    remaining: string | null
    overrun_rate: string | null
    unit: string | null
    _count: CBSummaryCardsCountAggregateOutputType | null
    _avg: CBSummaryCardsAvgAggregateOutputType | null
    _sum: CBSummaryCardsSumAggregateOutputType | null
    _min: CBSummaryCardsMinAggregateOutputType | null
    _max: CBSummaryCardsMaxAggregateOutputType | null
  }

  type GetCBSummaryCardsGroupByPayload<T extends CBSummaryCardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CBSummaryCardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CBSummaryCardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CBSummaryCardsGroupByOutputType[P]>
            : GetScalarType<T[P], CBSummaryCardsGroupByOutputType[P]>
        }
      >
    >


  export type CBSummaryCardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    total_energy?: boolean
    used?: boolean
    remaining?: boolean
    overrun_rate?: boolean
    unit?: boolean
  }, ExtArgs["result"]["cBSummaryCards"]>



  export type CBSummaryCardsSelectScalar = {
    id?: boolean
    total_energy?: boolean
    used?: boolean
    remaining?: boolean
    overrun_rate?: boolean
    unit?: boolean
  }

  export type CBSummaryCardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "total_energy" | "used" | "remaining" | "overrun_rate" | "unit", ExtArgs["result"]["cBSummaryCards"]>

  export type $CBSummaryCardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CBSummaryCards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      total_energy: string | null
      used: string | null
      remaining: string | null
      overrun_rate: string | null
      unit: string | null
    }, ExtArgs["result"]["cBSummaryCards"]>
    composites: {}
  }

  type CBSummaryCardsGetPayload<S extends boolean | null | undefined | CBSummaryCardsDefaultArgs> = $Result.GetResult<Prisma.$CBSummaryCardsPayload, S>

  type CBSummaryCardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CBSummaryCardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CBSummaryCardsCountAggregateInputType | true
    }

  export interface CBSummaryCardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CBSummaryCards'], meta: { name: 'CBSummaryCards' } }
    /**
     * Find zero or one CBSummaryCards that matches the filter.
     * @param {CBSummaryCardsFindUniqueArgs} args - Arguments to find a CBSummaryCards
     * @example
     * // Get one CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CBSummaryCardsFindUniqueArgs>(args: SelectSubset<T, CBSummaryCardsFindUniqueArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CBSummaryCards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CBSummaryCardsFindUniqueOrThrowArgs} args - Arguments to find a CBSummaryCards
     * @example
     * // Get one CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CBSummaryCardsFindUniqueOrThrowArgs>(args: SelectSubset<T, CBSummaryCardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CBSummaryCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsFindFirstArgs} args - Arguments to find a CBSummaryCards
     * @example
     * // Get one CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CBSummaryCardsFindFirstArgs>(args?: SelectSubset<T, CBSummaryCardsFindFirstArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CBSummaryCards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsFindFirstOrThrowArgs} args - Arguments to find a CBSummaryCards
     * @example
     * // Get one CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CBSummaryCardsFindFirstOrThrowArgs>(args?: SelectSubset<T, CBSummaryCardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CBSummaryCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.findMany()
     * 
     * // Get first 10 CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cBSummaryCardsWithIdOnly = await prisma.cBSummaryCards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CBSummaryCardsFindManyArgs>(args?: SelectSubset<T, CBSummaryCardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CBSummaryCards.
     * @param {CBSummaryCardsCreateArgs} args - Arguments to create a CBSummaryCards.
     * @example
     * // Create one CBSummaryCards
     * const CBSummaryCards = await prisma.cBSummaryCards.create({
     *   data: {
     *     // ... data to create a CBSummaryCards
     *   }
     * })
     * 
     */
    create<T extends CBSummaryCardsCreateArgs>(args: SelectSubset<T, CBSummaryCardsCreateArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CBSummaryCards.
     * @param {CBSummaryCardsCreateManyArgs} args - Arguments to create many CBSummaryCards.
     * @example
     * // Create many CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CBSummaryCardsCreateManyArgs>(args?: SelectSubset<T, CBSummaryCardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CBSummaryCards.
     * @param {CBSummaryCardsDeleteArgs} args - Arguments to delete one CBSummaryCards.
     * @example
     * // Delete one CBSummaryCards
     * const CBSummaryCards = await prisma.cBSummaryCards.delete({
     *   where: {
     *     // ... filter to delete one CBSummaryCards
     *   }
     * })
     * 
     */
    delete<T extends CBSummaryCardsDeleteArgs>(args: SelectSubset<T, CBSummaryCardsDeleteArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CBSummaryCards.
     * @param {CBSummaryCardsUpdateArgs} args - Arguments to update one CBSummaryCards.
     * @example
     * // Update one CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CBSummaryCardsUpdateArgs>(args: SelectSubset<T, CBSummaryCardsUpdateArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CBSummaryCards.
     * @param {CBSummaryCardsDeleteManyArgs} args - Arguments to filter CBSummaryCards to delete.
     * @example
     * // Delete a few CBSummaryCards
     * const { count } = await prisma.cBSummaryCards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CBSummaryCardsDeleteManyArgs>(args?: SelectSubset<T, CBSummaryCardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CBSummaryCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CBSummaryCardsUpdateManyArgs>(args: SelectSubset<T, CBSummaryCardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CBSummaryCards.
     * @param {CBSummaryCardsUpsertArgs} args - Arguments to update or create a CBSummaryCards.
     * @example
     * // Update or create a CBSummaryCards
     * const cBSummaryCards = await prisma.cBSummaryCards.upsert({
     *   create: {
     *     // ... data to create a CBSummaryCards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CBSummaryCards we want to update
     *   }
     * })
     */
    upsert<T extends CBSummaryCardsUpsertArgs>(args: SelectSubset<T, CBSummaryCardsUpsertArgs<ExtArgs>>): Prisma__CBSummaryCardsClient<$Result.GetResult<Prisma.$CBSummaryCardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CBSummaryCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsCountArgs} args - Arguments to filter CBSummaryCards to count.
     * @example
     * // Count the number of CBSummaryCards
     * const count = await prisma.cBSummaryCards.count({
     *   where: {
     *     // ... the filter for the CBSummaryCards we want to count
     *   }
     * })
    **/
    count<T extends CBSummaryCardsCountArgs>(
      args?: Subset<T, CBSummaryCardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CBSummaryCardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CBSummaryCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CBSummaryCardsAggregateArgs>(args: Subset<T, CBSummaryCardsAggregateArgs>): Prisma.PrismaPromise<GetCBSummaryCardsAggregateType<T>>

    /**
     * Group by CBSummaryCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CBSummaryCardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CBSummaryCardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CBSummaryCardsGroupByArgs['orderBy'] }
        : { orderBy?: CBSummaryCardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CBSummaryCardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCBSummaryCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CBSummaryCards model
   */
  readonly fields: CBSummaryCardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CBSummaryCards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CBSummaryCardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CBSummaryCards model
   */
  interface CBSummaryCardsFieldRefs {
    readonly id: FieldRef<"CBSummaryCards", 'Int'>
    readonly total_energy: FieldRef<"CBSummaryCards", 'String'>
    readonly used: FieldRef<"CBSummaryCards", 'String'>
    readonly remaining: FieldRef<"CBSummaryCards", 'String'>
    readonly overrun_rate: FieldRef<"CBSummaryCards", 'String'>
    readonly unit: FieldRef<"CBSummaryCards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CBSummaryCards findUnique
   */
  export type CBSummaryCardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * Filter, which CBSummaryCards to fetch.
     */
    where: CBSummaryCardsWhereUniqueInput
  }

  /**
   * CBSummaryCards findUniqueOrThrow
   */
  export type CBSummaryCardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * Filter, which CBSummaryCards to fetch.
     */
    where: CBSummaryCardsWhereUniqueInput
  }

  /**
   * CBSummaryCards findFirst
   */
  export type CBSummaryCardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * Filter, which CBSummaryCards to fetch.
     */
    where?: CBSummaryCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBSummaryCards to fetch.
     */
    orderBy?: CBSummaryCardsOrderByWithRelationInput | CBSummaryCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CBSummaryCards.
     */
    cursor?: CBSummaryCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBSummaryCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBSummaryCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CBSummaryCards.
     */
    distinct?: CBSummaryCardsScalarFieldEnum | CBSummaryCardsScalarFieldEnum[]
  }

  /**
   * CBSummaryCards findFirstOrThrow
   */
  export type CBSummaryCardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * Filter, which CBSummaryCards to fetch.
     */
    where?: CBSummaryCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBSummaryCards to fetch.
     */
    orderBy?: CBSummaryCardsOrderByWithRelationInput | CBSummaryCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CBSummaryCards.
     */
    cursor?: CBSummaryCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBSummaryCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBSummaryCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CBSummaryCards.
     */
    distinct?: CBSummaryCardsScalarFieldEnum | CBSummaryCardsScalarFieldEnum[]
  }

  /**
   * CBSummaryCards findMany
   */
  export type CBSummaryCardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * Filter, which CBSummaryCards to fetch.
     */
    where?: CBSummaryCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CBSummaryCards to fetch.
     */
    orderBy?: CBSummaryCardsOrderByWithRelationInput | CBSummaryCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CBSummaryCards.
     */
    cursor?: CBSummaryCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CBSummaryCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CBSummaryCards.
     */
    skip?: number
    distinct?: CBSummaryCardsScalarFieldEnum | CBSummaryCardsScalarFieldEnum[]
  }

  /**
   * CBSummaryCards create
   */
  export type CBSummaryCardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * The data needed to create a CBSummaryCards.
     */
    data?: XOR<CBSummaryCardsCreateInput, CBSummaryCardsUncheckedCreateInput>
  }

  /**
   * CBSummaryCards createMany
   */
  export type CBSummaryCardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CBSummaryCards.
     */
    data: CBSummaryCardsCreateManyInput | CBSummaryCardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CBSummaryCards update
   */
  export type CBSummaryCardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * The data needed to update a CBSummaryCards.
     */
    data: XOR<CBSummaryCardsUpdateInput, CBSummaryCardsUncheckedUpdateInput>
    /**
     * Choose, which CBSummaryCards to update.
     */
    where: CBSummaryCardsWhereUniqueInput
  }

  /**
   * CBSummaryCards updateMany
   */
  export type CBSummaryCardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CBSummaryCards.
     */
    data: XOR<CBSummaryCardsUpdateManyMutationInput, CBSummaryCardsUncheckedUpdateManyInput>
    /**
     * Filter which CBSummaryCards to update
     */
    where?: CBSummaryCardsWhereInput
    /**
     * Limit how many CBSummaryCards to update.
     */
    limit?: number
  }

  /**
   * CBSummaryCards upsert
   */
  export type CBSummaryCardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * The filter to search for the CBSummaryCards to update in case it exists.
     */
    where: CBSummaryCardsWhereUniqueInput
    /**
     * In case the CBSummaryCards found by the `where` argument doesn't exist, create a new CBSummaryCards with this data.
     */
    create: XOR<CBSummaryCardsCreateInput, CBSummaryCardsUncheckedCreateInput>
    /**
     * In case the CBSummaryCards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CBSummaryCardsUpdateInput, CBSummaryCardsUncheckedUpdateInput>
  }

  /**
   * CBSummaryCards delete
   */
  export type CBSummaryCardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
    /**
     * Filter which CBSummaryCards to delete.
     */
    where: CBSummaryCardsWhereUniqueInput
  }

  /**
   * CBSummaryCards deleteMany
   */
  export type CBSummaryCardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CBSummaryCards to delete
     */
    where?: CBSummaryCardsWhereInput
    /**
     * Limit how many CBSummaryCards to delete.
     */
    limit?: number
  }

  /**
   * CBSummaryCards without action
   */
  export type CBSummaryCardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CBSummaryCards
     */
    select?: CBSummaryCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CBSummaryCards
     */
    omit?: CBSummaryCardsOmit<ExtArgs> | null
  }


  /**
   * Model CFDetails
   */

  export type AggregateCFDetails = {
    _count: CFDetailsCountAggregateOutputType | null
    _avg: CFDetailsAvgAggregateOutputType | null
    _sum: CFDetailsSumAggregateOutputType | null
    _min: CFDetailsMinAggregateOutputType | null
    _max: CFDetailsMaxAggregateOutputType | null
  }

  export type CFDetailsAvgAggregateOutputType = {
    id: number | null
    emission: Decimal | null
    factor: Decimal | null
    total: Decimal | null
  }

  export type CFDetailsSumAggregateOutputType = {
    id: number | null
    emission: Decimal | null
    factor: Decimal | null
    total: Decimal | null
  }

  export type CFDetailsMinAggregateOutputType = {
    id: number | null
    process: string | null
    scope: string | null
    emission: Decimal | null
    factor: Decimal | null
    total: Decimal | null
  }

  export type CFDetailsMaxAggregateOutputType = {
    id: number | null
    process: string | null
    scope: string | null
    emission: Decimal | null
    factor: Decimal | null
    total: Decimal | null
  }

  export type CFDetailsCountAggregateOutputType = {
    id: number
    process: number
    scope: number
    emission: number
    factor: number
    total: number
    _all: number
  }


  export type CFDetailsAvgAggregateInputType = {
    id?: true
    emission?: true
    factor?: true
    total?: true
  }

  export type CFDetailsSumAggregateInputType = {
    id?: true
    emission?: true
    factor?: true
    total?: true
  }

  export type CFDetailsMinAggregateInputType = {
    id?: true
    process?: true
    scope?: true
    emission?: true
    factor?: true
    total?: true
  }

  export type CFDetailsMaxAggregateInputType = {
    id?: true
    process?: true
    scope?: true
    emission?: true
    factor?: true
    total?: true
  }

  export type CFDetailsCountAggregateInputType = {
    id?: true
    process?: true
    scope?: true
    emission?: true
    factor?: true
    total?: true
    _all?: true
  }

  export type CFDetailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CFDetails to aggregate.
     */
    where?: CFDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFDetails to fetch.
     */
    orderBy?: CFDetailsOrderByWithRelationInput | CFDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CFDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CFDetails
    **/
    _count?: true | CFDetailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CFDetailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CFDetailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CFDetailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CFDetailsMaxAggregateInputType
  }

  export type GetCFDetailsAggregateType<T extends CFDetailsAggregateArgs> = {
        [P in keyof T & keyof AggregateCFDetails]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCFDetails[P]>
      : GetScalarType<T[P], AggregateCFDetails[P]>
  }




  export type CFDetailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CFDetailsWhereInput
    orderBy?: CFDetailsOrderByWithAggregationInput | CFDetailsOrderByWithAggregationInput[]
    by: CFDetailsScalarFieldEnum[] | CFDetailsScalarFieldEnum
    having?: CFDetailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CFDetailsCountAggregateInputType | true
    _avg?: CFDetailsAvgAggregateInputType
    _sum?: CFDetailsSumAggregateInputType
    _min?: CFDetailsMinAggregateInputType
    _max?: CFDetailsMaxAggregateInputType
  }

  export type CFDetailsGroupByOutputType = {
    id: number
    process: string | null
    scope: string | null
    emission: Decimal | null
    factor: Decimal | null
    total: Decimal | null
    _count: CFDetailsCountAggregateOutputType | null
    _avg: CFDetailsAvgAggregateOutputType | null
    _sum: CFDetailsSumAggregateOutputType | null
    _min: CFDetailsMinAggregateOutputType | null
    _max: CFDetailsMaxAggregateOutputType | null
  }

  type GetCFDetailsGroupByPayload<T extends CFDetailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CFDetailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CFDetailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CFDetailsGroupByOutputType[P]>
            : GetScalarType<T[P], CFDetailsGroupByOutputType[P]>
        }
      >
    >


  export type CFDetailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    process?: boolean
    scope?: boolean
    emission?: boolean
    factor?: boolean
    total?: boolean
  }, ExtArgs["result"]["cFDetails"]>



  export type CFDetailsSelectScalar = {
    id?: boolean
    process?: boolean
    scope?: boolean
    emission?: boolean
    factor?: boolean
    total?: boolean
  }

  export type CFDetailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "process" | "scope" | "emission" | "factor" | "total", ExtArgs["result"]["cFDetails"]>

  export type $CFDetailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CFDetails"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      process: string | null
      scope: string | null
      emission: Prisma.Decimal | null
      factor: Prisma.Decimal | null
      total: Prisma.Decimal | null
    }, ExtArgs["result"]["cFDetails"]>
    composites: {}
  }

  type CFDetailsGetPayload<S extends boolean | null | undefined | CFDetailsDefaultArgs> = $Result.GetResult<Prisma.$CFDetailsPayload, S>

  type CFDetailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CFDetailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CFDetailsCountAggregateInputType | true
    }

  export interface CFDetailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CFDetails'], meta: { name: 'CFDetails' } }
    /**
     * Find zero or one CFDetails that matches the filter.
     * @param {CFDetailsFindUniqueArgs} args - Arguments to find a CFDetails
     * @example
     * // Get one CFDetails
     * const cFDetails = await prisma.cFDetails.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CFDetailsFindUniqueArgs>(args: SelectSubset<T, CFDetailsFindUniqueArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CFDetails that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CFDetailsFindUniqueOrThrowArgs} args - Arguments to find a CFDetails
     * @example
     * // Get one CFDetails
     * const cFDetails = await prisma.cFDetails.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CFDetailsFindUniqueOrThrowArgs>(args: SelectSubset<T, CFDetailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CFDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsFindFirstArgs} args - Arguments to find a CFDetails
     * @example
     * // Get one CFDetails
     * const cFDetails = await prisma.cFDetails.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CFDetailsFindFirstArgs>(args?: SelectSubset<T, CFDetailsFindFirstArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CFDetails that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsFindFirstOrThrowArgs} args - Arguments to find a CFDetails
     * @example
     * // Get one CFDetails
     * const cFDetails = await prisma.cFDetails.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CFDetailsFindFirstOrThrowArgs>(args?: SelectSubset<T, CFDetailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CFDetails that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CFDetails
     * const cFDetails = await prisma.cFDetails.findMany()
     * 
     * // Get first 10 CFDetails
     * const cFDetails = await prisma.cFDetails.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cFDetailsWithIdOnly = await prisma.cFDetails.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CFDetailsFindManyArgs>(args?: SelectSubset<T, CFDetailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CFDetails.
     * @param {CFDetailsCreateArgs} args - Arguments to create a CFDetails.
     * @example
     * // Create one CFDetails
     * const CFDetails = await prisma.cFDetails.create({
     *   data: {
     *     // ... data to create a CFDetails
     *   }
     * })
     * 
     */
    create<T extends CFDetailsCreateArgs>(args: SelectSubset<T, CFDetailsCreateArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CFDetails.
     * @param {CFDetailsCreateManyArgs} args - Arguments to create many CFDetails.
     * @example
     * // Create many CFDetails
     * const cFDetails = await prisma.cFDetails.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CFDetailsCreateManyArgs>(args?: SelectSubset<T, CFDetailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CFDetails.
     * @param {CFDetailsDeleteArgs} args - Arguments to delete one CFDetails.
     * @example
     * // Delete one CFDetails
     * const CFDetails = await prisma.cFDetails.delete({
     *   where: {
     *     // ... filter to delete one CFDetails
     *   }
     * })
     * 
     */
    delete<T extends CFDetailsDeleteArgs>(args: SelectSubset<T, CFDetailsDeleteArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CFDetails.
     * @param {CFDetailsUpdateArgs} args - Arguments to update one CFDetails.
     * @example
     * // Update one CFDetails
     * const cFDetails = await prisma.cFDetails.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CFDetailsUpdateArgs>(args: SelectSubset<T, CFDetailsUpdateArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CFDetails.
     * @param {CFDetailsDeleteManyArgs} args - Arguments to filter CFDetails to delete.
     * @example
     * // Delete a few CFDetails
     * const { count } = await prisma.cFDetails.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CFDetailsDeleteManyArgs>(args?: SelectSubset<T, CFDetailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CFDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CFDetails
     * const cFDetails = await prisma.cFDetails.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CFDetailsUpdateManyArgs>(args: SelectSubset<T, CFDetailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CFDetails.
     * @param {CFDetailsUpsertArgs} args - Arguments to update or create a CFDetails.
     * @example
     * // Update or create a CFDetails
     * const cFDetails = await prisma.cFDetails.upsert({
     *   create: {
     *     // ... data to create a CFDetails
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CFDetails we want to update
     *   }
     * })
     */
    upsert<T extends CFDetailsUpsertArgs>(args: SelectSubset<T, CFDetailsUpsertArgs<ExtArgs>>): Prisma__CFDetailsClient<$Result.GetResult<Prisma.$CFDetailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CFDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsCountArgs} args - Arguments to filter CFDetails to count.
     * @example
     * // Count the number of CFDetails
     * const count = await prisma.cFDetails.count({
     *   where: {
     *     // ... the filter for the CFDetails we want to count
     *   }
     * })
    **/
    count<T extends CFDetailsCountArgs>(
      args?: Subset<T, CFDetailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CFDetailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CFDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CFDetailsAggregateArgs>(args: Subset<T, CFDetailsAggregateArgs>): Prisma.PrismaPromise<GetCFDetailsAggregateType<T>>

    /**
     * Group by CFDetails.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFDetailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CFDetailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CFDetailsGroupByArgs['orderBy'] }
        : { orderBy?: CFDetailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CFDetailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCFDetailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CFDetails model
   */
  readonly fields: CFDetailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CFDetails.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CFDetailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CFDetails model
   */
  interface CFDetailsFieldRefs {
    readonly id: FieldRef<"CFDetails", 'Int'>
    readonly process: FieldRef<"CFDetails", 'String'>
    readonly scope: FieldRef<"CFDetails", 'String'>
    readonly emission: FieldRef<"CFDetails", 'Decimal'>
    readonly factor: FieldRef<"CFDetails", 'Decimal'>
    readonly total: FieldRef<"CFDetails", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * CFDetails findUnique
   */
  export type CFDetailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CFDetails to fetch.
     */
    where: CFDetailsWhereUniqueInput
  }

  /**
   * CFDetails findUniqueOrThrow
   */
  export type CFDetailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CFDetails to fetch.
     */
    where: CFDetailsWhereUniqueInput
  }

  /**
   * CFDetails findFirst
   */
  export type CFDetailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CFDetails to fetch.
     */
    where?: CFDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFDetails to fetch.
     */
    orderBy?: CFDetailsOrderByWithRelationInput | CFDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CFDetails.
     */
    cursor?: CFDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CFDetails.
     */
    distinct?: CFDetailsScalarFieldEnum | CFDetailsScalarFieldEnum[]
  }

  /**
   * CFDetails findFirstOrThrow
   */
  export type CFDetailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CFDetails to fetch.
     */
    where?: CFDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFDetails to fetch.
     */
    orderBy?: CFDetailsOrderByWithRelationInput | CFDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CFDetails.
     */
    cursor?: CFDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFDetails.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CFDetails.
     */
    distinct?: CFDetailsScalarFieldEnum | CFDetailsScalarFieldEnum[]
  }

  /**
   * CFDetails findMany
   */
  export type CFDetailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * Filter, which CFDetails to fetch.
     */
    where?: CFDetailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFDetails to fetch.
     */
    orderBy?: CFDetailsOrderByWithRelationInput | CFDetailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CFDetails.
     */
    cursor?: CFDetailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFDetails from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFDetails.
     */
    skip?: number
    distinct?: CFDetailsScalarFieldEnum | CFDetailsScalarFieldEnum[]
  }

  /**
   * CFDetails create
   */
  export type CFDetailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * The data needed to create a CFDetails.
     */
    data?: XOR<CFDetailsCreateInput, CFDetailsUncheckedCreateInput>
  }

  /**
   * CFDetails createMany
   */
  export type CFDetailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CFDetails.
     */
    data: CFDetailsCreateManyInput | CFDetailsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CFDetails update
   */
  export type CFDetailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * The data needed to update a CFDetails.
     */
    data: XOR<CFDetailsUpdateInput, CFDetailsUncheckedUpdateInput>
    /**
     * Choose, which CFDetails to update.
     */
    where: CFDetailsWhereUniqueInput
  }

  /**
   * CFDetails updateMany
   */
  export type CFDetailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CFDetails.
     */
    data: XOR<CFDetailsUpdateManyMutationInput, CFDetailsUncheckedUpdateManyInput>
    /**
     * Filter which CFDetails to update
     */
    where?: CFDetailsWhereInput
    /**
     * Limit how many CFDetails to update.
     */
    limit?: number
  }

  /**
   * CFDetails upsert
   */
  export type CFDetailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * The filter to search for the CFDetails to update in case it exists.
     */
    where: CFDetailsWhereUniqueInput
    /**
     * In case the CFDetails found by the `where` argument doesn't exist, create a new CFDetails with this data.
     */
    create: XOR<CFDetailsCreateInput, CFDetailsUncheckedCreateInput>
    /**
     * In case the CFDetails was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CFDetailsUpdateInput, CFDetailsUncheckedUpdateInput>
  }

  /**
   * CFDetails delete
   */
  export type CFDetailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
    /**
     * Filter which CFDetails to delete.
     */
    where: CFDetailsWhereUniqueInput
  }

  /**
   * CFDetails deleteMany
   */
  export type CFDetailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CFDetails to delete
     */
    where?: CFDetailsWhereInput
    /**
     * Limit how many CFDetails to delete.
     */
    limit?: number
  }

  /**
   * CFDetails without action
   */
  export type CFDetailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFDetails
     */
    select?: CFDetailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFDetails
     */
    omit?: CFDetailsOmit<ExtArgs> | null
  }


  /**
   * Model CFPieChart
   */

  export type AggregateCFPieChart = {
    _count: CFPieChartCountAggregateOutputType | null
    _avg: CFPieChartAvgAggregateOutputType | null
    _sum: CFPieChartSumAggregateOutputType | null
    _min: CFPieChartMinAggregateOutputType | null
    _max: CFPieChartMaxAggregateOutputType | null
  }

  export type CFPieChartAvgAggregateOutputType = {
    id: number | null
  }

  export type CFPieChartSumAggregateOutputType = {
    id: number | null
  }

  export type CFPieChartMinAggregateOutputType = {
    id: number | null
    scope: string | null
    value: string | null
    percentage: string | null
  }

  export type CFPieChartMaxAggregateOutputType = {
    id: number | null
    scope: string | null
    value: string | null
    percentage: string | null
  }

  export type CFPieChartCountAggregateOutputType = {
    id: number
    scope: number
    value: number
    percentage: number
    _all: number
  }


  export type CFPieChartAvgAggregateInputType = {
    id?: true
  }

  export type CFPieChartSumAggregateInputType = {
    id?: true
  }

  export type CFPieChartMinAggregateInputType = {
    id?: true
    scope?: true
    value?: true
    percentage?: true
  }

  export type CFPieChartMaxAggregateInputType = {
    id?: true
    scope?: true
    value?: true
    percentage?: true
  }

  export type CFPieChartCountAggregateInputType = {
    id?: true
    scope?: true
    value?: true
    percentage?: true
    _all?: true
  }

  export type CFPieChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CFPieChart to aggregate.
     */
    where?: CFPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFPieCharts to fetch.
     */
    orderBy?: CFPieChartOrderByWithRelationInput | CFPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CFPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CFPieCharts
    **/
    _count?: true | CFPieChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CFPieChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CFPieChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CFPieChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CFPieChartMaxAggregateInputType
  }

  export type GetCFPieChartAggregateType<T extends CFPieChartAggregateArgs> = {
        [P in keyof T & keyof AggregateCFPieChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCFPieChart[P]>
      : GetScalarType<T[P], AggregateCFPieChart[P]>
  }




  export type CFPieChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CFPieChartWhereInput
    orderBy?: CFPieChartOrderByWithAggregationInput | CFPieChartOrderByWithAggregationInput[]
    by: CFPieChartScalarFieldEnum[] | CFPieChartScalarFieldEnum
    having?: CFPieChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CFPieChartCountAggregateInputType | true
    _avg?: CFPieChartAvgAggregateInputType
    _sum?: CFPieChartSumAggregateInputType
    _min?: CFPieChartMinAggregateInputType
    _max?: CFPieChartMaxAggregateInputType
  }

  export type CFPieChartGroupByOutputType = {
    id: number
    scope: string | null
    value: string | null
    percentage: string | null
    _count: CFPieChartCountAggregateOutputType | null
    _avg: CFPieChartAvgAggregateOutputType | null
    _sum: CFPieChartSumAggregateOutputType | null
    _min: CFPieChartMinAggregateOutputType | null
    _max: CFPieChartMaxAggregateOutputType | null
  }

  type GetCFPieChartGroupByPayload<T extends CFPieChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CFPieChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CFPieChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CFPieChartGroupByOutputType[P]>
            : GetScalarType<T[P], CFPieChartGroupByOutputType[P]>
        }
      >
    >


  export type CFPieChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    scope?: boolean
    value?: boolean
    percentage?: boolean
  }, ExtArgs["result"]["cFPieChart"]>



  export type CFPieChartSelectScalar = {
    id?: boolean
    scope?: boolean
    value?: boolean
    percentage?: boolean
  }

  export type CFPieChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "scope" | "value" | "percentage", ExtArgs["result"]["cFPieChart"]>

  export type $CFPieChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CFPieChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      scope: string | null
      value: string | null
      percentage: string | null
    }, ExtArgs["result"]["cFPieChart"]>
    composites: {}
  }

  type CFPieChartGetPayload<S extends boolean | null | undefined | CFPieChartDefaultArgs> = $Result.GetResult<Prisma.$CFPieChartPayload, S>

  type CFPieChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CFPieChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CFPieChartCountAggregateInputType | true
    }

  export interface CFPieChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CFPieChart'], meta: { name: 'CFPieChart' } }
    /**
     * Find zero or one CFPieChart that matches the filter.
     * @param {CFPieChartFindUniqueArgs} args - Arguments to find a CFPieChart
     * @example
     * // Get one CFPieChart
     * const cFPieChart = await prisma.cFPieChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CFPieChartFindUniqueArgs>(args: SelectSubset<T, CFPieChartFindUniqueArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CFPieChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CFPieChartFindUniqueOrThrowArgs} args - Arguments to find a CFPieChart
     * @example
     * // Get one CFPieChart
     * const cFPieChart = await prisma.cFPieChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CFPieChartFindUniqueOrThrowArgs>(args: SelectSubset<T, CFPieChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CFPieChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartFindFirstArgs} args - Arguments to find a CFPieChart
     * @example
     * // Get one CFPieChart
     * const cFPieChart = await prisma.cFPieChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CFPieChartFindFirstArgs>(args?: SelectSubset<T, CFPieChartFindFirstArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CFPieChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartFindFirstOrThrowArgs} args - Arguments to find a CFPieChart
     * @example
     * // Get one CFPieChart
     * const cFPieChart = await prisma.cFPieChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CFPieChartFindFirstOrThrowArgs>(args?: SelectSubset<T, CFPieChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CFPieCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CFPieCharts
     * const cFPieCharts = await prisma.cFPieChart.findMany()
     * 
     * // Get first 10 CFPieCharts
     * const cFPieCharts = await prisma.cFPieChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cFPieChartWithIdOnly = await prisma.cFPieChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CFPieChartFindManyArgs>(args?: SelectSubset<T, CFPieChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CFPieChart.
     * @param {CFPieChartCreateArgs} args - Arguments to create a CFPieChart.
     * @example
     * // Create one CFPieChart
     * const CFPieChart = await prisma.cFPieChart.create({
     *   data: {
     *     // ... data to create a CFPieChart
     *   }
     * })
     * 
     */
    create<T extends CFPieChartCreateArgs>(args: SelectSubset<T, CFPieChartCreateArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CFPieCharts.
     * @param {CFPieChartCreateManyArgs} args - Arguments to create many CFPieCharts.
     * @example
     * // Create many CFPieCharts
     * const cFPieChart = await prisma.cFPieChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CFPieChartCreateManyArgs>(args?: SelectSubset<T, CFPieChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CFPieChart.
     * @param {CFPieChartDeleteArgs} args - Arguments to delete one CFPieChart.
     * @example
     * // Delete one CFPieChart
     * const CFPieChart = await prisma.cFPieChart.delete({
     *   where: {
     *     // ... filter to delete one CFPieChart
     *   }
     * })
     * 
     */
    delete<T extends CFPieChartDeleteArgs>(args: SelectSubset<T, CFPieChartDeleteArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CFPieChart.
     * @param {CFPieChartUpdateArgs} args - Arguments to update one CFPieChart.
     * @example
     * // Update one CFPieChart
     * const cFPieChart = await prisma.cFPieChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CFPieChartUpdateArgs>(args: SelectSubset<T, CFPieChartUpdateArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CFPieCharts.
     * @param {CFPieChartDeleteManyArgs} args - Arguments to filter CFPieCharts to delete.
     * @example
     * // Delete a few CFPieCharts
     * const { count } = await prisma.cFPieChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CFPieChartDeleteManyArgs>(args?: SelectSubset<T, CFPieChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CFPieCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CFPieCharts
     * const cFPieChart = await prisma.cFPieChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CFPieChartUpdateManyArgs>(args: SelectSubset<T, CFPieChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CFPieChart.
     * @param {CFPieChartUpsertArgs} args - Arguments to update or create a CFPieChart.
     * @example
     * // Update or create a CFPieChart
     * const cFPieChart = await prisma.cFPieChart.upsert({
     *   create: {
     *     // ... data to create a CFPieChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CFPieChart we want to update
     *   }
     * })
     */
    upsert<T extends CFPieChartUpsertArgs>(args: SelectSubset<T, CFPieChartUpsertArgs<ExtArgs>>): Prisma__CFPieChartClient<$Result.GetResult<Prisma.$CFPieChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CFPieCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartCountArgs} args - Arguments to filter CFPieCharts to count.
     * @example
     * // Count the number of CFPieCharts
     * const count = await prisma.cFPieChart.count({
     *   where: {
     *     // ... the filter for the CFPieCharts we want to count
     *   }
     * })
    **/
    count<T extends CFPieChartCountArgs>(
      args?: Subset<T, CFPieChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CFPieChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CFPieChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CFPieChartAggregateArgs>(args: Subset<T, CFPieChartAggregateArgs>): Prisma.PrismaPromise<GetCFPieChartAggregateType<T>>

    /**
     * Group by CFPieChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFPieChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CFPieChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CFPieChartGroupByArgs['orderBy'] }
        : { orderBy?: CFPieChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CFPieChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCFPieChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CFPieChart model
   */
  readonly fields: CFPieChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CFPieChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CFPieChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CFPieChart model
   */
  interface CFPieChartFieldRefs {
    readonly id: FieldRef<"CFPieChart", 'Int'>
    readonly scope: FieldRef<"CFPieChart", 'String'>
    readonly value: FieldRef<"CFPieChart", 'String'>
    readonly percentage: FieldRef<"CFPieChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CFPieChart findUnique
   */
  export type CFPieChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CFPieChart to fetch.
     */
    where: CFPieChartWhereUniqueInput
  }

  /**
   * CFPieChart findUniqueOrThrow
   */
  export type CFPieChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CFPieChart to fetch.
     */
    where: CFPieChartWhereUniqueInput
  }

  /**
   * CFPieChart findFirst
   */
  export type CFPieChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CFPieChart to fetch.
     */
    where?: CFPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFPieCharts to fetch.
     */
    orderBy?: CFPieChartOrderByWithRelationInput | CFPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CFPieCharts.
     */
    cursor?: CFPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CFPieCharts.
     */
    distinct?: CFPieChartScalarFieldEnum | CFPieChartScalarFieldEnum[]
  }

  /**
   * CFPieChart findFirstOrThrow
   */
  export type CFPieChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CFPieChart to fetch.
     */
    where?: CFPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFPieCharts to fetch.
     */
    orderBy?: CFPieChartOrderByWithRelationInput | CFPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CFPieCharts.
     */
    cursor?: CFPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CFPieCharts.
     */
    distinct?: CFPieChartScalarFieldEnum | CFPieChartScalarFieldEnum[]
  }

  /**
   * CFPieChart findMany
   */
  export type CFPieChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * Filter, which CFPieCharts to fetch.
     */
    where?: CFPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFPieCharts to fetch.
     */
    orderBy?: CFPieChartOrderByWithRelationInput | CFPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CFPieCharts.
     */
    cursor?: CFPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFPieCharts.
     */
    skip?: number
    distinct?: CFPieChartScalarFieldEnum | CFPieChartScalarFieldEnum[]
  }

  /**
   * CFPieChart create
   */
  export type CFPieChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * The data needed to create a CFPieChart.
     */
    data?: XOR<CFPieChartCreateInput, CFPieChartUncheckedCreateInput>
  }

  /**
   * CFPieChart createMany
   */
  export type CFPieChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CFPieCharts.
     */
    data: CFPieChartCreateManyInput | CFPieChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CFPieChart update
   */
  export type CFPieChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * The data needed to update a CFPieChart.
     */
    data: XOR<CFPieChartUpdateInput, CFPieChartUncheckedUpdateInput>
    /**
     * Choose, which CFPieChart to update.
     */
    where: CFPieChartWhereUniqueInput
  }

  /**
   * CFPieChart updateMany
   */
  export type CFPieChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CFPieCharts.
     */
    data: XOR<CFPieChartUpdateManyMutationInput, CFPieChartUncheckedUpdateManyInput>
    /**
     * Filter which CFPieCharts to update
     */
    where?: CFPieChartWhereInput
    /**
     * Limit how many CFPieCharts to update.
     */
    limit?: number
  }

  /**
   * CFPieChart upsert
   */
  export type CFPieChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * The filter to search for the CFPieChart to update in case it exists.
     */
    where: CFPieChartWhereUniqueInput
    /**
     * In case the CFPieChart found by the `where` argument doesn't exist, create a new CFPieChart with this data.
     */
    create: XOR<CFPieChartCreateInput, CFPieChartUncheckedCreateInput>
    /**
     * In case the CFPieChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CFPieChartUpdateInput, CFPieChartUncheckedUpdateInput>
  }

  /**
   * CFPieChart delete
   */
  export type CFPieChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
    /**
     * Filter which CFPieChart to delete.
     */
    where: CFPieChartWhereUniqueInput
  }

  /**
   * CFPieChart deleteMany
   */
  export type CFPieChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CFPieCharts to delete
     */
    where?: CFPieChartWhereInput
    /**
     * Limit how many CFPieCharts to delete.
     */
    limit?: number
  }

  /**
   * CFPieChart without action
   */
  export type CFPieChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFPieChart
     */
    select?: CFPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFPieChart
     */
    omit?: CFPieChartOmit<ExtArgs> | null
  }


  /**
   * Model CFTrendChart
   */

  export type AggregateCFTrendChart = {
    _count: CFTrendChartCountAggregateOutputType | null
    _avg: CFTrendChartAvgAggregateOutputType | null
    _sum: CFTrendChartSumAggregateOutputType | null
    _min: CFTrendChartMinAggregateOutputType | null
    _max: CFTrendChartMaxAggregateOutputType | null
  }

  export type CFTrendChartAvgAggregateOutputType = {
    id: number | null
  }

  export type CFTrendChartSumAggregateOutputType = {
    id: number | null
  }

  export type CFTrendChartMinAggregateOutputType = {
    id: number | null
    month: string | null
    footprint: string | null
    scope1: string | null
    scope2: string | null
    scope3: string | null
  }

  export type CFTrendChartMaxAggregateOutputType = {
    id: number | null
    month: string | null
    footprint: string | null
    scope1: string | null
    scope2: string | null
    scope3: string | null
  }

  export type CFTrendChartCountAggregateOutputType = {
    id: number
    month: number
    footprint: number
    scope1: number
    scope2: number
    scope3: number
    _all: number
  }


  export type CFTrendChartAvgAggregateInputType = {
    id?: true
  }

  export type CFTrendChartSumAggregateInputType = {
    id?: true
  }

  export type CFTrendChartMinAggregateInputType = {
    id?: true
    month?: true
    footprint?: true
    scope1?: true
    scope2?: true
    scope3?: true
  }

  export type CFTrendChartMaxAggregateInputType = {
    id?: true
    month?: true
    footprint?: true
    scope1?: true
    scope2?: true
    scope3?: true
  }

  export type CFTrendChartCountAggregateInputType = {
    id?: true
    month?: true
    footprint?: true
    scope1?: true
    scope2?: true
    scope3?: true
    _all?: true
  }

  export type CFTrendChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CFTrendChart to aggregate.
     */
    where?: CFTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFTrendCharts to fetch.
     */
    orderBy?: CFTrendChartOrderByWithRelationInput | CFTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CFTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFTrendCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CFTrendCharts
    **/
    _count?: true | CFTrendChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CFTrendChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CFTrendChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CFTrendChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CFTrendChartMaxAggregateInputType
  }

  export type GetCFTrendChartAggregateType<T extends CFTrendChartAggregateArgs> = {
        [P in keyof T & keyof AggregateCFTrendChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCFTrendChart[P]>
      : GetScalarType<T[P], AggregateCFTrendChart[P]>
  }




  export type CFTrendChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CFTrendChartWhereInput
    orderBy?: CFTrendChartOrderByWithAggregationInput | CFTrendChartOrderByWithAggregationInput[]
    by: CFTrendChartScalarFieldEnum[] | CFTrendChartScalarFieldEnum
    having?: CFTrendChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CFTrendChartCountAggregateInputType | true
    _avg?: CFTrendChartAvgAggregateInputType
    _sum?: CFTrendChartSumAggregateInputType
    _min?: CFTrendChartMinAggregateInputType
    _max?: CFTrendChartMaxAggregateInputType
  }

  export type CFTrendChartGroupByOutputType = {
    id: number
    month: string | null
    footprint: string | null
    scope1: string | null
    scope2: string | null
    scope3: string | null
    _count: CFTrendChartCountAggregateOutputType | null
    _avg: CFTrendChartAvgAggregateOutputType | null
    _sum: CFTrendChartSumAggregateOutputType | null
    _min: CFTrendChartMinAggregateOutputType | null
    _max: CFTrendChartMaxAggregateOutputType | null
  }

  type GetCFTrendChartGroupByPayload<T extends CFTrendChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CFTrendChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CFTrendChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CFTrendChartGroupByOutputType[P]>
            : GetScalarType<T[P], CFTrendChartGroupByOutputType[P]>
        }
      >
    >


  export type CFTrendChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    footprint?: boolean
    scope1?: boolean
    scope2?: boolean
    scope3?: boolean
  }, ExtArgs["result"]["cFTrendChart"]>



  export type CFTrendChartSelectScalar = {
    id?: boolean
    month?: boolean
    footprint?: boolean
    scope1?: boolean
    scope2?: boolean
    scope3?: boolean
  }

  export type CFTrendChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "footprint" | "scope1" | "scope2" | "scope3", ExtArgs["result"]["cFTrendChart"]>

  export type $CFTrendChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CFTrendChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string | null
      footprint: string | null
      scope1: string | null
      scope2: string | null
      scope3: string | null
    }, ExtArgs["result"]["cFTrendChart"]>
    composites: {}
  }

  type CFTrendChartGetPayload<S extends boolean | null | undefined | CFTrendChartDefaultArgs> = $Result.GetResult<Prisma.$CFTrendChartPayload, S>

  type CFTrendChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CFTrendChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CFTrendChartCountAggregateInputType | true
    }

  export interface CFTrendChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CFTrendChart'], meta: { name: 'CFTrendChart' } }
    /**
     * Find zero or one CFTrendChart that matches the filter.
     * @param {CFTrendChartFindUniqueArgs} args - Arguments to find a CFTrendChart
     * @example
     * // Get one CFTrendChart
     * const cFTrendChart = await prisma.cFTrendChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CFTrendChartFindUniqueArgs>(args: SelectSubset<T, CFTrendChartFindUniqueArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CFTrendChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CFTrendChartFindUniqueOrThrowArgs} args - Arguments to find a CFTrendChart
     * @example
     * // Get one CFTrendChart
     * const cFTrendChart = await prisma.cFTrendChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CFTrendChartFindUniqueOrThrowArgs>(args: SelectSubset<T, CFTrendChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CFTrendChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartFindFirstArgs} args - Arguments to find a CFTrendChart
     * @example
     * // Get one CFTrendChart
     * const cFTrendChart = await prisma.cFTrendChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CFTrendChartFindFirstArgs>(args?: SelectSubset<T, CFTrendChartFindFirstArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CFTrendChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartFindFirstOrThrowArgs} args - Arguments to find a CFTrendChart
     * @example
     * // Get one CFTrendChart
     * const cFTrendChart = await prisma.cFTrendChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CFTrendChartFindFirstOrThrowArgs>(args?: SelectSubset<T, CFTrendChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CFTrendCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CFTrendCharts
     * const cFTrendCharts = await prisma.cFTrendChart.findMany()
     * 
     * // Get first 10 CFTrendCharts
     * const cFTrendCharts = await prisma.cFTrendChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cFTrendChartWithIdOnly = await prisma.cFTrendChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CFTrendChartFindManyArgs>(args?: SelectSubset<T, CFTrendChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CFTrendChart.
     * @param {CFTrendChartCreateArgs} args - Arguments to create a CFTrendChart.
     * @example
     * // Create one CFTrendChart
     * const CFTrendChart = await prisma.cFTrendChart.create({
     *   data: {
     *     // ... data to create a CFTrendChart
     *   }
     * })
     * 
     */
    create<T extends CFTrendChartCreateArgs>(args: SelectSubset<T, CFTrendChartCreateArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CFTrendCharts.
     * @param {CFTrendChartCreateManyArgs} args - Arguments to create many CFTrendCharts.
     * @example
     * // Create many CFTrendCharts
     * const cFTrendChart = await prisma.cFTrendChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CFTrendChartCreateManyArgs>(args?: SelectSubset<T, CFTrendChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a CFTrendChart.
     * @param {CFTrendChartDeleteArgs} args - Arguments to delete one CFTrendChart.
     * @example
     * // Delete one CFTrendChart
     * const CFTrendChart = await prisma.cFTrendChart.delete({
     *   where: {
     *     // ... filter to delete one CFTrendChart
     *   }
     * })
     * 
     */
    delete<T extends CFTrendChartDeleteArgs>(args: SelectSubset<T, CFTrendChartDeleteArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CFTrendChart.
     * @param {CFTrendChartUpdateArgs} args - Arguments to update one CFTrendChart.
     * @example
     * // Update one CFTrendChart
     * const cFTrendChart = await prisma.cFTrendChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CFTrendChartUpdateArgs>(args: SelectSubset<T, CFTrendChartUpdateArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CFTrendCharts.
     * @param {CFTrendChartDeleteManyArgs} args - Arguments to filter CFTrendCharts to delete.
     * @example
     * // Delete a few CFTrendCharts
     * const { count } = await prisma.cFTrendChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CFTrendChartDeleteManyArgs>(args?: SelectSubset<T, CFTrendChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CFTrendCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CFTrendCharts
     * const cFTrendChart = await prisma.cFTrendChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CFTrendChartUpdateManyArgs>(args: SelectSubset<T, CFTrendChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CFTrendChart.
     * @param {CFTrendChartUpsertArgs} args - Arguments to update or create a CFTrendChart.
     * @example
     * // Update or create a CFTrendChart
     * const cFTrendChart = await prisma.cFTrendChart.upsert({
     *   create: {
     *     // ... data to create a CFTrendChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CFTrendChart we want to update
     *   }
     * })
     */
    upsert<T extends CFTrendChartUpsertArgs>(args: SelectSubset<T, CFTrendChartUpsertArgs<ExtArgs>>): Prisma__CFTrendChartClient<$Result.GetResult<Prisma.$CFTrendChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CFTrendCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartCountArgs} args - Arguments to filter CFTrendCharts to count.
     * @example
     * // Count the number of CFTrendCharts
     * const count = await prisma.cFTrendChart.count({
     *   where: {
     *     // ... the filter for the CFTrendCharts we want to count
     *   }
     * })
    **/
    count<T extends CFTrendChartCountArgs>(
      args?: Subset<T, CFTrendChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CFTrendChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CFTrendChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CFTrendChartAggregateArgs>(args: Subset<T, CFTrendChartAggregateArgs>): Prisma.PrismaPromise<GetCFTrendChartAggregateType<T>>

    /**
     * Group by CFTrendChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CFTrendChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CFTrendChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CFTrendChartGroupByArgs['orderBy'] }
        : { orderBy?: CFTrendChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CFTrendChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCFTrendChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CFTrendChart model
   */
  readonly fields: CFTrendChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CFTrendChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CFTrendChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CFTrendChart model
   */
  interface CFTrendChartFieldRefs {
    readonly id: FieldRef<"CFTrendChart", 'Int'>
    readonly month: FieldRef<"CFTrendChart", 'String'>
    readonly footprint: FieldRef<"CFTrendChart", 'String'>
    readonly scope1: FieldRef<"CFTrendChart", 'String'>
    readonly scope2: FieldRef<"CFTrendChart", 'String'>
    readonly scope3: FieldRef<"CFTrendChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * CFTrendChart findUnique
   */
  export type CFTrendChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which CFTrendChart to fetch.
     */
    where: CFTrendChartWhereUniqueInput
  }

  /**
   * CFTrendChart findUniqueOrThrow
   */
  export type CFTrendChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which CFTrendChart to fetch.
     */
    where: CFTrendChartWhereUniqueInput
  }

  /**
   * CFTrendChart findFirst
   */
  export type CFTrendChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which CFTrendChart to fetch.
     */
    where?: CFTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFTrendCharts to fetch.
     */
    orderBy?: CFTrendChartOrderByWithRelationInput | CFTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CFTrendCharts.
     */
    cursor?: CFTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFTrendCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CFTrendCharts.
     */
    distinct?: CFTrendChartScalarFieldEnum | CFTrendChartScalarFieldEnum[]
  }

  /**
   * CFTrendChart findFirstOrThrow
   */
  export type CFTrendChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which CFTrendChart to fetch.
     */
    where?: CFTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFTrendCharts to fetch.
     */
    orderBy?: CFTrendChartOrderByWithRelationInput | CFTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CFTrendCharts.
     */
    cursor?: CFTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFTrendCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CFTrendCharts.
     */
    distinct?: CFTrendChartScalarFieldEnum | CFTrendChartScalarFieldEnum[]
  }

  /**
   * CFTrendChart findMany
   */
  export type CFTrendChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which CFTrendCharts to fetch.
     */
    where?: CFTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CFTrendCharts to fetch.
     */
    orderBy?: CFTrendChartOrderByWithRelationInput | CFTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CFTrendCharts.
     */
    cursor?: CFTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CFTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CFTrendCharts.
     */
    skip?: number
    distinct?: CFTrendChartScalarFieldEnum | CFTrendChartScalarFieldEnum[]
  }

  /**
   * CFTrendChart create
   */
  export type CFTrendChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * The data needed to create a CFTrendChart.
     */
    data?: XOR<CFTrendChartCreateInput, CFTrendChartUncheckedCreateInput>
  }

  /**
   * CFTrendChart createMany
   */
  export type CFTrendChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CFTrendCharts.
     */
    data: CFTrendChartCreateManyInput | CFTrendChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CFTrendChart update
   */
  export type CFTrendChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * The data needed to update a CFTrendChart.
     */
    data: XOR<CFTrendChartUpdateInput, CFTrendChartUncheckedUpdateInput>
    /**
     * Choose, which CFTrendChart to update.
     */
    where: CFTrendChartWhereUniqueInput
  }

  /**
   * CFTrendChart updateMany
   */
  export type CFTrendChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CFTrendCharts.
     */
    data: XOR<CFTrendChartUpdateManyMutationInput, CFTrendChartUncheckedUpdateManyInput>
    /**
     * Filter which CFTrendCharts to update
     */
    where?: CFTrendChartWhereInput
    /**
     * Limit how many CFTrendCharts to update.
     */
    limit?: number
  }

  /**
   * CFTrendChart upsert
   */
  export type CFTrendChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * The filter to search for the CFTrendChart to update in case it exists.
     */
    where: CFTrendChartWhereUniqueInput
    /**
     * In case the CFTrendChart found by the `where` argument doesn't exist, create a new CFTrendChart with this data.
     */
    create: XOR<CFTrendChartCreateInput, CFTrendChartUncheckedCreateInput>
    /**
     * In case the CFTrendChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CFTrendChartUpdateInput, CFTrendChartUncheckedUpdateInput>
  }

  /**
   * CFTrendChart delete
   */
  export type CFTrendChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
    /**
     * Filter which CFTrendChart to delete.
     */
    where: CFTrendChartWhereUniqueInput
  }

  /**
   * CFTrendChart deleteMany
   */
  export type CFTrendChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CFTrendCharts to delete
     */
    where?: CFTrendChartWhereInput
    /**
     * Limit how many CFTrendCharts to delete.
     */
    limit?: number
  }

  /**
   * CFTrendChart without action
   */
  export type CFTrendChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CFTrendChart
     */
    select?: CFTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CFTrendChart
     */
    omit?: CFTrendChartOmit<ExtArgs> | null
  }


  /**
   * Model EAConsumptionTrend
   */

  export type AggregateEAConsumptionTrend = {
    _count: EAConsumptionTrendCountAggregateOutputType | null
    _avg: EAConsumptionTrendAvgAggregateOutputType | null
    _sum: EAConsumptionTrendSumAggregateOutputType | null
    _min: EAConsumptionTrendMinAggregateOutputType | null
    _max: EAConsumptionTrendMaxAggregateOutputType | null
  }

  export type EAConsumptionTrendAvgAggregateOutputType = {
    id: number | null
    total: Decimal | null
    upstream: Decimal | null
    downstream: Decimal | null
    forecast: Decimal | null
  }

  export type EAConsumptionTrendSumAggregateOutputType = {
    id: number | null
    total: Decimal | null
    upstream: Decimal | null
    downstream: Decimal | null
    forecast: Decimal | null
  }

  export type EAConsumptionTrendMinAggregateOutputType = {
    id: number | null
    date: string | null
    total: Decimal | null
    upstream: Decimal | null
    downstream: Decimal | null
    forecast: Decimal | null
  }

  export type EAConsumptionTrendMaxAggregateOutputType = {
    id: number | null
    date: string | null
    total: Decimal | null
    upstream: Decimal | null
    downstream: Decimal | null
    forecast: Decimal | null
  }

  export type EAConsumptionTrendCountAggregateOutputType = {
    id: number
    date: number
    total: number
    upstream: number
    downstream: number
    forecast: number
    _all: number
  }


  export type EAConsumptionTrendAvgAggregateInputType = {
    id?: true
    total?: true
    upstream?: true
    downstream?: true
    forecast?: true
  }

  export type EAConsumptionTrendSumAggregateInputType = {
    id?: true
    total?: true
    upstream?: true
    downstream?: true
    forecast?: true
  }

  export type EAConsumptionTrendMinAggregateInputType = {
    id?: true
    date?: true
    total?: true
    upstream?: true
    downstream?: true
    forecast?: true
  }

  export type EAConsumptionTrendMaxAggregateInputType = {
    id?: true
    date?: true
    total?: true
    upstream?: true
    downstream?: true
    forecast?: true
  }

  export type EAConsumptionTrendCountAggregateInputType = {
    id?: true
    date?: true
    total?: true
    upstream?: true
    downstream?: true
    forecast?: true
    _all?: true
  }

  export type EAConsumptionTrendAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAConsumptionTrend to aggregate.
     */
    where?: EAConsumptionTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAConsumptionTrends to fetch.
     */
    orderBy?: EAConsumptionTrendOrderByWithRelationInput | EAConsumptionTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EAConsumptionTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAConsumptionTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAConsumptionTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EAConsumptionTrends
    **/
    _count?: true | EAConsumptionTrendCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EAConsumptionTrendAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EAConsumptionTrendSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EAConsumptionTrendMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EAConsumptionTrendMaxAggregateInputType
  }

  export type GetEAConsumptionTrendAggregateType<T extends EAConsumptionTrendAggregateArgs> = {
        [P in keyof T & keyof AggregateEAConsumptionTrend]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEAConsumptionTrend[P]>
      : GetScalarType<T[P], AggregateEAConsumptionTrend[P]>
  }




  export type EAConsumptionTrendGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EAConsumptionTrendWhereInput
    orderBy?: EAConsumptionTrendOrderByWithAggregationInput | EAConsumptionTrendOrderByWithAggregationInput[]
    by: EAConsumptionTrendScalarFieldEnum[] | EAConsumptionTrendScalarFieldEnum
    having?: EAConsumptionTrendScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EAConsumptionTrendCountAggregateInputType | true
    _avg?: EAConsumptionTrendAvgAggregateInputType
    _sum?: EAConsumptionTrendSumAggregateInputType
    _min?: EAConsumptionTrendMinAggregateInputType
    _max?: EAConsumptionTrendMaxAggregateInputType
  }

  export type EAConsumptionTrendGroupByOutputType = {
    id: number
    date: string | null
    total: Decimal | null
    upstream: Decimal | null
    downstream: Decimal | null
    forecast: Decimal | null
    _count: EAConsumptionTrendCountAggregateOutputType | null
    _avg: EAConsumptionTrendAvgAggregateOutputType | null
    _sum: EAConsumptionTrendSumAggregateOutputType | null
    _min: EAConsumptionTrendMinAggregateOutputType | null
    _max: EAConsumptionTrendMaxAggregateOutputType | null
  }

  type GetEAConsumptionTrendGroupByPayload<T extends EAConsumptionTrendGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EAConsumptionTrendGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EAConsumptionTrendGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EAConsumptionTrendGroupByOutputType[P]>
            : GetScalarType<T[P], EAConsumptionTrendGroupByOutputType[P]>
        }
      >
    >


  export type EAConsumptionTrendSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    date?: boolean
    total?: boolean
    upstream?: boolean
    downstream?: boolean
    forecast?: boolean
  }, ExtArgs["result"]["eAConsumptionTrend"]>



  export type EAConsumptionTrendSelectScalar = {
    id?: boolean
    date?: boolean
    total?: boolean
    upstream?: boolean
    downstream?: boolean
    forecast?: boolean
  }

  export type EAConsumptionTrendOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "date" | "total" | "upstream" | "downstream" | "forecast", ExtArgs["result"]["eAConsumptionTrend"]>

  export type $EAConsumptionTrendPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EAConsumptionTrend"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      date: string | null
      total: Prisma.Decimal | null
      upstream: Prisma.Decimal | null
      downstream: Prisma.Decimal | null
      forecast: Prisma.Decimal | null
    }, ExtArgs["result"]["eAConsumptionTrend"]>
    composites: {}
  }

  type EAConsumptionTrendGetPayload<S extends boolean | null | undefined | EAConsumptionTrendDefaultArgs> = $Result.GetResult<Prisma.$EAConsumptionTrendPayload, S>

  type EAConsumptionTrendCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EAConsumptionTrendFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EAConsumptionTrendCountAggregateInputType | true
    }

  export interface EAConsumptionTrendDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EAConsumptionTrend'], meta: { name: 'EAConsumptionTrend' } }
    /**
     * Find zero or one EAConsumptionTrend that matches the filter.
     * @param {EAConsumptionTrendFindUniqueArgs} args - Arguments to find a EAConsumptionTrend
     * @example
     * // Get one EAConsumptionTrend
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EAConsumptionTrendFindUniqueArgs>(args: SelectSubset<T, EAConsumptionTrendFindUniqueArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EAConsumptionTrend that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EAConsumptionTrendFindUniqueOrThrowArgs} args - Arguments to find a EAConsumptionTrend
     * @example
     * // Get one EAConsumptionTrend
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EAConsumptionTrendFindUniqueOrThrowArgs>(args: SelectSubset<T, EAConsumptionTrendFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EAConsumptionTrend that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendFindFirstArgs} args - Arguments to find a EAConsumptionTrend
     * @example
     * // Get one EAConsumptionTrend
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EAConsumptionTrendFindFirstArgs>(args?: SelectSubset<T, EAConsumptionTrendFindFirstArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EAConsumptionTrend that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendFindFirstOrThrowArgs} args - Arguments to find a EAConsumptionTrend
     * @example
     * // Get one EAConsumptionTrend
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EAConsumptionTrendFindFirstOrThrowArgs>(args?: SelectSubset<T, EAConsumptionTrendFindFirstOrThrowArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EAConsumptionTrends that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EAConsumptionTrends
     * const eAConsumptionTrends = await prisma.eAConsumptionTrend.findMany()
     * 
     * // Get first 10 EAConsumptionTrends
     * const eAConsumptionTrends = await prisma.eAConsumptionTrend.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eAConsumptionTrendWithIdOnly = await prisma.eAConsumptionTrend.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EAConsumptionTrendFindManyArgs>(args?: SelectSubset<T, EAConsumptionTrendFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EAConsumptionTrend.
     * @param {EAConsumptionTrendCreateArgs} args - Arguments to create a EAConsumptionTrend.
     * @example
     * // Create one EAConsumptionTrend
     * const EAConsumptionTrend = await prisma.eAConsumptionTrend.create({
     *   data: {
     *     // ... data to create a EAConsumptionTrend
     *   }
     * })
     * 
     */
    create<T extends EAConsumptionTrendCreateArgs>(args: SelectSubset<T, EAConsumptionTrendCreateArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EAConsumptionTrends.
     * @param {EAConsumptionTrendCreateManyArgs} args - Arguments to create many EAConsumptionTrends.
     * @example
     * // Create many EAConsumptionTrends
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EAConsumptionTrendCreateManyArgs>(args?: SelectSubset<T, EAConsumptionTrendCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EAConsumptionTrend.
     * @param {EAConsumptionTrendDeleteArgs} args - Arguments to delete one EAConsumptionTrend.
     * @example
     * // Delete one EAConsumptionTrend
     * const EAConsumptionTrend = await prisma.eAConsumptionTrend.delete({
     *   where: {
     *     // ... filter to delete one EAConsumptionTrend
     *   }
     * })
     * 
     */
    delete<T extends EAConsumptionTrendDeleteArgs>(args: SelectSubset<T, EAConsumptionTrendDeleteArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EAConsumptionTrend.
     * @param {EAConsumptionTrendUpdateArgs} args - Arguments to update one EAConsumptionTrend.
     * @example
     * // Update one EAConsumptionTrend
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EAConsumptionTrendUpdateArgs>(args: SelectSubset<T, EAConsumptionTrendUpdateArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EAConsumptionTrends.
     * @param {EAConsumptionTrendDeleteManyArgs} args - Arguments to filter EAConsumptionTrends to delete.
     * @example
     * // Delete a few EAConsumptionTrends
     * const { count } = await prisma.eAConsumptionTrend.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EAConsumptionTrendDeleteManyArgs>(args?: SelectSubset<T, EAConsumptionTrendDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EAConsumptionTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EAConsumptionTrends
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EAConsumptionTrendUpdateManyArgs>(args: SelectSubset<T, EAConsumptionTrendUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EAConsumptionTrend.
     * @param {EAConsumptionTrendUpsertArgs} args - Arguments to update or create a EAConsumptionTrend.
     * @example
     * // Update or create a EAConsumptionTrend
     * const eAConsumptionTrend = await prisma.eAConsumptionTrend.upsert({
     *   create: {
     *     // ... data to create a EAConsumptionTrend
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EAConsumptionTrend we want to update
     *   }
     * })
     */
    upsert<T extends EAConsumptionTrendUpsertArgs>(args: SelectSubset<T, EAConsumptionTrendUpsertArgs<ExtArgs>>): Prisma__EAConsumptionTrendClient<$Result.GetResult<Prisma.$EAConsumptionTrendPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EAConsumptionTrends.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendCountArgs} args - Arguments to filter EAConsumptionTrends to count.
     * @example
     * // Count the number of EAConsumptionTrends
     * const count = await prisma.eAConsumptionTrend.count({
     *   where: {
     *     // ... the filter for the EAConsumptionTrends we want to count
     *   }
     * })
    **/
    count<T extends EAConsumptionTrendCountArgs>(
      args?: Subset<T, EAConsumptionTrendCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EAConsumptionTrendCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EAConsumptionTrend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAConsumptionTrendAggregateArgs>(args: Subset<T, EAConsumptionTrendAggregateArgs>): Prisma.PrismaPromise<GetEAConsumptionTrendAggregateType<T>>

    /**
     * Group by EAConsumptionTrend.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAConsumptionTrendGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EAConsumptionTrendGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EAConsumptionTrendGroupByArgs['orderBy'] }
        : { orderBy?: EAConsumptionTrendGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EAConsumptionTrendGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEAConsumptionTrendGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EAConsumptionTrend model
   */
  readonly fields: EAConsumptionTrendFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EAConsumptionTrend.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EAConsumptionTrendClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EAConsumptionTrend model
   */
  interface EAConsumptionTrendFieldRefs {
    readonly id: FieldRef<"EAConsumptionTrend", 'Int'>
    readonly date: FieldRef<"EAConsumptionTrend", 'String'>
    readonly total: FieldRef<"EAConsumptionTrend", 'Decimal'>
    readonly upstream: FieldRef<"EAConsumptionTrend", 'Decimal'>
    readonly downstream: FieldRef<"EAConsumptionTrend", 'Decimal'>
    readonly forecast: FieldRef<"EAConsumptionTrend", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * EAConsumptionTrend findUnique
   */
  export type EAConsumptionTrendFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * Filter, which EAConsumptionTrend to fetch.
     */
    where: EAConsumptionTrendWhereUniqueInput
  }

  /**
   * EAConsumptionTrend findUniqueOrThrow
   */
  export type EAConsumptionTrendFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * Filter, which EAConsumptionTrend to fetch.
     */
    where: EAConsumptionTrendWhereUniqueInput
  }

  /**
   * EAConsumptionTrend findFirst
   */
  export type EAConsumptionTrendFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * Filter, which EAConsumptionTrend to fetch.
     */
    where?: EAConsumptionTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAConsumptionTrends to fetch.
     */
    orderBy?: EAConsumptionTrendOrderByWithRelationInput | EAConsumptionTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAConsumptionTrends.
     */
    cursor?: EAConsumptionTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAConsumptionTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAConsumptionTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAConsumptionTrends.
     */
    distinct?: EAConsumptionTrendScalarFieldEnum | EAConsumptionTrendScalarFieldEnum[]
  }

  /**
   * EAConsumptionTrend findFirstOrThrow
   */
  export type EAConsumptionTrendFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * Filter, which EAConsumptionTrend to fetch.
     */
    where?: EAConsumptionTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAConsumptionTrends to fetch.
     */
    orderBy?: EAConsumptionTrendOrderByWithRelationInput | EAConsumptionTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAConsumptionTrends.
     */
    cursor?: EAConsumptionTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAConsumptionTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAConsumptionTrends.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAConsumptionTrends.
     */
    distinct?: EAConsumptionTrendScalarFieldEnum | EAConsumptionTrendScalarFieldEnum[]
  }

  /**
   * EAConsumptionTrend findMany
   */
  export type EAConsumptionTrendFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * Filter, which EAConsumptionTrends to fetch.
     */
    where?: EAConsumptionTrendWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAConsumptionTrends to fetch.
     */
    orderBy?: EAConsumptionTrendOrderByWithRelationInput | EAConsumptionTrendOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EAConsumptionTrends.
     */
    cursor?: EAConsumptionTrendWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAConsumptionTrends from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAConsumptionTrends.
     */
    skip?: number
    distinct?: EAConsumptionTrendScalarFieldEnum | EAConsumptionTrendScalarFieldEnum[]
  }

  /**
   * EAConsumptionTrend create
   */
  export type EAConsumptionTrendCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * The data needed to create a EAConsumptionTrend.
     */
    data?: XOR<EAConsumptionTrendCreateInput, EAConsumptionTrendUncheckedCreateInput>
  }

  /**
   * EAConsumptionTrend createMany
   */
  export type EAConsumptionTrendCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EAConsumptionTrends.
     */
    data: EAConsumptionTrendCreateManyInput | EAConsumptionTrendCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EAConsumptionTrend update
   */
  export type EAConsumptionTrendUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * The data needed to update a EAConsumptionTrend.
     */
    data: XOR<EAConsumptionTrendUpdateInput, EAConsumptionTrendUncheckedUpdateInput>
    /**
     * Choose, which EAConsumptionTrend to update.
     */
    where: EAConsumptionTrendWhereUniqueInput
  }

  /**
   * EAConsumptionTrend updateMany
   */
  export type EAConsumptionTrendUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EAConsumptionTrends.
     */
    data: XOR<EAConsumptionTrendUpdateManyMutationInput, EAConsumptionTrendUncheckedUpdateManyInput>
    /**
     * Filter which EAConsumptionTrends to update
     */
    where?: EAConsumptionTrendWhereInput
    /**
     * Limit how many EAConsumptionTrends to update.
     */
    limit?: number
  }

  /**
   * EAConsumptionTrend upsert
   */
  export type EAConsumptionTrendUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * The filter to search for the EAConsumptionTrend to update in case it exists.
     */
    where: EAConsumptionTrendWhereUniqueInput
    /**
     * In case the EAConsumptionTrend found by the `where` argument doesn't exist, create a new EAConsumptionTrend with this data.
     */
    create: XOR<EAConsumptionTrendCreateInput, EAConsumptionTrendUncheckedCreateInput>
    /**
     * In case the EAConsumptionTrend was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EAConsumptionTrendUpdateInput, EAConsumptionTrendUncheckedUpdateInput>
  }

  /**
   * EAConsumptionTrend delete
   */
  export type EAConsumptionTrendDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
    /**
     * Filter which EAConsumptionTrend to delete.
     */
    where: EAConsumptionTrendWhereUniqueInput
  }

  /**
   * EAConsumptionTrend deleteMany
   */
  export type EAConsumptionTrendDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAConsumptionTrends to delete
     */
    where?: EAConsumptionTrendWhereInput
    /**
     * Limit how many EAConsumptionTrends to delete.
     */
    limit?: number
  }

  /**
   * EAConsumptionTrend without action
   */
  export type EAConsumptionTrendDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAConsumptionTrend
     */
    select?: EAConsumptionTrendSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAConsumptionTrend
     */
    omit?: EAConsumptionTrendOmit<ExtArgs> | null
  }


  /**
   * Model EAMonthSummary
   */

  export type AggregateEAMonthSummary = {
    _count: EAMonthSummaryCountAggregateOutputType | null
    _avg: EAMonthSummaryAvgAggregateOutputType | null
    _sum: EAMonthSummarySumAggregateOutputType | null
    _min: EAMonthSummaryMinAggregateOutputType | null
    _max: EAMonthSummaryMaxAggregateOutputType | null
  }

  export type EAMonthSummaryAvgAggregateOutputType = {
    id: number | null
    total: Decimal | null
    upstream: Decimal | null
    growth_rate: Decimal | null
    forecast_growth: Decimal | null
  }

  export type EAMonthSummarySumAggregateOutputType = {
    id: number | null
    total: Decimal | null
    upstream: Decimal | null
    growth_rate: Decimal | null
    forecast_growth: Decimal | null
  }

  export type EAMonthSummaryMinAggregateOutputType = {
    id: number | null
    month: string | null
    total: Decimal | null
    upstream: Decimal | null
    growth_rate: Decimal | null
    forecast_growth: Decimal | null
  }

  export type EAMonthSummaryMaxAggregateOutputType = {
    id: number | null
    month: string | null
    total: Decimal | null
    upstream: Decimal | null
    growth_rate: Decimal | null
    forecast_growth: Decimal | null
  }

  export type EAMonthSummaryCountAggregateOutputType = {
    id: number
    month: number
    total: number
    upstream: number
    growth_rate: number
    forecast_growth: number
    _all: number
  }


  export type EAMonthSummaryAvgAggregateInputType = {
    id?: true
    total?: true
    upstream?: true
    growth_rate?: true
    forecast_growth?: true
  }

  export type EAMonthSummarySumAggregateInputType = {
    id?: true
    total?: true
    upstream?: true
    growth_rate?: true
    forecast_growth?: true
  }

  export type EAMonthSummaryMinAggregateInputType = {
    id?: true
    month?: true
    total?: true
    upstream?: true
    growth_rate?: true
    forecast_growth?: true
  }

  export type EAMonthSummaryMaxAggregateInputType = {
    id?: true
    month?: true
    total?: true
    upstream?: true
    growth_rate?: true
    forecast_growth?: true
  }

  export type EAMonthSummaryCountAggregateInputType = {
    id?: true
    month?: true
    total?: true
    upstream?: true
    growth_rate?: true
    forecast_growth?: true
    _all?: true
  }

  export type EAMonthSummaryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAMonthSummary to aggregate.
     */
    where?: EAMonthSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAMonthSummaries to fetch.
     */
    orderBy?: EAMonthSummaryOrderByWithRelationInput | EAMonthSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EAMonthSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAMonthSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAMonthSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EAMonthSummaries
    **/
    _count?: true | EAMonthSummaryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EAMonthSummaryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EAMonthSummarySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EAMonthSummaryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EAMonthSummaryMaxAggregateInputType
  }

  export type GetEAMonthSummaryAggregateType<T extends EAMonthSummaryAggregateArgs> = {
        [P in keyof T & keyof AggregateEAMonthSummary]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEAMonthSummary[P]>
      : GetScalarType<T[P], AggregateEAMonthSummary[P]>
  }




  export type EAMonthSummaryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EAMonthSummaryWhereInput
    orderBy?: EAMonthSummaryOrderByWithAggregationInput | EAMonthSummaryOrderByWithAggregationInput[]
    by: EAMonthSummaryScalarFieldEnum[] | EAMonthSummaryScalarFieldEnum
    having?: EAMonthSummaryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EAMonthSummaryCountAggregateInputType | true
    _avg?: EAMonthSummaryAvgAggregateInputType
    _sum?: EAMonthSummarySumAggregateInputType
    _min?: EAMonthSummaryMinAggregateInputType
    _max?: EAMonthSummaryMaxAggregateInputType
  }

  export type EAMonthSummaryGroupByOutputType = {
    id: number
    month: string | null
    total: Decimal | null
    upstream: Decimal | null
    growth_rate: Decimal | null
    forecast_growth: Decimal | null
    _count: EAMonthSummaryCountAggregateOutputType | null
    _avg: EAMonthSummaryAvgAggregateOutputType | null
    _sum: EAMonthSummarySumAggregateOutputType | null
    _min: EAMonthSummaryMinAggregateOutputType | null
    _max: EAMonthSummaryMaxAggregateOutputType | null
  }

  type GetEAMonthSummaryGroupByPayload<T extends EAMonthSummaryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EAMonthSummaryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EAMonthSummaryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EAMonthSummaryGroupByOutputType[P]>
            : GetScalarType<T[P], EAMonthSummaryGroupByOutputType[P]>
        }
      >
    >


  export type EAMonthSummarySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    total?: boolean
    upstream?: boolean
    growth_rate?: boolean
    forecast_growth?: boolean
  }, ExtArgs["result"]["eAMonthSummary"]>



  export type EAMonthSummarySelectScalar = {
    id?: boolean
    month?: boolean
    total?: boolean
    upstream?: boolean
    growth_rate?: boolean
    forecast_growth?: boolean
  }

  export type EAMonthSummaryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "total" | "upstream" | "growth_rate" | "forecast_growth", ExtArgs["result"]["eAMonthSummary"]>

  export type $EAMonthSummaryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EAMonthSummary"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string | null
      total: Prisma.Decimal | null
      upstream: Prisma.Decimal | null
      growth_rate: Prisma.Decimal | null
      forecast_growth: Prisma.Decimal | null
    }, ExtArgs["result"]["eAMonthSummary"]>
    composites: {}
  }

  type EAMonthSummaryGetPayload<S extends boolean | null | undefined | EAMonthSummaryDefaultArgs> = $Result.GetResult<Prisma.$EAMonthSummaryPayload, S>

  type EAMonthSummaryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EAMonthSummaryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EAMonthSummaryCountAggregateInputType | true
    }

  export interface EAMonthSummaryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EAMonthSummary'], meta: { name: 'EAMonthSummary' } }
    /**
     * Find zero or one EAMonthSummary that matches the filter.
     * @param {EAMonthSummaryFindUniqueArgs} args - Arguments to find a EAMonthSummary
     * @example
     * // Get one EAMonthSummary
     * const eAMonthSummary = await prisma.eAMonthSummary.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EAMonthSummaryFindUniqueArgs>(args: SelectSubset<T, EAMonthSummaryFindUniqueArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EAMonthSummary that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EAMonthSummaryFindUniqueOrThrowArgs} args - Arguments to find a EAMonthSummary
     * @example
     * // Get one EAMonthSummary
     * const eAMonthSummary = await prisma.eAMonthSummary.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EAMonthSummaryFindUniqueOrThrowArgs>(args: SelectSubset<T, EAMonthSummaryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EAMonthSummary that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryFindFirstArgs} args - Arguments to find a EAMonthSummary
     * @example
     * // Get one EAMonthSummary
     * const eAMonthSummary = await prisma.eAMonthSummary.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EAMonthSummaryFindFirstArgs>(args?: SelectSubset<T, EAMonthSummaryFindFirstArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EAMonthSummary that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryFindFirstOrThrowArgs} args - Arguments to find a EAMonthSummary
     * @example
     * // Get one EAMonthSummary
     * const eAMonthSummary = await prisma.eAMonthSummary.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EAMonthSummaryFindFirstOrThrowArgs>(args?: SelectSubset<T, EAMonthSummaryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EAMonthSummaries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EAMonthSummaries
     * const eAMonthSummaries = await prisma.eAMonthSummary.findMany()
     * 
     * // Get first 10 EAMonthSummaries
     * const eAMonthSummaries = await prisma.eAMonthSummary.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eAMonthSummaryWithIdOnly = await prisma.eAMonthSummary.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EAMonthSummaryFindManyArgs>(args?: SelectSubset<T, EAMonthSummaryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EAMonthSummary.
     * @param {EAMonthSummaryCreateArgs} args - Arguments to create a EAMonthSummary.
     * @example
     * // Create one EAMonthSummary
     * const EAMonthSummary = await prisma.eAMonthSummary.create({
     *   data: {
     *     // ... data to create a EAMonthSummary
     *   }
     * })
     * 
     */
    create<T extends EAMonthSummaryCreateArgs>(args: SelectSubset<T, EAMonthSummaryCreateArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EAMonthSummaries.
     * @param {EAMonthSummaryCreateManyArgs} args - Arguments to create many EAMonthSummaries.
     * @example
     * // Create many EAMonthSummaries
     * const eAMonthSummary = await prisma.eAMonthSummary.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EAMonthSummaryCreateManyArgs>(args?: SelectSubset<T, EAMonthSummaryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EAMonthSummary.
     * @param {EAMonthSummaryDeleteArgs} args - Arguments to delete one EAMonthSummary.
     * @example
     * // Delete one EAMonthSummary
     * const EAMonthSummary = await prisma.eAMonthSummary.delete({
     *   where: {
     *     // ... filter to delete one EAMonthSummary
     *   }
     * })
     * 
     */
    delete<T extends EAMonthSummaryDeleteArgs>(args: SelectSubset<T, EAMonthSummaryDeleteArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EAMonthSummary.
     * @param {EAMonthSummaryUpdateArgs} args - Arguments to update one EAMonthSummary.
     * @example
     * // Update one EAMonthSummary
     * const eAMonthSummary = await prisma.eAMonthSummary.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EAMonthSummaryUpdateArgs>(args: SelectSubset<T, EAMonthSummaryUpdateArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EAMonthSummaries.
     * @param {EAMonthSummaryDeleteManyArgs} args - Arguments to filter EAMonthSummaries to delete.
     * @example
     * // Delete a few EAMonthSummaries
     * const { count } = await prisma.eAMonthSummary.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EAMonthSummaryDeleteManyArgs>(args?: SelectSubset<T, EAMonthSummaryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EAMonthSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EAMonthSummaries
     * const eAMonthSummary = await prisma.eAMonthSummary.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EAMonthSummaryUpdateManyArgs>(args: SelectSubset<T, EAMonthSummaryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EAMonthSummary.
     * @param {EAMonthSummaryUpsertArgs} args - Arguments to update or create a EAMonthSummary.
     * @example
     * // Update or create a EAMonthSummary
     * const eAMonthSummary = await prisma.eAMonthSummary.upsert({
     *   create: {
     *     // ... data to create a EAMonthSummary
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EAMonthSummary we want to update
     *   }
     * })
     */
    upsert<T extends EAMonthSummaryUpsertArgs>(args: SelectSubset<T, EAMonthSummaryUpsertArgs<ExtArgs>>): Prisma__EAMonthSummaryClient<$Result.GetResult<Prisma.$EAMonthSummaryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EAMonthSummaries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryCountArgs} args - Arguments to filter EAMonthSummaries to count.
     * @example
     * // Count the number of EAMonthSummaries
     * const count = await prisma.eAMonthSummary.count({
     *   where: {
     *     // ... the filter for the EAMonthSummaries we want to count
     *   }
     * })
    **/
    count<T extends EAMonthSummaryCountArgs>(
      args?: Subset<T, EAMonthSummaryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EAMonthSummaryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EAMonthSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAMonthSummaryAggregateArgs>(args: Subset<T, EAMonthSummaryAggregateArgs>): Prisma.PrismaPromise<GetEAMonthSummaryAggregateType<T>>

    /**
     * Group by EAMonthSummary.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAMonthSummaryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EAMonthSummaryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EAMonthSummaryGroupByArgs['orderBy'] }
        : { orderBy?: EAMonthSummaryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EAMonthSummaryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEAMonthSummaryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EAMonthSummary model
   */
  readonly fields: EAMonthSummaryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EAMonthSummary.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EAMonthSummaryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EAMonthSummary model
   */
  interface EAMonthSummaryFieldRefs {
    readonly id: FieldRef<"EAMonthSummary", 'Int'>
    readonly month: FieldRef<"EAMonthSummary", 'String'>
    readonly total: FieldRef<"EAMonthSummary", 'Decimal'>
    readonly upstream: FieldRef<"EAMonthSummary", 'Decimal'>
    readonly growth_rate: FieldRef<"EAMonthSummary", 'Decimal'>
    readonly forecast_growth: FieldRef<"EAMonthSummary", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * EAMonthSummary findUnique
   */
  export type EAMonthSummaryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * Filter, which EAMonthSummary to fetch.
     */
    where: EAMonthSummaryWhereUniqueInput
  }

  /**
   * EAMonthSummary findUniqueOrThrow
   */
  export type EAMonthSummaryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * Filter, which EAMonthSummary to fetch.
     */
    where: EAMonthSummaryWhereUniqueInput
  }

  /**
   * EAMonthSummary findFirst
   */
  export type EAMonthSummaryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * Filter, which EAMonthSummary to fetch.
     */
    where?: EAMonthSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAMonthSummaries to fetch.
     */
    orderBy?: EAMonthSummaryOrderByWithRelationInput | EAMonthSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAMonthSummaries.
     */
    cursor?: EAMonthSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAMonthSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAMonthSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAMonthSummaries.
     */
    distinct?: EAMonthSummaryScalarFieldEnum | EAMonthSummaryScalarFieldEnum[]
  }

  /**
   * EAMonthSummary findFirstOrThrow
   */
  export type EAMonthSummaryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * Filter, which EAMonthSummary to fetch.
     */
    where?: EAMonthSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAMonthSummaries to fetch.
     */
    orderBy?: EAMonthSummaryOrderByWithRelationInput | EAMonthSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAMonthSummaries.
     */
    cursor?: EAMonthSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAMonthSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAMonthSummaries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAMonthSummaries.
     */
    distinct?: EAMonthSummaryScalarFieldEnum | EAMonthSummaryScalarFieldEnum[]
  }

  /**
   * EAMonthSummary findMany
   */
  export type EAMonthSummaryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * Filter, which EAMonthSummaries to fetch.
     */
    where?: EAMonthSummaryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAMonthSummaries to fetch.
     */
    orderBy?: EAMonthSummaryOrderByWithRelationInput | EAMonthSummaryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EAMonthSummaries.
     */
    cursor?: EAMonthSummaryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAMonthSummaries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAMonthSummaries.
     */
    skip?: number
    distinct?: EAMonthSummaryScalarFieldEnum | EAMonthSummaryScalarFieldEnum[]
  }

  /**
   * EAMonthSummary create
   */
  export type EAMonthSummaryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * The data needed to create a EAMonthSummary.
     */
    data?: XOR<EAMonthSummaryCreateInput, EAMonthSummaryUncheckedCreateInput>
  }

  /**
   * EAMonthSummary createMany
   */
  export type EAMonthSummaryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EAMonthSummaries.
     */
    data: EAMonthSummaryCreateManyInput | EAMonthSummaryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EAMonthSummary update
   */
  export type EAMonthSummaryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * The data needed to update a EAMonthSummary.
     */
    data: XOR<EAMonthSummaryUpdateInput, EAMonthSummaryUncheckedUpdateInput>
    /**
     * Choose, which EAMonthSummary to update.
     */
    where: EAMonthSummaryWhereUniqueInput
  }

  /**
   * EAMonthSummary updateMany
   */
  export type EAMonthSummaryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EAMonthSummaries.
     */
    data: XOR<EAMonthSummaryUpdateManyMutationInput, EAMonthSummaryUncheckedUpdateManyInput>
    /**
     * Filter which EAMonthSummaries to update
     */
    where?: EAMonthSummaryWhereInput
    /**
     * Limit how many EAMonthSummaries to update.
     */
    limit?: number
  }

  /**
   * EAMonthSummary upsert
   */
  export type EAMonthSummaryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * The filter to search for the EAMonthSummary to update in case it exists.
     */
    where: EAMonthSummaryWhereUniqueInput
    /**
     * In case the EAMonthSummary found by the `where` argument doesn't exist, create a new EAMonthSummary with this data.
     */
    create: XOR<EAMonthSummaryCreateInput, EAMonthSummaryUncheckedCreateInput>
    /**
     * In case the EAMonthSummary was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EAMonthSummaryUpdateInput, EAMonthSummaryUncheckedUpdateInput>
  }

  /**
   * EAMonthSummary delete
   */
  export type EAMonthSummaryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
    /**
     * Filter which EAMonthSummary to delete.
     */
    where: EAMonthSummaryWhereUniqueInput
  }

  /**
   * EAMonthSummary deleteMany
   */
  export type EAMonthSummaryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAMonthSummaries to delete
     */
    where?: EAMonthSummaryWhereInput
    /**
     * Limit how many EAMonthSummaries to delete.
     */
    limit?: number
  }

  /**
   * EAMonthSummary without action
   */
  export type EAMonthSummaryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAMonthSummary
     */
    select?: EAMonthSummarySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAMonthSummary
     */
    omit?: EAMonthSummaryOmit<ExtArgs> | null
  }


  /**
   * Model EAStrategy
   */

  export type AggregateEAStrategy = {
    _count: EAStrategyCountAggregateOutputType | null
    _avg: EAStrategyAvgAggregateOutputType | null
    _sum: EAStrategySumAggregateOutputType | null
    _min: EAStrategyMinAggregateOutputType | null
    _max: EAStrategyMaxAggregateOutputType | null
  }

  export type EAStrategyAvgAggregateOutputType = {
    id: number | null
  }

  export type EAStrategySumAggregateOutputType = {
    id: number | null
  }

  export type EAStrategyMinAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    action: string | null
  }

  export type EAStrategyMaxAggregateOutputType = {
    id: number | null
    title: string | null
    description: string | null
    action: string | null
  }

  export type EAStrategyCountAggregateOutputType = {
    id: number
    title: number
    description: number
    impact: number
    action: number
    _all: number
  }


  export type EAStrategyAvgAggregateInputType = {
    id?: true
  }

  export type EAStrategySumAggregateInputType = {
    id?: true
  }

  export type EAStrategyMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    action?: true
  }

  export type EAStrategyMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    action?: true
  }

  export type EAStrategyCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    impact?: true
    action?: true
    _all?: true
  }

  export type EAStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAStrategy to aggregate.
     */
    where?: EAStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAStrategies to fetch.
     */
    orderBy?: EAStrategyOrderByWithRelationInput | EAStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EAStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EAStrategies
    **/
    _count?: true | EAStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EAStrategyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EAStrategySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EAStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EAStrategyMaxAggregateInputType
  }

  export type GetEAStrategyAggregateType<T extends EAStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateEAStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEAStrategy[P]>
      : GetScalarType<T[P], AggregateEAStrategy[P]>
  }




  export type EAStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EAStrategyWhereInput
    orderBy?: EAStrategyOrderByWithAggregationInput | EAStrategyOrderByWithAggregationInput[]
    by: EAStrategyScalarFieldEnum[] | EAStrategyScalarFieldEnum
    having?: EAStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EAStrategyCountAggregateInputType | true
    _avg?: EAStrategyAvgAggregateInputType
    _sum?: EAStrategySumAggregateInputType
    _min?: EAStrategyMinAggregateInputType
    _max?: EAStrategyMaxAggregateInputType
  }

  export type EAStrategyGroupByOutputType = {
    id: number
    title: string | null
    description: string | null
    impact: JsonValue | null
    action: string | null
    _count: EAStrategyCountAggregateOutputType | null
    _avg: EAStrategyAvgAggregateOutputType | null
    _sum: EAStrategySumAggregateOutputType | null
    _min: EAStrategyMinAggregateOutputType | null
    _max: EAStrategyMaxAggregateOutputType | null
  }

  type GetEAStrategyGroupByPayload<T extends EAStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EAStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EAStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EAStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], EAStrategyGroupByOutputType[P]>
        }
      >
    >


  export type EAStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    impact?: boolean
    action?: boolean
  }, ExtArgs["result"]["eAStrategy"]>



  export type EAStrategySelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    impact?: boolean
    action?: boolean
  }

  export type EAStrategyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "impact" | "action", ExtArgs["result"]["eAStrategy"]>

  export type $EAStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EAStrategy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string | null
      description: string | null
      impact: Prisma.JsonValue | null
      action: string | null
    }, ExtArgs["result"]["eAStrategy"]>
    composites: {}
  }

  type EAStrategyGetPayload<S extends boolean | null | undefined | EAStrategyDefaultArgs> = $Result.GetResult<Prisma.$EAStrategyPayload, S>

  type EAStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EAStrategyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EAStrategyCountAggregateInputType | true
    }

  export interface EAStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EAStrategy'], meta: { name: 'EAStrategy' } }
    /**
     * Find zero or one EAStrategy that matches the filter.
     * @param {EAStrategyFindUniqueArgs} args - Arguments to find a EAStrategy
     * @example
     * // Get one EAStrategy
     * const eAStrategy = await prisma.eAStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EAStrategyFindUniqueArgs>(args: SelectSubset<T, EAStrategyFindUniqueArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EAStrategy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EAStrategyFindUniqueOrThrowArgs} args - Arguments to find a EAStrategy
     * @example
     * // Get one EAStrategy
     * const eAStrategy = await prisma.eAStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EAStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, EAStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EAStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyFindFirstArgs} args - Arguments to find a EAStrategy
     * @example
     * // Get one EAStrategy
     * const eAStrategy = await prisma.eAStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EAStrategyFindFirstArgs>(args?: SelectSubset<T, EAStrategyFindFirstArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EAStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyFindFirstOrThrowArgs} args - Arguments to find a EAStrategy
     * @example
     * // Get one EAStrategy
     * const eAStrategy = await prisma.eAStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EAStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, EAStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EAStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EAStrategies
     * const eAStrategies = await prisma.eAStrategy.findMany()
     * 
     * // Get first 10 EAStrategies
     * const eAStrategies = await prisma.eAStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eAStrategyWithIdOnly = await prisma.eAStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EAStrategyFindManyArgs>(args?: SelectSubset<T, EAStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EAStrategy.
     * @param {EAStrategyCreateArgs} args - Arguments to create a EAStrategy.
     * @example
     * // Create one EAStrategy
     * const EAStrategy = await prisma.eAStrategy.create({
     *   data: {
     *     // ... data to create a EAStrategy
     *   }
     * })
     * 
     */
    create<T extends EAStrategyCreateArgs>(args: SelectSubset<T, EAStrategyCreateArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EAStrategies.
     * @param {EAStrategyCreateManyArgs} args - Arguments to create many EAStrategies.
     * @example
     * // Create many EAStrategies
     * const eAStrategy = await prisma.eAStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EAStrategyCreateManyArgs>(args?: SelectSubset<T, EAStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EAStrategy.
     * @param {EAStrategyDeleteArgs} args - Arguments to delete one EAStrategy.
     * @example
     * // Delete one EAStrategy
     * const EAStrategy = await prisma.eAStrategy.delete({
     *   where: {
     *     // ... filter to delete one EAStrategy
     *   }
     * })
     * 
     */
    delete<T extends EAStrategyDeleteArgs>(args: SelectSubset<T, EAStrategyDeleteArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EAStrategy.
     * @param {EAStrategyUpdateArgs} args - Arguments to update one EAStrategy.
     * @example
     * // Update one EAStrategy
     * const eAStrategy = await prisma.eAStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EAStrategyUpdateArgs>(args: SelectSubset<T, EAStrategyUpdateArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EAStrategies.
     * @param {EAStrategyDeleteManyArgs} args - Arguments to filter EAStrategies to delete.
     * @example
     * // Delete a few EAStrategies
     * const { count } = await prisma.eAStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EAStrategyDeleteManyArgs>(args?: SelectSubset<T, EAStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EAStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EAStrategies
     * const eAStrategy = await prisma.eAStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EAStrategyUpdateManyArgs>(args: SelectSubset<T, EAStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EAStrategy.
     * @param {EAStrategyUpsertArgs} args - Arguments to update or create a EAStrategy.
     * @example
     * // Update or create a EAStrategy
     * const eAStrategy = await prisma.eAStrategy.upsert({
     *   create: {
     *     // ... data to create a EAStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EAStrategy we want to update
     *   }
     * })
     */
    upsert<T extends EAStrategyUpsertArgs>(args: SelectSubset<T, EAStrategyUpsertArgs<ExtArgs>>): Prisma__EAStrategyClient<$Result.GetResult<Prisma.$EAStrategyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EAStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyCountArgs} args - Arguments to filter EAStrategies to count.
     * @example
     * // Count the number of EAStrategies
     * const count = await prisma.eAStrategy.count({
     *   where: {
     *     // ... the filter for the EAStrategies we want to count
     *   }
     * })
    **/
    count<T extends EAStrategyCountArgs>(
      args?: Subset<T, EAStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EAStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EAStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EAStrategyAggregateArgs>(args: Subset<T, EAStrategyAggregateArgs>): Prisma.PrismaPromise<GetEAStrategyAggregateType<T>>

    /**
     * Group by EAStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EAStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EAStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EAStrategyGroupByArgs['orderBy'] }
        : { orderBy?: EAStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EAStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEAStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EAStrategy model
   */
  readonly fields: EAStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EAStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EAStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EAStrategy model
   */
  interface EAStrategyFieldRefs {
    readonly id: FieldRef<"EAStrategy", 'Int'>
    readonly title: FieldRef<"EAStrategy", 'String'>
    readonly description: FieldRef<"EAStrategy", 'String'>
    readonly impact: FieldRef<"EAStrategy", 'Json'>
    readonly action: FieldRef<"EAStrategy", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EAStrategy findUnique
   */
  export type EAStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * Filter, which EAStrategy to fetch.
     */
    where: EAStrategyWhereUniqueInput
  }

  /**
   * EAStrategy findUniqueOrThrow
   */
  export type EAStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * Filter, which EAStrategy to fetch.
     */
    where: EAStrategyWhereUniqueInput
  }

  /**
   * EAStrategy findFirst
   */
  export type EAStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * Filter, which EAStrategy to fetch.
     */
    where?: EAStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAStrategies to fetch.
     */
    orderBy?: EAStrategyOrderByWithRelationInput | EAStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAStrategies.
     */
    cursor?: EAStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAStrategies.
     */
    distinct?: EAStrategyScalarFieldEnum | EAStrategyScalarFieldEnum[]
  }

  /**
   * EAStrategy findFirstOrThrow
   */
  export type EAStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * Filter, which EAStrategy to fetch.
     */
    where?: EAStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAStrategies to fetch.
     */
    orderBy?: EAStrategyOrderByWithRelationInput | EAStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EAStrategies.
     */
    cursor?: EAStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EAStrategies.
     */
    distinct?: EAStrategyScalarFieldEnum | EAStrategyScalarFieldEnum[]
  }

  /**
   * EAStrategy findMany
   */
  export type EAStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * Filter, which EAStrategies to fetch.
     */
    where?: EAStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EAStrategies to fetch.
     */
    orderBy?: EAStrategyOrderByWithRelationInput | EAStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EAStrategies.
     */
    cursor?: EAStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EAStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EAStrategies.
     */
    skip?: number
    distinct?: EAStrategyScalarFieldEnum | EAStrategyScalarFieldEnum[]
  }

  /**
   * EAStrategy create
   */
  export type EAStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * The data needed to create a EAStrategy.
     */
    data?: XOR<EAStrategyCreateInput, EAStrategyUncheckedCreateInput>
  }

  /**
   * EAStrategy createMany
   */
  export type EAStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EAStrategies.
     */
    data: EAStrategyCreateManyInput | EAStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EAStrategy update
   */
  export type EAStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * The data needed to update a EAStrategy.
     */
    data: XOR<EAStrategyUpdateInput, EAStrategyUncheckedUpdateInput>
    /**
     * Choose, which EAStrategy to update.
     */
    where: EAStrategyWhereUniqueInput
  }

  /**
   * EAStrategy updateMany
   */
  export type EAStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EAStrategies.
     */
    data: XOR<EAStrategyUpdateManyMutationInput, EAStrategyUncheckedUpdateManyInput>
    /**
     * Filter which EAStrategies to update
     */
    where?: EAStrategyWhereInput
    /**
     * Limit how many EAStrategies to update.
     */
    limit?: number
  }

  /**
   * EAStrategy upsert
   */
  export type EAStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * The filter to search for the EAStrategy to update in case it exists.
     */
    where: EAStrategyWhereUniqueInput
    /**
     * In case the EAStrategy found by the `where` argument doesn't exist, create a new EAStrategy with this data.
     */
    create: XOR<EAStrategyCreateInput, EAStrategyUncheckedCreateInput>
    /**
     * In case the EAStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EAStrategyUpdateInput, EAStrategyUncheckedUpdateInput>
  }

  /**
   * EAStrategy delete
   */
  export type EAStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
    /**
     * Filter which EAStrategy to delete.
     */
    where: EAStrategyWhereUniqueInput
  }

  /**
   * EAStrategy deleteMany
   */
  export type EAStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EAStrategies to delete
     */
    where?: EAStrategyWhereInput
    /**
     * Limit how many EAStrategies to delete.
     */
    limit?: number
  }

  /**
   * EAStrategy without action
   */
  export type EAStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EAStrategy
     */
    select?: EAStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EAStrategy
     */
    omit?: EAStrategyOmit<ExtArgs> | null
  }


  /**
   * Model EATypeComparison
   */

  export type AggregateEATypeComparison = {
    _count: EATypeComparisonCountAggregateOutputType | null
    _avg: EATypeComparisonAvgAggregateOutputType | null
    _sum: EATypeComparisonSumAggregateOutputType | null
    _min: EATypeComparisonMinAggregateOutputType | null
    _max: EATypeComparisonMaxAggregateOutputType | null
  }

  export type EATypeComparisonAvgAggregateOutputType = {
    id: number | null
    coal: Decimal | null
    gas: Decimal | null
    electric: Decimal | null
  }

  export type EATypeComparisonSumAggregateOutputType = {
    id: number | null
    coal: Decimal | null
    gas: Decimal | null
    electric: Decimal | null
  }

  export type EATypeComparisonMinAggregateOutputType = {
    id: number | null
    month: string | null
    coal: Decimal | null
    gas: Decimal | null
    electric: Decimal | null
  }

  export type EATypeComparisonMaxAggregateOutputType = {
    id: number | null
    month: string | null
    coal: Decimal | null
    gas: Decimal | null
    electric: Decimal | null
  }

  export type EATypeComparisonCountAggregateOutputType = {
    id: number
    month: number
    coal: number
    gas: number
    electric: number
    _all: number
  }


  export type EATypeComparisonAvgAggregateInputType = {
    id?: true
    coal?: true
    gas?: true
    electric?: true
  }

  export type EATypeComparisonSumAggregateInputType = {
    id?: true
    coal?: true
    gas?: true
    electric?: true
  }

  export type EATypeComparisonMinAggregateInputType = {
    id?: true
    month?: true
    coal?: true
    gas?: true
    electric?: true
  }

  export type EATypeComparisonMaxAggregateInputType = {
    id?: true
    month?: true
    coal?: true
    gas?: true
    electric?: true
  }

  export type EATypeComparisonCountAggregateInputType = {
    id?: true
    month?: true
    coal?: true
    gas?: true
    electric?: true
    _all?: true
  }

  export type EATypeComparisonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EATypeComparison to aggregate.
     */
    where?: EATypeComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EATypeComparisons to fetch.
     */
    orderBy?: EATypeComparisonOrderByWithRelationInput | EATypeComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EATypeComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EATypeComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EATypeComparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EATypeComparisons
    **/
    _count?: true | EATypeComparisonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EATypeComparisonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EATypeComparisonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EATypeComparisonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EATypeComparisonMaxAggregateInputType
  }

  export type GetEATypeComparisonAggregateType<T extends EATypeComparisonAggregateArgs> = {
        [P in keyof T & keyof AggregateEATypeComparison]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEATypeComparison[P]>
      : GetScalarType<T[P], AggregateEATypeComparison[P]>
  }




  export type EATypeComparisonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EATypeComparisonWhereInput
    orderBy?: EATypeComparisonOrderByWithAggregationInput | EATypeComparisonOrderByWithAggregationInput[]
    by: EATypeComparisonScalarFieldEnum[] | EATypeComparisonScalarFieldEnum
    having?: EATypeComparisonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EATypeComparisonCountAggregateInputType | true
    _avg?: EATypeComparisonAvgAggregateInputType
    _sum?: EATypeComparisonSumAggregateInputType
    _min?: EATypeComparisonMinAggregateInputType
    _max?: EATypeComparisonMaxAggregateInputType
  }

  export type EATypeComparisonGroupByOutputType = {
    id: number
    month: string | null
    coal: Decimal | null
    gas: Decimal | null
    electric: Decimal | null
    _count: EATypeComparisonCountAggregateOutputType | null
    _avg: EATypeComparisonAvgAggregateOutputType | null
    _sum: EATypeComparisonSumAggregateOutputType | null
    _min: EATypeComparisonMinAggregateOutputType | null
    _max: EATypeComparisonMaxAggregateOutputType | null
  }

  type GetEATypeComparisonGroupByPayload<T extends EATypeComparisonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EATypeComparisonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EATypeComparisonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EATypeComparisonGroupByOutputType[P]>
            : GetScalarType<T[P], EATypeComparisonGroupByOutputType[P]>
        }
      >
    >


  export type EATypeComparisonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    coal?: boolean
    gas?: boolean
    electric?: boolean
  }, ExtArgs["result"]["eATypeComparison"]>



  export type EATypeComparisonSelectScalar = {
    id?: boolean
    month?: boolean
    coal?: boolean
    gas?: boolean
    electric?: boolean
  }

  export type EATypeComparisonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "coal" | "gas" | "electric", ExtArgs["result"]["eATypeComparison"]>

  export type $EATypeComparisonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EATypeComparison"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string | null
      coal: Prisma.Decimal | null
      gas: Prisma.Decimal | null
      electric: Prisma.Decimal | null
    }, ExtArgs["result"]["eATypeComparison"]>
    composites: {}
  }

  type EATypeComparisonGetPayload<S extends boolean | null | undefined | EATypeComparisonDefaultArgs> = $Result.GetResult<Prisma.$EATypeComparisonPayload, S>

  type EATypeComparisonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EATypeComparisonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EATypeComparisonCountAggregateInputType | true
    }

  export interface EATypeComparisonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EATypeComparison'], meta: { name: 'EATypeComparison' } }
    /**
     * Find zero or one EATypeComparison that matches the filter.
     * @param {EATypeComparisonFindUniqueArgs} args - Arguments to find a EATypeComparison
     * @example
     * // Get one EATypeComparison
     * const eATypeComparison = await prisma.eATypeComparison.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EATypeComparisonFindUniqueArgs>(args: SelectSubset<T, EATypeComparisonFindUniqueArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EATypeComparison that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EATypeComparisonFindUniqueOrThrowArgs} args - Arguments to find a EATypeComparison
     * @example
     * // Get one EATypeComparison
     * const eATypeComparison = await prisma.eATypeComparison.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EATypeComparisonFindUniqueOrThrowArgs>(args: SelectSubset<T, EATypeComparisonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EATypeComparison that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonFindFirstArgs} args - Arguments to find a EATypeComparison
     * @example
     * // Get one EATypeComparison
     * const eATypeComparison = await prisma.eATypeComparison.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EATypeComparisonFindFirstArgs>(args?: SelectSubset<T, EATypeComparisonFindFirstArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EATypeComparison that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonFindFirstOrThrowArgs} args - Arguments to find a EATypeComparison
     * @example
     * // Get one EATypeComparison
     * const eATypeComparison = await prisma.eATypeComparison.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EATypeComparisonFindFirstOrThrowArgs>(args?: SelectSubset<T, EATypeComparisonFindFirstOrThrowArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EATypeComparisons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EATypeComparisons
     * const eATypeComparisons = await prisma.eATypeComparison.findMany()
     * 
     * // Get first 10 EATypeComparisons
     * const eATypeComparisons = await prisma.eATypeComparison.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eATypeComparisonWithIdOnly = await prisma.eATypeComparison.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EATypeComparisonFindManyArgs>(args?: SelectSubset<T, EATypeComparisonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EATypeComparison.
     * @param {EATypeComparisonCreateArgs} args - Arguments to create a EATypeComparison.
     * @example
     * // Create one EATypeComparison
     * const EATypeComparison = await prisma.eATypeComparison.create({
     *   data: {
     *     // ... data to create a EATypeComparison
     *   }
     * })
     * 
     */
    create<T extends EATypeComparisonCreateArgs>(args: SelectSubset<T, EATypeComparisonCreateArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EATypeComparisons.
     * @param {EATypeComparisonCreateManyArgs} args - Arguments to create many EATypeComparisons.
     * @example
     * // Create many EATypeComparisons
     * const eATypeComparison = await prisma.eATypeComparison.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EATypeComparisonCreateManyArgs>(args?: SelectSubset<T, EATypeComparisonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EATypeComparison.
     * @param {EATypeComparisonDeleteArgs} args - Arguments to delete one EATypeComparison.
     * @example
     * // Delete one EATypeComparison
     * const EATypeComparison = await prisma.eATypeComparison.delete({
     *   where: {
     *     // ... filter to delete one EATypeComparison
     *   }
     * })
     * 
     */
    delete<T extends EATypeComparisonDeleteArgs>(args: SelectSubset<T, EATypeComparisonDeleteArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EATypeComparison.
     * @param {EATypeComparisonUpdateArgs} args - Arguments to update one EATypeComparison.
     * @example
     * // Update one EATypeComparison
     * const eATypeComparison = await prisma.eATypeComparison.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EATypeComparisonUpdateArgs>(args: SelectSubset<T, EATypeComparisonUpdateArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EATypeComparisons.
     * @param {EATypeComparisonDeleteManyArgs} args - Arguments to filter EATypeComparisons to delete.
     * @example
     * // Delete a few EATypeComparisons
     * const { count } = await prisma.eATypeComparison.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EATypeComparisonDeleteManyArgs>(args?: SelectSubset<T, EATypeComparisonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EATypeComparisons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EATypeComparisons
     * const eATypeComparison = await prisma.eATypeComparison.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EATypeComparisonUpdateManyArgs>(args: SelectSubset<T, EATypeComparisonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EATypeComparison.
     * @param {EATypeComparisonUpsertArgs} args - Arguments to update or create a EATypeComparison.
     * @example
     * // Update or create a EATypeComparison
     * const eATypeComparison = await prisma.eATypeComparison.upsert({
     *   create: {
     *     // ... data to create a EATypeComparison
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EATypeComparison we want to update
     *   }
     * })
     */
    upsert<T extends EATypeComparisonUpsertArgs>(args: SelectSubset<T, EATypeComparisonUpsertArgs<ExtArgs>>): Prisma__EATypeComparisonClient<$Result.GetResult<Prisma.$EATypeComparisonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EATypeComparisons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonCountArgs} args - Arguments to filter EATypeComparisons to count.
     * @example
     * // Count the number of EATypeComparisons
     * const count = await prisma.eATypeComparison.count({
     *   where: {
     *     // ... the filter for the EATypeComparisons we want to count
     *   }
     * })
    **/
    count<T extends EATypeComparisonCountArgs>(
      args?: Subset<T, EATypeComparisonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EATypeComparisonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EATypeComparison.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EATypeComparisonAggregateArgs>(args: Subset<T, EATypeComparisonAggregateArgs>): Prisma.PrismaPromise<GetEATypeComparisonAggregateType<T>>

    /**
     * Group by EATypeComparison.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EATypeComparisonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EATypeComparisonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EATypeComparisonGroupByArgs['orderBy'] }
        : { orderBy?: EATypeComparisonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EATypeComparisonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEATypeComparisonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EATypeComparison model
   */
  readonly fields: EATypeComparisonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EATypeComparison.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EATypeComparisonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EATypeComparison model
   */
  interface EATypeComparisonFieldRefs {
    readonly id: FieldRef<"EATypeComparison", 'Int'>
    readonly month: FieldRef<"EATypeComparison", 'String'>
    readonly coal: FieldRef<"EATypeComparison", 'Decimal'>
    readonly gas: FieldRef<"EATypeComparison", 'Decimal'>
    readonly electric: FieldRef<"EATypeComparison", 'Decimal'>
  }
    

  // Custom InputTypes
  /**
   * EATypeComparison findUnique
   */
  export type EATypeComparisonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * Filter, which EATypeComparison to fetch.
     */
    where: EATypeComparisonWhereUniqueInput
  }

  /**
   * EATypeComparison findUniqueOrThrow
   */
  export type EATypeComparisonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * Filter, which EATypeComparison to fetch.
     */
    where: EATypeComparisonWhereUniqueInput
  }

  /**
   * EATypeComparison findFirst
   */
  export type EATypeComparisonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * Filter, which EATypeComparison to fetch.
     */
    where?: EATypeComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EATypeComparisons to fetch.
     */
    orderBy?: EATypeComparisonOrderByWithRelationInput | EATypeComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EATypeComparisons.
     */
    cursor?: EATypeComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EATypeComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EATypeComparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EATypeComparisons.
     */
    distinct?: EATypeComparisonScalarFieldEnum | EATypeComparisonScalarFieldEnum[]
  }

  /**
   * EATypeComparison findFirstOrThrow
   */
  export type EATypeComparisonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * Filter, which EATypeComparison to fetch.
     */
    where?: EATypeComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EATypeComparisons to fetch.
     */
    orderBy?: EATypeComparisonOrderByWithRelationInput | EATypeComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EATypeComparisons.
     */
    cursor?: EATypeComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EATypeComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EATypeComparisons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EATypeComparisons.
     */
    distinct?: EATypeComparisonScalarFieldEnum | EATypeComparisonScalarFieldEnum[]
  }

  /**
   * EATypeComparison findMany
   */
  export type EATypeComparisonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * Filter, which EATypeComparisons to fetch.
     */
    where?: EATypeComparisonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EATypeComparisons to fetch.
     */
    orderBy?: EATypeComparisonOrderByWithRelationInput | EATypeComparisonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EATypeComparisons.
     */
    cursor?: EATypeComparisonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EATypeComparisons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EATypeComparisons.
     */
    skip?: number
    distinct?: EATypeComparisonScalarFieldEnum | EATypeComparisonScalarFieldEnum[]
  }

  /**
   * EATypeComparison create
   */
  export type EATypeComparisonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * The data needed to create a EATypeComparison.
     */
    data?: XOR<EATypeComparisonCreateInput, EATypeComparisonUncheckedCreateInput>
  }

  /**
   * EATypeComparison createMany
   */
  export type EATypeComparisonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EATypeComparisons.
     */
    data: EATypeComparisonCreateManyInput | EATypeComparisonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EATypeComparison update
   */
  export type EATypeComparisonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * The data needed to update a EATypeComparison.
     */
    data: XOR<EATypeComparisonUpdateInput, EATypeComparisonUncheckedUpdateInput>
    /**
     * Choose, which EATypeComparison to update.
     */
    where: EATypeComparisonWhereUniqueInput
  }

  /**
   * EATypeComparison updateMany
   */
  export type EATypeComparisonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EATypeComparisons.
     */
    data: XOR<EATypeComparisonUpdateManyMutationInput, EATypeComparisonUncheckedUpdateManyInput>
    /**
     * Filter which EATypeComparisons to update
     */
    where?: EATypeComparisonWhereInput
    /**
     * Limit how many EATypeComparisons to update.
     */
    limit?: number
  }

  /**
   * EATypeComparison upsert
   */
  export type EATypeComparisonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * The filter to search for the EATypeComparison to update in case it exists.
     */
    where: EATypeComparisonWhereUniqueInput
    /**
     * In case the EATypeComparison found by the `where` argument doesn't exist, create a new EATypeComparison with this data.
     */
    create: XOR<EATypeComparisonCreateInput, EATypeComparisonUncheckedCreateInput>
    /**
     * In case the EATypeComparison was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EATypeComparisonUpdateInput, EATypeComparisonUncheckedUpdateInput>
  }

  /**
   * EATypeComparison delete
   */
  export type EATypeComparisonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
    /**
     * Filter which EATypeComparison to delete.
     */
    where: EATypeComparisonWhereUniqueInput
  }

  /**
   * EATypeComparison deleteMany
   */
  export type EATypeComparisonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EATypeComparisons to delete
     */
    where?: EATypeComparisonWhereInput
    /**
     * Limit how many EATypeComparisons to delete.
     */
    limit?: number
  }

  /**
   * EATypeComparison without action
   */
  export type EATypeComparisonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EATypeComparison
     */
    select?: EATypeComparisonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EATypeComparison
     */
    omit?: EATypeComparisonOmit<ExtArgs> | null
  }


  /**
   * Model EBParamCards
   */

  export type AggregateEBParamCards = {
    _count: EBParamCardsCountAggregateOutputType | null
    _avg: EBParamCardsAvgAggregateOutputType | null
    _sum: EBParamCardsSumAggregateOutputType | null
    _min: EBParamCardsMinAggregateOutputType | null
    _max: EBParamCardsMaxAggregateOutputType | null
  }

  export type EBParamCardsAvgAggregateOutputType = {
    id: number | null
  }

  export type EBParamCardsSumAggregateOutputType = {
    id: number | null
  }

  export type EBParamCardsMinAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    unit: string | null
    trend: string | null
  }

  export type EBParamCardsMaxAggregateOutputType = {
    id: number | null
    key: string | null
    value: string | null
    unit: string | null
    trend: string | null
  }

  export type EBParamCardsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    unit: number
    trend: number
    _all: number
  }


  export type EBParamCardsAvgAggregateInputType = {
    id?: true
  }

  export type EBParamCardsSumAggregateInputType = {
    id?: true
  }

  export type EBParamCardsMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    unit?: true
    trend?: true
  }

  export type EBParamCardsMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    unit?: true
    trend?: true
  }

  export type EBParamCardsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    unit?: true
    trend?: true
    _all?: true
  }

  export type EBParamCardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBParamCards to aggregate.
     */
    where?: EBParamCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBParamCards to fetch.
     */
    orderBy?: EBParamCardsOrderByWithRelationInput | EBParamCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EBParamCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBParamCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBParamCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EBParamCards
    **/
    _count?: true | EBParamCardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EBParamCardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EBParamCardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EBParamCardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EBParamCardsMaxAggregateInputType
  }

  export type GetEBParamCardsAggregateType<T extends EBParamCardsAggregateArgs> = {
        [P in keyof T & keyof AggregateEBParamCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEBParamCards[P]>
      : GetScalarType<T[P], AggregateEBParamCards[P]>
  }




  export type EBParamCardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EBParamCardsWhereInput
    orderBy?: EBParamCardsOrderByWithAggregationInput | EBParamCardsOrderByWithAggregationInput[]
    by: EBParamCardsScalarFieldEnum[] | EBParamCardsScalarFieldEnum
    having?: EBParamCardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EBParamCardsCountAggregateInputType | true
    _avg?: EBParamCardsAvgAggregateInputType
    _sum?: EBParamCardsSumAggregateInputType
    _min?: EBParamCardsMinAggregateInputType
    _max?: EBParamCardsMaxAggregateInputType
  }

  export type EBParamCardsGroupByOutputType = {
    id: number
    key: string | null
    value: string | null
    unit: string | null
    trend: string | null
    _count: EBParamCardsCountAggregateOutputType | null
    _avg: EBParamCardsAvgAggregateOutputType | null
    _sum: EBParamCardsSumAggregateOutputType | null
    _min: EBParamCardsMinAggregateOutputType | null
    _max: EBParamCardsMaxAggregateOutputType | null
  }

  type GetEBParamCardsGroupByPayload<T extends EBParamCardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EBParamCardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EBParamCardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EBParamCardsGroupByOutputType[P]>
            : GetScalarType<T[P], EBParamCardsGroupByOutputType[P]>
        }
      >
    >


  export type EBParamCardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    unit?: boolean
    trend?: boolean
  }, ExtArgs["result"]["eBParamCards"]>



  export type EBParamCardsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    unit?: boolean
    trend?: boolean
  }

  export type EBParamCardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "unit" | "trend", ExtArgs["result"]["eBParamCards"]>

  export type $EBParamCardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EBParamCards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      key: string | null
      value: string | null
      unit: string | null
      trend: string | null
    }, ExtArgs["result"]["eBParamCards"]>
    composites: {}
  }

  type EBParamCardsGetPayload<S extends boolean | null | undefined | EBParamCardsDefaultArgs> = $Result.GetResult<Prisma.$EBParamCardsPayload, S>

  type EBParamCardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EBParamCardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EBParamCardsCountAggregateInputType | true
    }

  export interface EBParamCardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EBParamCards'], meta: { name: 'EBParamCards' } }
    /**
     * Find zero or one EBParamCards that matches the filter.
     * @param {EBParamCardsFindUniqueArgs} args - Arguments to find a EBParamCards
     * @example
     * // Get one EBParamCards
     * const eBParamCards = await prisma.eBParamCards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EBParamCardsFindUniqueArgs>(args: SelectSubset<T, EBParamCardsFindUniqueArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EBParamCards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EBParamCardsFindUniqueOrThrowArgs} args - Arguments to find a EBParamCards
     * @example
     * // Get one EBParamCards
     * const eBParamCards = await prisma.eBParamCards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EBParamCardsFindUniqueOrThrowArgs>(args: SelectSubset<T, EBParamCardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBParamCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsFindFirstArgs} args - Arguments to find a EBParamCards
     * @example
     * // Get one EBParamCards
     * const eBParamCards = await prisma.eBParamCards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EBParamCardsFindFirstArgs>(args?: SelectSubset<T, EBParamCardsFindFirstArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBParamCards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsFindFirstOrThrowArgs} args - Arguments to find a EBParamCards
     * @example
     * // Get one EBParamCards
     * const eBParamCards = await prisma.eBParamCards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EBParamCardsFindFirstOrThrowArgs>(args?: SelectSubset<T, EBParamCardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EBParamCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EBParamCards
     * const eBParamCards = await prisma.eBParamCards.findMany()
     * 
     * // Get first 10 EBParamCards
     * const eBParamCards = await prisma.eBParamCards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eBParamCardsWithIdOnly = await prisma.eBParamCards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EBParamCardsFindManyArgs>(args?: SelectSubset<T, EBParamCardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EBParamCards.
     * @param {EBParamCardsCreateArgs} args - Arguments to create a EBParamCards.
     * @example
     * // Create one EBParamCards
     * const EBParamCards = await prisma.eBParamCards.create({
     *   data: {
     *     // ... data to create a EBParamCards
     *   }
     * })
     * 
     */
    create<T extends EBParamCardsCreateArgs>(args: SelectSubset<T, EBParamCardsCreateArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EBParamCards.
     * @param {EBParamCardsCreateManyArgs} args - Arguments to create many EBParamCards.
     * @example
     * // Create many EBParamCards
     * const eBParamCards = await prisma.eBParamCards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EBParamCardsCreateManyArgs>(args?: SelectSubset<T, EBParamCardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EBParamCards.
     * @param {EBParamCardsDeleteArgs} args - Arguments to delete one EBParamCards.
     * @example
     * // Delete one EBParamCards
     * const EBParamCards = await prisma.eBParamCards.delete({
     *   where: {
     *     // ... filter to delete one EBParamCards
     *   }
     * })
     * 
     */
    delete<T extends EBParamCardsDeleteArgs>(args: SelectSubset<T, EBParamCardsDeleteArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EBParamCards.
     * @param {EBParamCardsUpdateArgs} args - Arguments to update one EBParamCards.
     * @example
     * // Update one EBParamCards
     * const eBParamCards = await prisma.eBParamCards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EBParamCardsUpdateArgs>(args: SelectSubset<T, EBParamCardsUpdateArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EBParamCards.
     * @param {EBParamCardsDeleteManyArgs} args - Arguments to filter EBParamCards to delete.
     * @example
     * // Delete a few EBParamCards
     * const { count } = await prisma.eBParamCards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EBParamCardsDeleteManyArgs>(args?: SelectSubset<T, EBParamCardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EBParamCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EBParamCards
     * const eBParamCards = await prisma.eBParamCards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EBParamCardsUpdateManyArgs>(args: SelectSubset<T, EBParamCardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EBParamCards.
     * @param {EBParamCardsUpsertArgs} args - Arguments to update or create a EBParamCards.
     * @example
     * // Update or create a EBParamCards
     * const eBParamCards = await prisma.eBParamCards.upsert({
     *   create: {
     *     // ... data to create a EBParamCards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EBParamCards we want to update
     *   }
     * })
     */
    upsert<T extends EBParamCardsUpsertArgs>(args: SelectSubset<T, EBParamCardsUpsertArgs<ExtArgs>>): Prisma__EBParamCardsClient<$Result.GetResult<Prisma.$EBParamCardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EBParamCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsCountArgs} args - Arguments to filter EBParamCards to count.
     * @example
     * // Count the number of EBParamCards
     * const count = await prisma.eBParamCards.count({
     *   where: {
     *     // ... the filter for the EBParamCards we want to count
     *   }
     * })
    **/
    count<T extends EBParamCardsCountArgs>(
      args?: Subset<T, EBParamCardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EBParamCardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EBParamCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EBParamCardsAggregateArgs>(args: Subset<T, EBParamCardsAggregateArgs>): Prisma.PrismaPromise<GetEBParamCardsAggregateType<T>>

    /**
     * Group by EBParamCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBParamCardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EBParamCardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EBParamCardsGroupByArgs['orderBy'] }
        : { orderBy?: EBParamCardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EBParamCardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEBParamCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EBParamCards model
   */
  readonly fields: EBParamCardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EBParamCards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EBParamCardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EBParamCards model
   */
  interface EBParamCardsFieldRefs {
    readonly id: FieldRef<"EBParamCards", 'Int'>
    readonly key: FieldRef<"EBParamCards", 'String'>
    readonly value: FieldRef<"EBParamCards", 'String'>
    readonly unit: FieldRef<"EBParamCards", 'String'>
    readonly trend: FieldRef<"EBParamCards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EBParamCards findUnique
   */
  export type EBParamCardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * Filter, which EBParamCards to fetch.
     */
    where: EBParamCardsWhereUniqueInput
  }

  /**
   * EBParamCards findUniqueOrThrow
   */
  export type EBParamCardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * Filter, which EBParamCards to fetch.
     */
    where: EBParamCardsWhereUniqueInput
  }

  /**
   * EBParamCards findFirst
   */
  export type EBParamCardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * Filter, which EBParamCards to fetch.
     */
    where?: EBParamCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBParamCards to fetch.
     */
    orderBy?: EBParamCardsOrderByWithRelationInput | EBParamCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBParamCards.
     */
    cursor?: EBParamCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBParamCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBParamCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBParamCards.
     */
    distinct?: EBParamCardsScalarFieldEnum | EBParamCardsScalarFieldEnum[]
  }

  /**
   * EBParamCards findFirstOrThrow
   */
  export type EBParamCardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * Filter, which EBParamCards to fetch.
     */
    where?: EBParamCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBParamCards to fetch.
     */
    orderBy?: EBParamCardsOrderByWithRelationInput | EBParamCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBParamCards.
     */
    cursor?: EBParamCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBParamCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBParamCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBParamCards.
     */
    distinct?: EBParamCardsScalarFieldEnum | EBParamCardsScalarFieldEnum[]
  }

  /**
   * EBParamCards findMany
   */
  export type EBParamCardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * Filter, which EBParamCards to fetch.
     */
    where?: EBParamCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBParamCards to fetch.
     */
    orderBy?: EBParamCardsOrderByWithRelationInput | EBParamCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EBParamCards.
     */
    cursor?: EBParamCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBParamCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBParamCards.
     */
    skip?: number
    distinct?: EBParamCardsScalarFieldEnum | EBParamCardsScalarFieldEnum[]
  }

  /**
   * EBParamCards create
   */
  export type EBParamCardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * The data needed to create a EBParamCards.
     */
    data?: XOR<EBParamCardsCreateInput, EBParamCardsUncheckedCreateInput>
  }

  /**
   * EBParamCards createMany
   */
  export type EBParamCardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EBParamCards.
     */
    data: EBParamCardsCreateManyInput | EBParamCardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EBParamCards update
   */
  export type EBParamCardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * The data needed to update a EBParamCards.
     */
    data: XOR<EBParamCardsUpdateInput, EBParamCardsUncheckedUpdateInput>
    /**
     * Choose, which EBParamCards to update.
     */
    where: EBParamCardsWhereUniqueInput
  }

  /**
   * EBParamCards updateMany
   */
  export type EBParamCardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EBParamCards.
     */
    data: XOR<EBParamCardsUpdateManyMutationInput, EBParamCardsUncheckedUpdateManyInput>
    /**
     * Filter which EBParamCards to update
     */
    where?: EBParamCardsWhereInput
    /**
     * Limit how many EBParamCards to update.
     */
    limit?: number
  }

  /**
   * EBParamCards upsert
   */
  export type EBParamCardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * The filter to search for the EBParamCards to update in case it exists.
     */
    where: EBParamCardsWhereUniqueInput
    /**
     * In case the EBParamCards found by the `where` argument doesn't exist, create a new EBParamCards with this data.
     */
    create: XOR<EBParamCardsCreateInput, EBParamCardsUncheckedCreateInput>
    /**
     * In case the EBParamCards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EBParamCardsUpdateInput, EBParamCardsUncheckedUpdateInput>
  }

  /**
   * EBParamCards delete
   */
  export type EBParamCardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
    /**
     * Filter which EBParamCards to delete.
     */
    where: EBParamCardsWhereUniqueInput
  }

  /**
   * EBParamCards deleteMany
   */
  export type EBParamCardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBParamCards to delete
     */
    where?: EBParamCardsWhereInput
    /**
     * Limit how many EBParamCards to delete.
     */
    limit?: number
  }

  /**
   * EBParamCards without action
   */
  export type EBParamCardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBParamCards
     */
    select?: EBParamCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBParamCards
     */
    omit?: EBParamCardsOmit<ExtArgs> | null
  }


  /**
   * Model EBPieChart
   */

  export type AggregateEBPieChart = {
    _count: EBPieChartCountAggregateOutputType | null
    _avg: EBPieChartAvgAggregateOutputType | null
    _sum: EBPieChartSumAggregateOutputType | null
    _min: EBPieChartMinAggregateOutputType | null
    _max: EBPieChartMaxAggregateOutputType | null
  }

  export type EBPieChartAvgAggregateOutputType = {
    id: number | null
  }

  export type EBPieChartSumAggregateOutputType = {
    id: number | null
  }

  export type EBPieChartMinAggregateOutputType = {
    id: number | null
    type: string | null
    value: string | null
    color: string | null
  }

  export type EBPieChartMaxAggregateOutputType = {
    id: number | null
    type: string | null
    value: string | null
    color: string | null
  }

  export type EBPieChartCountAggregateOutputType = {
    id: number
    type: number
    value: number
    color: number
    _all: number
  }


  export type EBPieChartAvgAggregateInputType = {
    id?: true
  }

  export type EBPieChartSumAggregateInputType = {
    id?: true
  }

  export type EBPieChartMinAggregateInputType = {
    id?: true
    type?: true
    value?: true
    color?: true
  }

  export type EBPieChartMaxAggregateInputType = {
    id?: true
    type?: true
    value?: true
    color?: true
  }

  export type EBPieChartCountAggregateInputType = {
    id?: true
    type?: true
    value?: true
    color?: true
    _all?: true
  }

  export type EBPieChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBPieChart to aggregate.
     */
    where?: EBPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBPieCharts to fetch.
     */
    orderBy?: EBPieChartOrderByWithRelationInput | EBPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EBPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EBPieCharts
    **/
    _count?: true | EBPieChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EBPieChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EBPieChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EBPieChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EBPieChartMaxAggregateInputType
  }

  export type GetEBPieChartAggregateType<T extends EBPieChartAggregateArgs> = {
        [P in keyof T & keyof AggregateEBPieChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEBPieChart[P]>
      : GetScalarType<T[P], AggregateEBPieChart[P]>
  }




  export type EBPieChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EBPieChartWhereInput
    orderBy?: EBPieChartOrderByWithAggregationInput | EBPieChartOrderByWithAggregationInput[]
    by: EBPieChartScalarFieldEnum[] | EBPieChartScalarFieldEnum
    having?: EBPieChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EBPieChartCountAggregateInputType | true
    _avg?: EBPieChartAvgAggregateInputType
    _sum?: EBPieChartSumAggregateInputType
    _min?: EBPieChartMinAggregateInputType
    _max?: EBPieChartMaxAggregateInputType
  }

  export type EBPieChartGroupByOutputType = {
    id: number
    type: string | null
    value: string | null
    color: string | null
    _count: EBPieChartCountAggregateOutputType | null
    _avg: EBPieChartAvgAggregateOutputType | null
    _sum: EBPieChartSumAggregateOutputType | null
    _min: EBPieChartMinAggregateOutputType | null
    _max: EBPieChartMaxAggregateOutputType | null
  }

  type GetEBPieChartGroupByPayload<T extends EBPieChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EBPieChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EBPieChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EBPieChartGroupByOutputType[P]>
            : GetScalarType<T[P], EBPieChartGroupByOutputType[P]>
        }
      >
    >


  export type EBPieChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    value?: boolean
    color?: boolean
  }, ExtArgs["result"]["eBPieChart"]>



  export type EBPieChartSelectScalar = {
    id?: boolean
    type?: boolean
    value?: boolean
    color?: boolean
  }

  export type EBPieChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "value" | "color", ExtArgs["result"]["eBPieChart"]>

  export type $EBPieChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EBPieChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      value: string | null
      color: string | null
    }, ExtArgs["result"]["eBPieChart"]>
    composites: {}
  }

  type EBPieChartGetPayload<S extends boolean | null | undefined | EBPieChartDefaultArgs> = $Result.GetResult<Prisma.$EBPieChartPayload, S>

  type EBPieChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EBPieChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EBPieChartCountAggregateInputType | true
    }

  export interface EBPieChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EBPieChart'], meta: { name: 'EBPieChart' } }
    /**
     * Find zero or one EBPieChart that matches the filter.
     * @param {EBPieChartFindUniqueArgs} args - Arguments to find a EBPieChart
     * @example
     * // Get one EBPieChart
     * const eBPieChart = await prisma.eBPieChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EBPieChartFindUniqueArgs>(args: SelectSubset<T, EBPieChartFindUniqueArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EBPieChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EBPieChartFindUniqueOrThrowArgs} args - Arguments to find a EBPieChart
     * @example
     * // Get one EBPieChart
     * const eBPieChart = await prisma.eBPieChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EBPieChartFindUniqueOrThrowArgs>(args: SelectSubset<T, EBPieChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBPieChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartFindFirstArgs} args - Arguments to find a EBPieChart
     * @example
     * // Get one EBPieChart
     * const eBPieChart = await prisma.eBPieChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EBPieChartFindFirstArgs>(args?: SelectSubset<T, EBPieChartFindFirstArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBPieChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartFindFirstOrThrowArgs} args - Arguments to find a EBPieChart
     * @example
     * // Get one EBPieChart
     * const eBPieChart = await prisma.eBPieChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EBPieChartFindFirstOrThrowArgs>(args?: SelectSubset<T, EBPieChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EBPieCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EBPieCharts
     * const eBPieCharts = await prisma.eBPieChart.findMany()
     * 
     * // Get first 10 EBPieCharts
     * const eBPieCharts = await prisma.eBPieChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eBPieChartWithIdOnly = await prisma.eBPieChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EBPieChartFindManyArgs>(args?: SelectSubset<T, EBPieChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EBPieChart.
     * @param {EBPieChartCreateArgs} args - Arguments to create a EBPieChart.
     * @example
     * // Create one EBPieChart
     * const EBPieChart = await prisma.eBPieChart.create({
     *   data: {
     *     // ... data to create a EBPieChart
     *   }
     * })
     * 
     */
    create<T extends EBPieChartCreateArgs>(args: SelectSubset<T, EBPieChartCreateArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EBPieCharts.
     * @param {EBPieChartCreateManyArgs} args - Arguments to create many EBPieCharts.
     * @example
     * // Create many EBPieCharts
     * const eBPieChart = await prisma.eBPieChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EBPieChartCreateManyArgs>(args?: SelectSubset<T, EBPieChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EBPieChart.
     * @param {EBPieChartDeleteArgs} args - Arguments to delete one EBPieChart.
     * @example
     * // Delete one EBPieChart
     * const EBPieChart = await prisma.eBPieChart.delete({
     *   where: {
     *     // ... filter to delete one EBPieChart
     *   }
     * })
     * 
     */
    delete<T extends EBPieChartDeleteArgs>(args: SelectSubset<T, EBPieChartDeleteArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EBPieChart.
     * @param {EBPieChartUpdateArgs} args - Arguments to update one EBPieChart.
     * @example
     * // Update one EBPieChart
     * const eBPieChart = await prisma.eBPieChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EBPieChartUpdateArgs>(args: SelectSubset<T, EBPieChartUpdateArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EBPieCharts.
     * @param {EBPieChartDeleteManyArgs} args - Arguments to filter EBPieCharts to delete.
     * @example
     * // Delete a few EBPieCharts
     * const { count } = await prisma.eBPieChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EBPieChartDeleteManyArgs>(args?: SelectSubset<T, EBPieChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EBPieCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EBPieCharts
     * const eBPieChart = await prisma.eBPieChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EBPieChartUpdateManyArgs>(args: SelectSubset<T, EBPieChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EBPieChart.
     * @param {EBPieChartUpsertArgs} args - Arguments to update or create a EBPieChart.
     * @example
     * // Update or create a EBPieChart
     * const eBPieChart = await prisma.eBPieChart.upsert({
     *   create: {
     *     // ... data to create a EBPieChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EBPieChart we want to update
     *   }
     * })
     */
    upsert<T extends EBPieChartUpsertArgs>(args: SelectSubset<T, EBPieChartUpsertArgs<ExtArgs>>): Prisma__EBPieChartClient<$Result.GetResult<Prisma.$EBPieChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EBPieCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartCountArgs} args - Arguments to filter EBPieCharts to count.
     * @example
     * // Count the number of EBPieCharts
     * const count = await prisma.eBPieChart.count({
     *   where: {
     *     // ... the filter for the EBPieCharts we want to count
     *   }
     * })
    **/
    count<T extends EBPieChartCountArgs>(
      args?: Subset<T, EBPieChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EBPieChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EBPieChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EBPieChartAggregateArgs>(args: Subset<T, EBPieChartAggregateArgs>): Prisma.PrismaPromise<GetEBPieChartAggregateType<T>>

    /**
     * Group by EBPieChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBPieChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EBPieChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EBPieChartGroupByArgs['orderBy'] }
        : { orderBy?: EBPieChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EBPieChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEBPieChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EBPieChart model
   */
  readonly fields: EBPieChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EBPieChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EBPieChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EBPieChart model
   */
  interface EBPieChartFieldRefs {
    readonly id: FieldRef<"EBPieChart", 'Int'>
    readonly type: FieldRef<"EBPieChart", 'String'>
    readonly value: FieldRef<"EBPieChart", 'String'>
    readonly color: FieldRef<"EBPieChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EBPieChart findUnique
   */
  export type EBPieChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * Filter, which EBPieChart to fetch.
     */
    where: EBPieChartWhereUniqueInput
  }

  /**
   * EBPieChart findUniqueOrThrow
   */
  export type EBPieChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * Filter, which EBPieChart to fetch.
     */
    where: EBPieChartWhereUniqueInput
  }

  /**
   * EBPieChart findFirst
   */
  export type EBPieChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * Filter, which EBPieChart to fetch.
     */
    where?: EBPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBPieCharts to fetch.
     */
    orderBy?: EBPieChartOrderByWithRelationInput | EBPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBPieCharts.
     */
    cursor?: EBPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBPieCharts.
     */
    distinct?: EBPieChartScalarFieldEnum | EBPieChartScalarFieldEnum[]
  }

  /**
   * EBPieChart findFirstOrThrow
   */
  export type EBPieChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * Filter, which EBPieChart to fetch.
     */
    where?: EBPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBPieCharts to fetch.
     */
    orderBy?: EBPieChartOrderByWithRelationInput | EBPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBPieCharts.
     */
    cursor?: EBPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBPieCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBPieCharts.
     */
    distinct?: EBPieChartScalarFieldEnum | EBPieChartScalarFieldEnum[]
  }

  /**
   * EBPieChart findMany
   */
  export type EBPieChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * Filter, which EBPieCharts to fetch.
     */
    where?: EBPieChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBPieCharts to fetch.
     */
    orderBy?: EBPieChartOrderByWithRelationInput | EBPieChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EBPieCharts.
     */
    cursor?: EBPieChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBPieCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBPieCharts.
     */
    skip?: number
    distinct?: EBPieChartScalarFieldEnum | EBPieChartScalarFieldEnum[]
  }

  /**
   * EBPieChart create
   */
  export type EBPieChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * The data needed to create a EBPieChart.
     */
    data?: XOR<EBPieChartCreateInput, EBPieChartUncheckedCreateInput>
  }

  /**
   * EBPieChart createMany
   */
  export type EBPieChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EBPieCharts.
     */
    data: EBPieChartCreateManyInput | EBPieChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EBPieChart update
   */
  export type EBPieChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * The data needed to update a EBPieChart.
     */
    data: XOR<EBPieChartUpdateInput, EBPieChartUncheckedUpdateInput>
    /**
     * Choose, which EBPieChart to update.
     */
    where: EBPieChartWhereUniqueInput
  }

  /**
   * EBPieChart updateMany
   */
  export type EBPieChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EBPieCharts.
     */
    data: XOR<EBPieChartUpdateManyMutationInput, EBPieChartUncheckedUpdateManyInput>
    /**
     * Filter which EBPieCharts to update
     */
    where?: EBPieChartWhereInput
    /**
     * Limit how many EBPieCharts to update.
     */
    limit?: number
  }

  /**
   * EBPieChart upsert
   */
  export type EBPieChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * The filter to search for the EBPieChart to update in case it exists.
     */
    where: EBPieChartWhereUniqueInput
    /**
     * In case the EBPieChart found by the `where` argument doesn't exist, create a new EBPieChart with this data.
     */
    create: XOR<EBPieChartCreateInput, EBPieChartUncheckedCreateInput>
    /**
     * In case the EBPieChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EBPieChartUpdateInput, EBPieChartUncheckedUpdateInput>
  }

  /**
   * EBPieChart delete
   */
  export type EBPieChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
    /**
     * Filter which EBPieChart to delete.
     */
    where: EBPieChartWhereUniqueInput
  }

  /**
   * EBPieChart deleteMany
   */
  export type EBPieChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBPieCharts to delete
     */
    where?: EBPieChartWhereInput
    /**
     * Limit how many EBPieCharts to delete.
     */
    limit?: number
  }

  /**
   * EBPieChart without action
   */
  export type EBPieChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBPieChart
     */
    select?: EBPieChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBPieChart
     */
    omit?: EBPieChartOmit<ExtArgs> | null
  }


  /**
   * Model EBResults
   */

  export type AggregateEBResults = {
    _count: EBResultsCountAggregateOutputType | null
    _avg: EBResultsAvgAggregateOutputType | null
    _sum: EBResultsSumAggregateOutputType | null
    _min: EBResultsMinAggregateOutputType | null
    _max: EBResultsMaxAggregateOutputType | null
  }

  export type EBResultsAvgAggregateOutputType = {
    id: number | null
  }

  export type EBResultsSumAggregateOutputType = {
    id: number | null
  }

  export type EBResultsMinAggregateOutputType = {
    id: number | null
    savings: string | null
  }

  export type EBResultsMaxAggregateOutputType = {
    id: number | null
    savings: string | null
  }

  export type EBResultsCountAggregateOutputType = {
    id: number
    before: number
    after: number
    savings: number
    _all: number
  }


  export type EBResultsAvgAggregateInputType = {
    id?: true
  }

  export type EBResultsSumAggregateInputType = {
    id?: true
  }

  export type EBResultsMinAggregateInputType = {
    id?: true
    savings?: true
  }

  export type EBResultsMaxAggregateInputType = {
    id?: true
    savings?: true
  }

  export type EBResultsCountAggregateInputType = {
    id?: true
    before?: true
    after?: true
    savings?: true
    _all?: true
  }

  export type EBResultsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBResults to aggregate.
     */
    where?: EBResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBResults to fetch.
     */
    orderBy?: EBResultsOrderByWithRelationInput | EBResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EBResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EBResults
    **/
    _count?: true | EBResultsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EBResultsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EBResultsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EBResultsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EBResultsMaxAggregateInputType
  }

  export type GetEBResultsAggregateType<T extends EBResultsAggregateArgs> = {
        [P in keyof T & keyof AggregateEBResults]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEBResults[P]>
      : GetScalarType<T[P], AggregateEBResults[P]>
  }




  export type EBResultsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EBResultsWhereInput
    orderBy?: EBResultsOrderByWithAggregationInput | EBResultsOrderByWithAggregationInput[]
    by: EBResultsScalarFieldEnum[] | EBResultsScalarFieldEnum
    having?: EBResultsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EBResultsCountAggregateInputType | true
    _avg?: EBResultsAvgAggregateInputType
    _sum?: EBResultsSumAggregateInputType
    _min?: EBResultsMinAggregateInputType
    _max?: EBResultsMaxAggregateInputType
  }

  export type EBResultsGroupByOutputType = {
    id: number
    before: JsonValue | null
    after: JsonValue | null
    savings: string | null
    _count: EBResultsCountAggregateOutputType | null
    _avg: EBResultsAvgAggregateOutputType | null
    _sum: EBResultsSumAggregateOutputType | null
    _min: EBResultsMinAggregateOutputType | null
    _max: EBResultsMaxAggregateOutputType | null
  }

  type GetEBResultsGroupByPayload<T extends EBResultsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EBResultsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EBResultsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EBResultsGroupByOutputType[P]>
            : GetScalarType<T[P], EBResultsGroupByOutputType[P]>
        }
      >
    >


  export type EBResultsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    before?: boolean
    after?: boolean
    savings?: boolean
  }, ExtArgs["result"]["eBResults"]>



  export type EBResultsSelectScalar = {
    id?: boolean
    before?: boolean
    after?: boolean
    savings?: boolean
  }

  export type EBResultsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "before" | "after" | "savings", ExtArgs["result"]["eBResults"]>

  export type $EBResultsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EBResults"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      before: Prisma.JsonValue | null
      after: Prisma.JsonValue | null
      savings: string | null
    }, ExtArgs["result"]["eBResults"]>
    composites: {}
  }

  type EBResultsGetPayload<S extends boolean | null | undefined | EBResultsDefaultArgs> = $Result.GetResult<Prisma.$EBResultsPayload, S>

  type EBResultsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EBResultsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EBResultsCountAggregateInputType | true
    }

  export interface EBResultsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EBResults'], meta: { name: 'EBResults' } }
    /**
     * Find zero or one EBResults that matches the filter.
     * @param {EBResultsFindUniqueArgs} args - Arguments to find a EBResults
     * @example
     * // Get one EBResults
     * const eBResults = await prisma.eBResults.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EBResultsFindUniqueArgs>(args: SelectSubset<T, EBResultsFindUniqueArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EBResults that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EBResultsFindUniqueOrThrowArgs} args - Arguments to find a EBResults
     * @example
     * // Get one EBResults
     * const eBResults = await prisma.eBResults.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EBResultsFindUniqueOrThrowArgs>(args: SelectSubset<T, EBResultsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsFindFirstArgs} args - Arguments to find a EBResults
     * @example
     * // Get one EBResults
     * const eBResults = await prisma.eBResults.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EBResultsFindFirstArgs>(args?: SelectSubset<T, EBResultsFindFirstArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBResults that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsFindFirstOrThrowArgs} args - Arguments to find a EBResults
     * @example
     * // Get one EBResults
     * const eBResults = await prisma.eBResults.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EBResultsFindFirstOrThrowArgs>(args?: SelectSubset<T, EBResultsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EBResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EBResults
     * const eBResults = await prisma.eBResults.findMany()
     * 
     * // Get first 10 EBResults
     * const eBResults = await prisma.eBResults.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eBResultsWithIdOnly = await prisma.eBResults.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EBResultsFindManyArgs>(args?: SelectSubset<T, EBResultsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EBResults.
     * @param {EBResultsCreateArgs} args - Arguments to create a EBResults.
     * @example
     * // Create one EBResults
     * const EBResults = await prisma.eBResults.create({
     *   data: {
     *     // ... data to create a EBResults
     *   }
     * })
     * 
     */
    create<T extends EBResultsCreateArgs>(args: SelectSubset<T, EBResultsCreateArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EBResults.
     * @param {EBResultsCreateManyArgs} args - Arguments to create many EBResults.
     * @example
     * // Create many EBResults
     * const eBResults = await prisma.eBResults.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EBResultsCreateManyArgs>(args?: SelectSubset<T, EBResultsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EBResults.
     * @param {EBResultsDeleteArgs} args - Arguments to delete one EBResults.
     * @example
     * // Delete one EBResults
     * const EBResults = await prisma.eBResults.delete({
     *   where: {
     *     // ... filter to delete one EBResults
     *   }
     * })
     * 
     */
    delete<T extends EBResultsDeleteArgs>(args: SelectSubset<T, EBResultsDeleteArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EBResults.
     * @param {EBResultsUpdateArgs} args - Arguments to update one EBResults.
     * @example
     * // Update one EBResults
     * const eBResults = await prisma.eBResults.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EBResultsUpdateArgs>(args: SelectSubset<T, EBResultsUpdateArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EBResults.
     * @param {EBResultsDeleteManyArgs} args - Arguments to filter EBResults to delete.
     * @example
     * // Delete a few EBResults
     * const { count } = await prisma.eBResults.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EBResultsDeleteManyArgs>(args?: SelectSubset<T, EBResultsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EBResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EBResults
     * const eBResults = await prisma.eBResults.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EBResultsUpdateManyArgs>(args: SelectSubset<T, EBResultsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EBResults.
     * @param {EBResultsUpsertArgs} args - Arguments to update or create a EBResults.
     * @example
     * // Update or create a EBResults
     * const eBResults = await prisma.eBResults.upsert({
     *   create: {
     *     // ... data to create a EBResults
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EBResults we want to update
     *   }
     * })
     */
    upsert<T extends EBResultsUpsertArgs>(args: SelectSubset<T, EBResultsUpsertArgs<ExtArgs>>): Prisma__EBResultsClient<$Result.GetResult<Prisma.$EBResultsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EBResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsCountArgs} args - Arguments to filter EBResults to count.
     * @example
     * // Count the number of EBResults
     * const count = await prisma.eBResults.count({
     *   where: {
     *     // ... the filter for the EBResults we want to count
     *   }
     * })
    **/
    count<T extends EBResultsCountArgs>(
      args?: Subset<T, EBResultsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EBResultsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EBResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EBResultsAggregateArgs>(args: Subset<T, EBResultsAggregateArgs>): Prisma.PrismaPromise<GetEBResultsAggregateType<T>>

    /**
     * Group by EBResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBResultsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EBResultsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EBResultsGroupByArgs['orderBy'] }
        : { orderBy?: EBResultsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EBResultsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEBResultsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EBResults model
   */
  readonly fields: EBResultsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EBResults.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EBResultsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EBResults model
   */
  interface EBResultsFieldRefs {
    readonly id: FieldRef<"EBResults", 'Int'>
    readonly before: FieldRef<"EBResults", 'Json'>
    readonly after: FieldRef<"EBResults", 'Json'>
    readonly savings: FieldRef<"EBResults", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EBResults findUnique
   */
  export type EBResultsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * Filter, which EBResults to fetch.
     */
    where: EBResultsWhereUniqueInput
  }

  /**
   * EBResults findUniqueOrThrow
   */
  export type EBResultsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * Filter, which EBResults to fetch.
     */
    where: EBResultsWhereUniqueInput
  }

  /**
   * EBResults findFirst
   */
  export type EBResultsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * Filter, which EBResults to fetch.
     */
    where?: EBResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBResults to fetch.
     */
    orderBy?: EBResultsOrderByWithRelationInput | EBResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBResults.
     */
    cursor?: EBResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBResults.
     */
    distinct?: EBResultsScalarFieldEnum | EBResultsScalarFieldEnum[]
  }

  /**
   * EBResults findFirstOrThrow
   */
  export type EBResultsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * Filter, which EBResults to fetch.
     */
    where?: EBResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBResults to fetch.
     */
    orderBy?: EBResultsOrderByWithRelationInput | EBResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBResults.
     */
    cursor?: EBResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBResults.
     */
    distinct?: EBResultsScalarFieldEnum | EBResultsScalarFieldEnum[]
  }

  /**
   * EBResults findMany
   */
  export type EBResultsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * Filter, which EBResults to fetch.
     */
    where?: EBResultsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBResults to fetch.
     */
    orderBy?: EBResultsOrderByWithRelationInput | EBResultsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EBResults.
     */
    cursor?: EBResultsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBResults.
     */
    skip?: number
    distinct?: EBResultsScalarFieldEnum | EBResultsScalarFieldEnum[]
  }

  /**
   * EBResults create
   */
  export type EBResultsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * The data needed to create a EBResults.
     */
    data?: XOR<EBResultsCreateInput, EBResultsUncheckedCreateInput>
  }

  /**
   * EBResults createMany
   */
  export type EBResultsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EBResults.
     */
    data: EBResultsCreateManyInput | EBResultsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EBResults update
   */
  export type EBResultsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * The data needed to update a EBResults.
     */
    data: XOR<EBResultsUpdateInput, EBResultsUncheckedUpdateInput>
    /**
     * Choose, which EBResults to update.
     */
    where: EBResultsWhereUniqueInput
  }

  /**
   * EBResults updateMany
   */
  export type EBResultsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EBResults.
     */
    data: XOR<EBResultsUpdateManyMutationInput, EBResultsUncheckedUpdateManyInput>
    /**
     * Filter which EBResults to update
     */
    where?: EBResultsWhereInput
    /**
     * Limit how many EBResults to update.
     */
    limit?: number
  }

  /**
   * EBResults upsert
   */
  export type EBResultsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * The filter to search for the EBResults to update in case it exists.
     */
    where: EBResultsWhereUniqueInput
    /**
     * In case the EBResults found by the `where` argument doesn't exist, create a new EBResults with this data.
     */
    create: XOR<EBResultsCreateInput, EBResultsUncheckedCreateInput>
    /**
     * In case the EBResults was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EBResultsUpdateInput, EBResultsUncheckedUpdateInput>
  }

  /**
   * EBResults delete
   */
  export type EBResultsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
    /**
     * Filter which EBResults to delete.
     */
    where: EBResultsWhereUniqueInput
  }

  /**
   * EBResults deleteMany
   */
  export type EBResultsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBResults to delete
     */
    where?: EBResultsWhereInput
    /**
     * Limit how many EBResults to delete.
     */
    limit?: number
  }

  /**
   * EBResults without action
   */
  export type EBResultsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBResults
     */
    select?: EBResultsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBResults
     */
    omit?: EBResultsOmit<ExtArgs> | null
  }


  /**
   * Model EBTrendChart
   */

  export type AggregateEBTrendChart = {
    _count: EBTrendChartCountAggregateOutputType | null
    _avg: EBTrendChartAvgAggregateOutputType | null
    _sum: EBTrendChartSumAggregateOutputType | null
    _min: EBTrendChartMinAggregateOutputType | null
    _max: EBTrendChartMaxAggregateOutputType | null
  }

  export type EBTrendChartAvgAggregateOutputType = {
    id: number | null
  }

  export type EBTrendChartSumAggregateOutputType = {
    id: number | null
  }

  export type EBTrendChartMinAggregateOutputType = {
    id: number | null
    time: string | null
    generation: string | null
    consumption: string | null
  }

  export type EBTrendChartMaxAggregateOutputType = {
    id: number | null
    time: string | null
    generation: string | null
    consumption: string | null
  }

  export type EBTrendChartCountAggregateOutputType = {
    id: number
    time: number
    generation: number
    consumption: number
    _all: number
  }


  export type EBTrendChartAvgAggregateInputType = {
    id?: true
  }

  export type EBTrendChartSumAggregateInputType = {
    id?: true
  }

  export type EBTrendChartMinAggregateInputType = {
    id?: true
    time?: true
    generation?: true
    consumption?: true
  }

  export type EBTrendChartMaxAggregateInputType = {
    id?: true
    time?: true
    generation?: true
    consumption?: true
  }

  export type EBTrendChartCountAggregateInputType = {
    id?: true
    time?: true
    generation?: true
    consumption?: true
    _all?: true
  }

  export type EBTrendChartAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBTrendChart to aggregate.
     */
    where?: EBTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBTrendCharts to fetch.
     */
    orderBy?: EBTrendChartOrderByWithRelationInput | EBTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EBTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBTrendCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EBTrendCharts
    **/
    _count?: true | EBTrendChartCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EBTrendChartAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EBTrendChartSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EBTrendChartMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EBTrendChartMaxAggregateInputType
  }

  export type GetEBTrendChartAggregateType<T extends EBTrendChartAggregateArgs> = {
        [P in keyof T & keyof AggregateEBTrendChart]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEBTrendChart[P]>
      : GetScalarType<T[P], AggregateEBTrendChart[P]>
  }




  export type EBTrendChartGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EBTrendChartWhereInput
    orderBy?: EBTrendChartOrderByWithAggregationInput | EBTrendChartOrderByWithAggregationInput[]
    by: EBTrendChartScalarFieldEnum[] | EBTrendChartScalarFieldEnum
    having?: EBTrendChartScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EBTrendChartCountAggregateInputType | true
    _avg?: EBTrendChartAvgAggregateInputType
    _sum?: EBTrendChartSumAggregateInputType
    _min?: EBTrendChartMinAggregateInputType
    _max?: EBTrendChartMaxAggregateInputType
  }

  export type EBTrendChartGroupByOutputType = {
    id: number
    time: string | null
    generation: string | null
    consumption: string | null
    _count: EBTrendChartCountAggregateOutputType | null
    _avg: EBTrendChartAvgAggregateOutputType | null
    _sum: EBTrendChartSumAggregateOutputType | null
    _min: EBTrendChartMinAggregateOutputType | null
    _max: EBTrendChartMaxAggregateOutputType | null
  }

  type GetEBTrendChartGroupByPayload<T extends EBTrendChartGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EBTrendChartGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EBTrendChartGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EBTrendChartGroupByOutputType[P]>
            : GetScalarType<T[P], EBTrendChartGroupByOutputType[P]>
        }
      >
    >


  export type EBTrendChartSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    time?: boolean
    generation?: boolean
    consumption?: boolean
  }, ExtArgs["result"]["eBTrendChart"]>



  export type EBTrendChartSelectScalar = {
    id?: boolean
    time?: boolean
    generation?: boolean
    consumption?: boolean
  }

  export type EBTrendChartOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "time" | "generation" | "consumption", ExtArgs["result"]["eBTrendChart"]>

  export type $EBTrendChartPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EBTrendChart"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      time: string | null
      generation: string | null
      consumption: string | null
    }, ExtArgs["result"]["eBTrendChart"]>
    composites: {}
  }

  type EBTrendChartGetPayload<S extends boolean | null | undefined | EBTrendChartDefaultArgs> = $Result.GetResult<Prisma.$EBTrendChartPayload, S>

  type EBTrendChartCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EBTrendChartFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EBTrendChartCountAggregateInputType | true
    }

  export interface EBTrendChartDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EBTrendChart'], meta: { name: 'EBTrendChart' } }
    /**
     * Find zero or one EBTrendChart that matches the filter.
     * @param {EBTrendChartFindUniqueArgs} args - Arguments to find a EBTrendChart
     * @example
     * // Get one EBTrendChart
     * const eBTrendChart = await prisma.eBTrendChart.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EBTrendChartFindUniqueArgs>(args: SelectSubset<T, EBTrendChartFindUniqueArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EBTrendChart that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EBTrendChartFindUniqueOrThrowArgs} args - Arguments to find a EBTrendChart
     * @example
     * // Get one EBTrendChart
     * const eBTrendChart = await prisma.eBTrendChart.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EBTrendChartFindUniqueOrThrowArgs>(args: SelectSubset<T, EBTrendChartFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBTrendChart that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartFindFirstArgs} args - Arguments to find a EBTrendChart
     * @example
     * // Get one EBTrendChart
     * const eBTrendChart = await prisma.eBTrendChart.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EBTrendChartFindFirstArgs>(args?: SelectSubset<T, EBTrendChartFindFirstArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EBTrendChart that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartFindFirstOrThrowArgs} args - Arguments to find a EBTrendChart
     * @example
     * // Get one EBTrendChart
     * const eBTrendChart = await prisma.eBTrendChart.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EBTrendChartFindFirstOrThrowArgs>(args?: SelectSubset<T, EBTrendChartFindFirstOrThrowArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EBTrendCharts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EBTrendCharts
     * const eBTrendCharts = await prisma.eBTrendChart.findMany()
     * 
     * // Get first 10 EBTrendCharts
     * const eBTrendCharts = await prisma.eBTrendChart.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eBTrendChartWithIdOnly = await prisma.eBTrendChart.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EBTrendChartFindManyArgs>(args?: SelectSubset<T, EBTrendChartFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EBTrendChart.
     * @param {EBTrendChartCreateArgs} args - Arguments to create a EBTrendChart.
     * @example
     * // Create one EBTrendChart
     * const EBTrendChart = await prisma.eBTrendChart.create({
     *   data: {
     *     // ... data to create a EBTrendChart
     *   }
     * })
     * 
     */
    create<T extends EBTrendChartCreateArgs>(args: SelectSubset<T, EBTrendChartCreateArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EBTrendCharts.
     * @param {EBTrendChartCreateManyArgs} args - Arguments to create many EBTrendCharts.
     * @example
     * // Create many EBTrendCharts
     * const eBTrendChart = await prisma.eBTrendChart.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EBTrendChartCreateManyArgs>(args?: SelectSubset<T, EBTrendChartCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EBTrendChart.
     * @param {EBTrendChartDeleteArgs} args - Arguments to delete one EBTrendChart.
     * @example
     * // Delete one EBTrendChart
     * const EBTrendChart = await prisma.eBTrendChart.delete({
     *   where: {
     *     // ... filter to delete one EBTrendChart
     *   }
     * })
     * 
     */
    delete<T extends EBTrendChartDeleteArgs>(args: SelectSubset<T, EBTrendChartDeleteArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EBTrendChart.
     * @param {EBTrendChartUpdateArgs} args - Arguments to update one EBTrendChart.
     * @example
     * // Update one EBTrendChart
     * const eBTrendChart = await prisma.eBTrendChart.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EBTrendChartUpdateArgs>(args: SelectSubset<T, EBTrendChartUpdateArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EBTrendCharts.
     * @param {EBTrendChartDeleteManyArgs} args - Arguments to filter EBTrendCharts to delete.
     * @example
     * // Delete a few EBTrendCharts
     * const { count } = await prisma.eBTrendChart.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EBTrendChartDeleteManyArgs>(args?: SelectSubset<T, EBTrendChartDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EBTrendCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EBTrendCharts
     * const eBTrendChart = await prisma.eBTrendChart.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EBTrendChartUpdateManyArgs>(args: SelectSubset<T, EBTrendChartUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EBTrendChart.
     * @param {EBTrendChartUpsertArgs} args - Arguments to update or create a EBTrendChart.
     * @example
     * // Update or create a EBTrendChart
     * const eBTrendChart = await prisma.eBTrendChart.upsert({
     *   create: {
     *     // ... data to create a EBTrendChart
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EBTrendChart we want to update
     *   }
     * })
     */
    upsert<T extends EBTrendChartUpsertArgs>(args: SelectSubset<T, EBTrendChartUpsertArgs<ExtArgs>>): Prisma__EBTrendChartClient<$Result.GetResult<Prisma.$EBTrendChartPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EBTrendCharts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartCountArgs} args - Arguments to filter EBTrendCharts to count.
     * @example
     * // Count the number of EBTrendCharts
     * const count = await prisma.eBTrendChart.count({
     *   where: {
     *     // ... the filter for the EBTrendCharts we want to count
     *   }
     * })
    **/
    count<T extends EBTrendChartCountArgs>(
      args?: Subset<T, EBTrendChartCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EBTrendChartCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EBTrendChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EBTrendChartAggregateArgs>(args: Subset<T, EBTrendChartAggregateArgs>): Prisma.PrismaPromise<GetEBTrendChartAggregateType<T>>

    /**
     * Group by EBTrendChart.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EBTrendChartGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EBTrendChartGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EBTrendChartGroupByArgs['orderBy'] }
        : { orderBy?: EBTrendChartGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EBTrendChartGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEBTrendChartGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EBTrendChart model
   */
  readonly fields: EBTrendChartFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EBTrendChart.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EBTrendChartClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EBTrendChart model
   */
  interface EBTrendChartFieldRefs {
    readonly id: FieldRef<"EBTrendChart", 'Int'>
    readonly time: FieldRef<"EBTrendChart", 'String'>
    readonly generation: FieldRef<"EBTrendChart", 'String'>
    readonly consumption: FieldRef<"EBTrendChart", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EBTrendChart findUnique
   */
  export type EBTrendChartFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which EBTrendChart to fetch.
     */
    where: EBTrendChartWhereUniqueInput
  }

  /**
   * EBTrendChart findUniqueOrThrow
   */
  export type EBTrendChartFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which EBTrendChart to fetch.
     */
    where: EBTrendChartWhereUniqueInput
  }

  /**
   * EBTrendChart findFirst
   */
  export type EBTrendChartFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which EBTrendChart to fetch.
     */
    where?: EBTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBTrendCharts to fetch.
     */
    orderBy?: EBTrendChartOrderByWithRelationInput | EBTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBTrendCharts.
     */
    cursor?: EBTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBTrendCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBTrendCharts.
     */
    distinct?: EBTrendChartScalarFieldEnum | EBTrendChartScalarFieldEnum[]
  }

  /**
   * EBTrendChart findFirstOrThrow
   */
  export type EBTrendChartFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which EBTrendChart to fetch.
     */
    where?: EBTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBTrendCharts to fetch.
     */
    orderBy?: EBTrendChartOrderByWithRelationInput | EBTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EBTrendCharts.
     */
    cursor?: EBTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBTrendCharts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EBTrendCharts.
     */
    distinct?: EBTrendChartScalarFieldEnum | EBTrendChartScalarFieldEnum[]
  }

  /**
   * EBTrendChart findMany
   */
  export type EBTrendChartFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * Filter, which EBTrendCharts to fetch.
     */
    where?: EBTrendChartWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EBTrendCharts to fetch.
     */
    orderBy?: EBTrendChartOrderByWithRelationInput | EBTrendChartOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EBTrendCharts.
     */
    cursor?: EBTrendChartWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EBTrendCharts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EBTrendCharts.
     */
    skip?: number
    distinct?: EBTrendChartScalarFieldEnum | EBTrendChartScalarFieldEnum[]
  }

  /**
   * EBTrendChart create
   */
  export type EBTrendChartCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * The data needed to create a EBTrendChart.
     */
    data?: XOR<EBTrendChartCreateInput, EBTrendChartUncheckedCreateInput>
  }

  /**
   * EBTrendChart createMany
   */
  export type EBTrendChartCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EBTrendCharts.
     */
    data: EBTrendChartCreateManyInput | EBTrendChartCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EBTrendChart update
   */
  export type EBTrendChartUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * The data needed to update a EBTrendChart.
     */
    data: XOR<EBTrendChartUpdateInput, EBTrendChartUncheckedUpdateInput>
    /**
     * Choose, which EBTrendChart to update.
     */
    where: EBTrendChartWhereUniqueInput
  }

  /**
   * EBTrendChart updateMany
   */
  export type EBTrendChartUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EBTrendCharts.
     */
    data: XOR<EBTrendChartUpdateManyMutationInput, EBTrendChartUncheckedUpdateManyInput>
    /**
     * Filter which EBTrendCharts to update
     */
    where?: EBTrendChartWhereInput
    /**
     * Limit how many EBTrendCharts to update.
     */
    limit?: number
  }

  /**
   * EBTrendChart upsert
   */
  export type EBTrendChartUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * The filter to search for the EBTrendChart to update in case it exists.
     */
    where: EBTrendChartWhereUniqueInput
    /**
     * In case the EBTrendChart found by the `where` argument doesn't exist, create a new EBTrendChart with this data.
     */
    create: XOR<EBTrendChartCreateInput, EBTrendChartUncheckedCreateInput>
    /**
     * In case the EBTrendChart was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EBTrendChartUpdateInput, EBTrendChartUncheckedUpdateInput>
  }

  /**
   * EBTrendChart delete
   */
  export type EBTrendChartDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
    /**
     * Filter which EBTrendChart to delete.
     */
    where: EBTrendChartWhereUniqueInput
  }

  /**
   * EBTrendChart deleteMany
   */
  export type EBTrendChartDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EBTrendCharts to delete
     */
    where?: EBTrendChartWhereInput
    /**
     * Limit how many EBTrendCharts to delete.
     */
    limit?: number
  }

  /**
   * EBTrendChart without action
   */
  export type EBTrendChartDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EBTrendChart
     */
    select?: EBTrendChartSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EBTrendChart
     */
    omit?: EBTrendChartOmit<ExtArgs> | null
  }


  /**
   * Model ECenergyFlowRealTime
   */

  export type AggregateECenergyFlowRealTime = {
    _count: ECenergyFlowRealTimeCountAggregateOutputType | null
    _avg: ECenergyFlowRealTimeAvgAggregateOutputType | null
    _sum: ECenergyFlowRealTimeSumAggregateOutputType | null
    _min: ECenergyFlowRealTimeMinAggregateOutputType | null
    _max: ECenergyFlowRealTimeMaxAggregateOutputType | null
  }

  export type ECenergyFlowRealTimeAvgAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type ECenergyFlowRealTimeSumAggregateOutputType = {
    id: number | null
    device_id: number | null
  }

  export type ECenergyFlowRealTimeMinAggregateOutputType = {
    id: number | null
    device_id: number | null
    energy_type_id: string | null
    flow_value: string | null
    temperature: string | null
    pressure: string | null
    timestamp: string | null
  }

  export type ECenergyFlowRealTimeMaxAggregateOutputType = {
    id: number | null
    device_id: number | null
    energy_type_id: string | null
    flow_value: string | null
    temperature: string | null
    pressure: string | null
    timestamp: string | null
  }

  export type ECenergyFlowRealTimeCountAggregateOutputType = {
    id: number
    device_id: number
    energy_type_id: number
    flow_value: number
    temperature: number
    pressure: number
    timestamp: number
    _all: number
  }


  export type ECenergyFlowRealTimeAvgAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type ECenergyFlowRealTimeSumAggregateInputType = {
    id?: true
    device_id?: true
  }

  export type ECenergyFlowRealTimeMinAggregateInputType = {
    id?: true
    device_id?: true
    energy_type_id?: true
    flow_value?: true
    temperature?: true
    pressure?: true
    timestamp?: true
  }

  export type ECenergyFlowRealTimeMaxAggregateInputType = {
    id?: true
    device_id?: true
    energy_type_id?: true
    flow_value?: true
    temperature?: true
    pressure?: true
    timestamp?: true
  }

  export type ECenergyFlowRealTimeCountAggregateInputType = {
    id?: true
    device_id?: true
    energy_type_id?: true
    flow_value?: true
    temperature?: true
    pressure?: true
    timestamp?: true
    _all?: true
  }

  export type ECenergyFlowRealTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ECenergyFlowRealTime to aggregate.
     */
    where?: ECenergyFlowRealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyFlowRealTimes to fetch.
     */
    orderBy?: ECenergyFlowRealTimeOrderByWithRelationInput | ECenergyFlowRealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ECenergyFlowRealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyFlowRealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyFlowRealTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ECenergyFlowRealTimes
    **/
    _count?: true | ECenergyFlowRealTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ECenergyFlowRealTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ECenergyFlowRealTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ECenergyFlowRealTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ECenergyFlowRealTimeMaxAggregateInputType
  }

  export type GetECenergyFlowRealTimeAggregateType<T extends ECenergyFlowRealTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateECenergyFlowRealTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateECenergyFlowRealTime[P]>
      : GetScalarType<T[P], AggregateECenergyFlowRealTime[P]>
  }




  export type ECenergyFlowRealTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ECenergyFlowRealTimeWhereInput
    orderBy?: ECenergyFlowRealTimeOrderByWithAggregationInput | ECenergyFlowRealTimeOrderByWithAggregationInput[]
    by: ECenergyFlowRealTimeScalarFieldEnum[] | ECenergyFlowRealTimeScalarFieldEnum
    having?: ECenergyFlowRealTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ECenergyFlowRealTimeCountAggregateInputType | true
    _avg?: ECenergyFlowRealTimeAvgAggregateInputType
    _sum?: ECenergyFlowRealTimeSumAggregateInputType
    _min?: ECenergyFlowRealTimeMinAggregateInputType
    _max?: ECenergyFlowRealTimeMaxAggregateInputType
  }

  export type ECenergyFlowRealTimeGroupByOutputType = {
    id: number
    device_id: number | null
    energy_type_id: string | null
    flow_value: string | null
    temperature: string | null
    pressure: string | null
    timestamp: string | null
    _count: ECenergyFlowRealTimeCountAggregateOutputType | null
    _avg: ECenergyFlowRealTimeAvgAggregateOutputType | null
    _sum: ECenergyFlowRealTimeSumAggregateOutputType | null
    _min: ECenergyFlowRealTimeMinAggregateOutputType | null
    _max: ECenergyFlowRealTimeMaxAggregateOutputType | null
  }

  type GetECenergyFlowRealTimeGroupByPayload<T extends ECenergyFlowRealTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ECenergyFlowRealTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ECenergyFlowRealTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ECenergyFlowRealTimeGroupByOutputType[P]>
            : GetScalarType<T[P], ECenergyFlowRealTimeGroupByOutputType[P]>
        }
      >
    >


  export type ECenergyFlowRealTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    device_id?: boolean
    energy_type_id?: boolean
    flow_value?: boolean
    temperature?: boolean
    pressure?: boolean
    timestamp?: boolean
  }, ExtArgs["result"]["eCenergyFlowRealTime"]>



  export type ECenergyFlowRealTimeSelectScalar = {
    id?: boolean
    device_id?: boolean
    energy_type_id?: boolean
    flow_value?: boolean
    temperature?: boolean
    pressure?: boolean
    timestamp?: boolean
  }

  export type ECenergyFlowRealTimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "device_id" | "energy_type_id" | "flow_value" | "temperature" | "pressure" | "timestamp", ExtArgs["result"]["eCenergyFlowRealTime"]>

  export type $ECenergyFlowRealTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ECenergyFlowRealTime"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      device_id: number | null
      energy_type_id: string | null
      flow_value: string | null
      temperature: string | null
      pressure: string | null
      timestamp: string | null
    }, ExtArgs["result"]["eCenergyFlowRealTime"]>
    composites: {}
  }

  type ECenergyFlowRealTimeGetPayload<S extends boolean | null | undefined | ECenergyFlowRealTimeDefaultArgs> = $Result.GetResult<Prisma.$ECenergyFlowRealTimePayload, S>

  type ECenergyFlowRealTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ECenergyFlowRealTimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ECenergyFlowRealTimeCountAggregateInputType | true
    }

  export interface ECenergyFlowRealTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ECenergyFlowRealTime'], meta: { name: 'ECenergyFlowRealTime' } }
    /**
     * Find zero or one ECenergyFlowRealTime that matches the filter.
     * @param {ECenergyFlowRealTimeFindUniqueArgs} args - Arguments to find a ECenergyFlowRealTime
     * @example
     * // Get one ECenergyFlowRealTime
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ECenergyFlowRealTimeFindUniqueArgs>(args: SelectSubset<T, ECenergyFlowRealTimeFindUniqueArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ECenergyFlowRealTime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ECenergyFlowRealTimeFindUniqueOrThrowArgs} args - Arguments to find a ECenergyFlowRealTime
     * @example
     * // Get one ECenergyFlowRealTime
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ECenergyFlowRealTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, ECenergyFlowRealTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ECenergyFlowRealTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeFindFirstArgs} args - Arguments to find a ECenergyFlowRealTime
     * @example
     * // Get one ECenergyFlowRealTime
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ECenergyFlowRealTimeFindFirstArgs>(args?: SelectSubset<T, ECenergyFlowRealTimeFindFirstArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ECenergyFlowRealTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeFindFirstOrThrowArgs} args - Arguments to find a ECenergyFlowRealTime
     * @example
     * // Get one ECenergyFlowRealTime
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ECenergyFlowRealTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, ECenergyFlowRealTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ECenergyFlowRealTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ECenergyFlowRealTimes
     * const eCenergyFlowRealTimes = await prisma.eCenergyFlowRealTime.findMany()
     * 
     * // Get first 10 ECenergyFlowRealTimes
     * const eCenergyFlowRealTimes = await prisma.eCenergyFlowRealTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eCenergyFlowRealTimeWithIdOnly = await prisma.eCenergyFlowRealTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ECenergyFlowRealTimeFindManyArgs>(args?: SelectSubset<T, ECenergyFlowRealTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ECenergyFlowRealTime.
     * @param {ECenergyFlowRealTimeCreateArgs} args - Arguments to create a ECenergyFlowRealTime.
     * @example
     * // Create one ECenergyFlowRealTime
     * const ECenergyFlowRealTime = await prisma.eCenergyFlowRealTime.create({
     *   data: {
     *     // ... data to create a ECenergyFlowRealTime
     *   }
     * })
     * 
     */
    create<T extends ECenergyFlowRealTimeCreateArgs>(args: SelectSubset<T, ECenergyFlowRealTimeCreateArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ECenergyFlowRealTimes.
     * @param {ECenergyFlowRealTimeCreateManyArgs} args - Arguments to create many ECenergyFlowRealTimes.
     * @example
     * // Create many ECenergyFlowRealTimes
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ECenergyFlowRealTimeCreateManyArgs>(args?: SelectSubset<T, ECenergyFlowRealTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ECenergyFlowRealTime.
     * @param {ECenergyFlowRealTimeDeleteArgs} args - Arguments to delete one ECenergyFlowRealTime.
     * @example
     * // Delete one ECenergyFlowRealTime
     * const ECenergyFlowRealTime = await prisma.eCenergyFlowRealTime.delete({
     *   where: {
     *     // ... filter to delete one ECenergyFlowRealTime
     *   }
     * })
     * 
     */
    delete<T extends ECenergyFlowRealTimeDeleteArgs>(args: SelectSubset<T, ECenergyFlowRealTimeDeleteArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ECenergyFlowRealTime.
     * @param {ECenergyFlowRealTimeUpdateArgs} args - Arguments to update one ECenergyFlowRealTime.
     * @example
     * // Update one ECenergyFlowRealTime
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ECenergyFlowRealTimeUpdateArgs>(args: SelectSubset<T, ECenergyFlowRealTimeUpdateArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ECenergyFlowRealTimes.
     * @param {ECenergyFlowRealTimeDeleteManyArgs} args - Arguments to filter ECenergyFlowRealTimes to delete.
     * @example
     * // Delete a few ECenergyFlowRealTimes
     * const { count } = await prisma.eCenergyFlowRealTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ECenergyFlowRealTimeDeleteManyArgs>(args?: SelectSubset<T, ECenergyFlowRealTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ECenergyFlowRealTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ECenergyFlowRealTimes
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ECenergyFlowRealTimeUpdateManyArgs>(args: SelectSubset<T, ECenergyFlowRealTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ECenergyFlowRealTime.
     * @param {ECenergyFlowRealTimeUpsertArgs} args - Arguments to update or create a ECenergyFlowRealTime.
     * @example
     * // Update or create a ECenergyFlowRealTime
     * const eCenergyFlowRealTime = await prisma.eCenergyFlowRealTime.upsert({
     *   create: {
     *     // ... data to create a ECenergyFlowRealTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ECenergyFlowRealTime we want to update
     *   }
     * })
     */
    upsert<T extends ECenergyFlowRealTimeUpsertArgs>(args: SelectSubset<T, ECenergyFlowRealTimeUpsertArgs<ExtArgs>>): Prisma__ECenergyFlowRealTimeClient<$Result.GetResult<Prisma.$ECenergyFlowRealTimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ECenergyFlowRealTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeCountArgs} args - Arguments to filter ECenergyFlowRealTimes to count.
     * @example
     * // Count the number of ECenergyFlowRealTimes
     * const count = await prisma.eCenergyFlowRealTime.count({
     *   where: {
     *     // ... the filter for the ECenergyFlowRealTimes we want to count
     *   }
     * })
    **/
    count<T extends ECenergyFlowRealTimeCountArgs>(
      args?: Subset<T, ECenergyFlowRealTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ECenergyFlowRealTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ECenergyFlowRealTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ECenergyFlowRealTimeAggregateArgs>(args: Subset<T, ECenergyFlowRealTimeAggregateArgs>): Prisma.PrismaPromise<GetECenergyFlowRealTimeAggregateType<T>>

    /**
     * Group by ECenergyFlowRealTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyFlowRealTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ECenergyFlowRealTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ECenergyFlowRealTimeGroupByArgs['orderBy'] }
        : { orderBy?: ECenergyFlowRealTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ECenergyFlowRealTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetECenergyFlowRealTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ECenergyFlowRealTime model
   */
  readonly fields: ECenergyFlowRealTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ECenergyFlowRealTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ECenergyFlowRealTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ECenergyFlowRealTime model
   */
  interface ECenergyFlowRealTimeFieldRefs {
    readonly id: FieldRef<"ECenergyFlowRealTime", 'Int'>
    readonly device_id: FieldRef<"ECenergyFlowRealTime", 'Int'>
    readonly energy_type_id: FieldRef<"ECenergyFlowRealTime", 'String'>
    readonly flow_value: FieldRef<"ECenergyFlowRealTime", 'String'>
    readonly temperature: FieldRef<"ECenergyFlowRealTime", 'String'>
    readonly pressure: FieldRef<"ECenergyFlowRealTime", 'String'>
    readonly timestamp: FieldRef<"ECenergyFlowRealTime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ECenergyFlowRealTime findUnique
   */
  export type ECenergyFlowRealTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyFlowRealTime to fetch.
     */
    where: ECenergyFlowRealTimeWhereUniqueInput
  }

  /**
   * ECenergyFlowRealTime findUniqueOrThrow
   */
  export type ECenergyFlowRealTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyFlowRealTime to fetch.
     */
    where: ECenergyFlowRealTimeWhereUniqueInput
  }

  /**
   * ECenergyFlowRealTime findFirst
   */
  export type ECenergyFlowRealTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyFlowRealTime to fetch.
     */
    where?: ECenergyFlowRealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyFlowRealTimes to fetch.
     */
    orderBy?: ECenergyFlowRealTimeOrderByWithRelationInput | ECenergyFlowRealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ECenergyFlowRealTimes.
     */
    cursor?: ECenergyFlowRealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyFlowRealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyFlowRealTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ECenergyFlowRealTimes.
     */
    distinct?: ECenergyFlowRealTimeScalarFieldEnum | ECenergyFlowRealTimeScalarFieldEnum[]
  }

  /**
   * ECenergyFlowRealTime findFirstOrThrow
   */
  export type ECenergyFlowRealTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyFlowRealTime to fetch.
     */
    where?: ECenergyFlowRealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyFlowRealTimes to fetch.
     */
    orderBy?: ECenergyFlowRealTimeOrderByWithRelationInput | ECenergyFlowRealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ECenergyFlowRealTimes.
     */
    cursor?: ECenergyFlowRealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyFlowRealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyFlowRealTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ECenergyFlowRealTimes.
     */
    distinct?: ECenergyFlowRealTimeScalarFieldEnum | ECenergyFlowRealTimeScalarFieldEnum[]
  }

  /**
   * ECenergyFlowRealTime findMany
   */
  export type ECenergyFlowRealTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyFlowRealTimes to fetch.
     */
    where?: ECenergyFlowRealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyFlowRealTimes to fetch.
     */
    orderBy?: ECenergyFlowRealTimeOrderByWithRelationInput | ECenergyFlowRealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ECenergyFlowRealTimes.
     */
    cursor?: ECenergyFlowRealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyFlowRealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyFlowRealTimes.
     */
    skip?: number
    distinct?: ECenergyFlowRealTimeScalarFieldEnum | ECenergyFlowRealTimeScalarFieldEnum[]
  }

  /**
   * ECenergyFlowRealTime create
   */
  export type ECenergyFlowRealTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * The data needed to create a ECenergyFlowRealTime.
     */
    data?: XOR<ECenergyFlowRealTimeCreateInput, ECenergyFlowRealTimeUncheckedCreateInput>
  }

  /**
   * ECenergyFlowRealTime createMany
   */
  export type ECenergyFlowRealTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ECenergyFlowRealTimes.
     */
    data: ECenergyFlowRealTimeCreateManyInput | ECenergyFlowRealTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ECenergyFlowRealTime update
   */
  export type ECenergyFlowRealTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * The data needed to update a ECenergyFlowRealTime.
     */
    data: XOR<ECenergyFlowRealTimeUpdateInput, ECenergyFlowRealTimeUncheckedUpdateInput>
    /**
     * Choose, which ECenergyFlowRealTime to update.
     */
    where: ECenergyFlowRealTimeWhereUniqueInput
  }

  /**
   * ECenergyFlowRealTime updateMany
   */
  export type ECenergyFlowRealTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ECenergyFlowRealTimes.
     */
    data: XOR<ECenergyFlowRealTimeUpdateManyMutationInput, ECenergyFlowRealTimeUncheckedUpdateManyInput>
    /**
     * Filter which ECenergyFlowRealTimes to update
     */
    where?: ECenergyFlowRealTimeWhereInput
    /**
     * Limit how many ECenergyFlowRealTimes to update.
     */
    limit?: number
  }

  /**
   * ECenergyFlowRealTime upsert
   */
  export type ECenergyFlowRealTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * The filter to search for the ECenergyFlowRealTime to update in case it exists.
     */
    where: ECenergyFlowRealTimeWhereUniqueInput
    /**
     * In case the ECenergyFlowRealTime found by the `where` argument doesn't exist, create a new ECenergyFlowRealTime with this data.
     */
    create: XOR<ECenergyFlowRealTimeCreateInput, ECenergyFlowRealTimeUncheckedCreateInput>
    /**
     * In case the ECenergyFlowRealTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ECenergyFlowRealTimeUpdateInput, ECenergyFlowRealTimeUncheckedUpdateInput>
  }

  /**
   * ECenergyFlowRealTime delete
   */
  export type ECenergyFlowRealTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
    /**
     * Filter which ECenergyFlowRealTime to delete.
     */
    where: ECenergyFlowRealTimeWhereUniqueInput
  }

  /**
   * ECenergyFlowRealTime deleteMany
   */
  export type ECenergyFlowRealTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ECenergyFlowRealTimes to delete
     */
    where?: ECenergyFlowRealTimeWhereInput
    /**
     * Limit how many ECenergyFlowRealTimes to delete.
     */
    limit?: number
  }

  /**
   * ECenergyFlowRealTime without action
   */
  export type ECenergyFlowRealTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyFlowRealTime
     */
    select?: ECenergyFlowRealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyFlowRealTime
     */
    omit?: ECenergyFlowRealTimeOmit<ExtArgs> | null
  }


  /**
   * Model ECenergyTypes
   */

  export type AggregateECenergyTypes = {
    _count: ECenergyTypesCountAggregateOutputType | null
    _avg: ECenergyTypesAvgAggregateOutputType | null
    _sum: ECenergyTypesSumAggregateOutputType | null
    _min: ECenergyTypesMinAggregateOutputType | null
    _max: ECenergyTypesMaxAggregateOutputType | null
  }

  export type ECenergyTypesAvgAggregateOutputType = {
    id: number | null
  }

  export type ECenergyTypesSumAggregateOutputType = {
    id: number | null
  }

  export type ECenergyTypesMinAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    unit: string | null
    icon: string | null
    conversion_factor: string | null
    created_at: string | null
  }

  export type ECenergyTypesMaxAggregateOutputType = {
    id: number | null
    type: string | null
    name: string | null
    unit: string | null
    icon: string | null
    conversion_factor: string | null
    created_at: string | null
  }

  export type ECenergyTypesCountAggregateOutputType = {
    id: number
    type: number
    name: number
    unit: number
    icon: number
    conversion_factor: number
    created_at: number
    _all: number
  }


  export type ECenergyTypesAvgAggregateInputType = {
    id?: true
  }

  export type ECenergyTypesSumAggregateInputType = {
    id?: true
  }

  export type ECenergyTypesMinAggregateInputType = {
    id?: true
    type?: true
    name?: true
    unit?: true
    icon?: true
    conversion_factor?: true
    created_at?: true
  }

  export type ECenergyTypesMaxAggregateInputType = {
    id?: true
    type?: true
    name?: true
    unit?: true
    icon?: true
    conversion_factor?: true
    created_at?: true
  }

  export type ECenergyTypesCountAggregateInputType = {
    id?: true
    type?: true
    name?: true
    unit?: true
    icon?: true
    conversion_factor?: true
    created_at?: true
    _all?: true
  }

  export type ECenergyTypesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ECenergyTypes to aggregate.
     */
    where?: ECenergyTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyTypes to fetch.
     */
    orderBy?: ECenergyTypesOrderByWithRelationInput | ECenergyTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ECenergyTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ECenergyTypes
    **/
    _count?: true | ECenergyTypesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ECenergyTypesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ECenergyTypesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ECenergyTypesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ECenergyTypesMaxAggregateInputType
  }

  export type GetECenergyTypesAggregateType<T extends ECenergyTypesAggregateArgs> = {
        [P in keyof T & keyof AggregateECenergyTypes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateECenergyTypes[P]>
      : GetScalarType<T[P], AggregateECenergyTypes[P]>
  }




  export type ECenergyTypesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ECenergyTypesWhereInput
    orderBy?: ECenergyTypesOrderByWithAggregationInput | ECenergyTypesOrderByWithAggregationInput[]
    by: ECenergyTypesScalarFieldEnum[] | ECenergyTypesScalarFieldEnum
    having?: ECenergyTypesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ECenergyTypesCountAggregateInputType | true
    _avg?: ECenergyTypesAvgAggregateInputType
    _sum?: ECenergyTypesSumAggregateInputType
    _min?: ECenergyTypesMinAggregateInputType
    _max?: ECenergyTypesMaxAggregateInputType
  }

  export type ECenergyTypesGroupByOutputType = {
    id: number
    type: string | null
    name: string | null
    unit: string | null
    icon: string | null
    conversion_factor: string | null
    created_at: string | null
    _count: ECenergyTypesCountAggregateOutputType | null
    _avg: ECenergyTypesAvgAggregateOutputType | null
    _sum: ECenergyTypesSumAggregateOutputType | null
    _min: ECenergyTypesMinAggregateOutputType | null
    _max: ECenergyTypesMaxAggregateOutputType | null
  }

  type GetECenergyTypesGroupByPayload<T extends ECenergyTypesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ECenergyTypesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ECenergyTypesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ECenergyTypesGroupByOutputType[P]>
            : GetScalarType<T[P], ECenergyTypesGroupByOutputType[P]>
        }
      >
    >


  export type ECenergyTypesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    name?: boolean
    unit?: boolean
    icon?: boolean
    conversion_factor?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["eCenergyTypes"]>



  export type ECenergyTypesSelectScalar = {
    id?: boolean
    type?: boolean
    name?: boolean
    unit?: boolean
    icon?: boolean
    conversion_factor?: boolean
    created_at?: boolean
  }

  export type ECenergyTypesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "name" | "unit" | "icon" | "conversion_factor" | "created_at", ExtArgs["result"]["eCenergyTypes"]>

  export type $ECenergyTypesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ECenergyTypes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      type: string | null
      name: string | null
      unit: string | null
      icon: string | null
      conversion_factor: string | null
      created_at: string | null
    }, ExtArgs["result"]["eCenergyTypes"]>
    composites: {}
  }

  type ECenergyTypesGetPayload<S extends boolean | null | undefined | ECenergyTypesDefaultArgs> = $Result.GetResult<Prisma.$ECenergyTypesPayload, S>

  type ECenergyTypesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ECenergyTypesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ECenergyTypesCountAggregateInputType | true
    }

  export interface ECenergyTypesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ECenergyTypes'], meta: { name: 'ECenergyTypes' } }
    /**
     * Find zero or one ECenergyTypes that matches the filter.
     * @param {ECenergyTypesFindUniqueArgs} args - Arguments to find a ECenergyTypes
     * @example
     * // Get one ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ECenergyTypesFindUniqueArgs>(args: SelectSubset<T, ECenergyTypesFindUniqueArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ECenergyTypes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ECenergyTypesFindUniqueOrThrowArgs} args - Arguments to find a ECenergyTypes
     * @example
     * // Get one ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ECenergyTypesFindUniqueOrThrowArgs>(args: SelectSubset<T, ECenergyTypesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ECenergyTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesFindFirstArgs} args - Arguments to find a ECenergyTypes
     * @example
     * // Get one ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ECenergyTypesFindFirstArgs>(args?: SelectSubset<T, ECenergyTypesFindFirstArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ECenergyTypes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesFindFirstOrThrowArgs} args - Arguments to find a ECenergyTypes
     * @example
     * // Get one ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ECenergyTypesFindFirstOrThrowArgs>(args?: SelectSubset<T, ECenergyTypesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ECenergyTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.findMany()
     * 
     * // Get first 10 ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eCenergyTypesWithIdOnly = await prisma.eCenergyTypes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ECenergyTypesFindManyArgs>(args?: SelectSubset<T, ECenergyTypesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ECenergyTypes.
     * @param {ECenergyTypesCreateArgs} args - Arguments to create a ECenergyTypes.
     * @example
     * // Create one ECenergyTypes
     * const ECenergyTypes = await prisma.eCenergyTypes.create({
     *   data: {
     *     // ... data to create a ECenergyTypes
     *   }
     * })
     * 
     */
    create<T extends ECenergyTypesCreateArgs>(args: SelectSubset<T, ECenergyTypesCreateArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ECenergyTypes.
     * @param {ECenergyTypesCreateManyArgs} args - Arguments to create many ECenergyTypes.
     * @example
     * // Create many ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ECenergyTypesCreateManyArgs>(args?: SelectSubset<T, ECenergyTypesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ECenergyTypes.
     * @param {ECenergyTypesDeleteArgs} args - Arguments to delete one ECenergyTypes.
     * @example
     * // Delete one ECenergyTypes
     * const ECenergyTypes = await prisma.eCenergyTypes.delete({
     *   where: {
     *     // ... filter to delete one ECenergyTypes
     *   }
     * })
     * 
     */
    delete<T extends ECenergyTypesDeleteArgs>(args: SelectSubset<T, ECenergyTypesDeleteArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ECenergyTypes.
     * @param {ECenergyTypesUpdateArgs} args - Arguments to update one ECenergyTypes.
     * @example
     * // Update one ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ECenergyTypesUpdateArgs>(args: SelectSubset<T, ECenergyTypesUpdateArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ECenergyTypes.
     * @param {ECenergyTypesDeleteManyArgs} args - Arguments to filter ECenergyTypes to delete.
     * @example
     * // Delete a few ECenergyTypes
     * const { count } = await prisma.eCenergyTypes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ECenergyTypesDeleteManyArgs>(args?: SelectSubset<T, ECenergyTypesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ECenergyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ECenergyTypesUpdateManyArgs>(args: SelectSubset<T, ECenergyTypesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ECenergyTypes.
     * @param {ECenergyTypesUpsertArgs} args - Arguments to update or create a ECenergyTypes.
     * @example
     * // Update or create a ECenergyTypes
     * const eCenergyTypes = await prisma.eCenergyTypes.upsert({
     *   create: {
     *     // ... data to create a ECenergyTypes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ECenergyTypes we want to update
     *   }
     * })
     */
    upsert<T extends ECenergyTypesUpsertArgs>(args: SelectSubset<T, ECenergyTypesUpsertArgs<ExtArgs>>): Prisma__ECenergyTypesClient<$Result.GetResult<Prisma.$ECenergyTypesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ECenergyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesCountArgs} args - Arguments to filter ECenergyTypes to count.
     * @example
     * // Count the number of ECenergyTypes
     * const count = await prisma.eCenergyTypes.count({
     *   where: {
     *     // ... the filter for the ECenergyTypes we want to count
     *   }
     * })
    **/
    count<T extends ECenergyTypesCountArgs>(
      args?: Subset<T, ECenergyTypesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ECenergyTypesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ECenergyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ECenergyTypesAggregateArgs>(args: Subset<T, ECenergyTypesAggregateArgs>): Prisma.PrismaPromise<GetECenergyTypesAggregateType<T>>

    /**
     * Group by ECenergyTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECenergyTypesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ECenergyTypesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ECenergyTypesGroupByArgs['orderBy'] }
        : { orderBy?: ECenergyTypesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ECenergyTypesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetECenergyTypesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ECenergyTypes model
   */
  readonly fields: ECenergyTypesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ECenergyTypes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ECenergyTypesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ECenergyTypes model
   */
  interface ECenergyTypesFieldRefs {
    readonly id: FieldRef<"ECenergyTypes", 'Int'>
    readonly type: FieldRef<"ECenergyTypes", 'String'>
    readonly name: FieldRef<"ECenergyTypes", 'String'>
    readonly unit: FieldRef<"ECenergyTypes", 'String'>
    readonly icon: FieldRef<"ECenergyTypes", 'String'>
    readonly conversion_factor: FieldRef<"ECenergyTypes", 'String'>
    readonly created_at: FieldRef<"ECenergyTypes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ECenergyTypes findUnique
   */
  export type ECenergyTypesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyTypes to fetch.
     */
    where: ECenergyTypesWhereUniqueInput
  }

  /**
   * ECenergyTypes findUniqueOrThrow
   */
  export type ECenergyTypesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyTypes to fetch.
     */
    where: ECenergyTypesWhereUniqueInput
  }

  /**
   * ECenergyTypes findFirst
   */
  export type ECenergyTypesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyTypes to fetch.
     */
    where?: ECenergyTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyTypes to fetch.
     */
    orderBy?: ECenergyTypesOrderByWithRelationInput | ECenergyTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ECenergyTypes.
     */
    cursor?: ECenergyTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ECenergyTypes.
     */
    distinct?: ECenergyTypesScalarFieldEnum | ECenergyTypesScalarFieldEnum[]
  }

  /**
   * ECenergyTypes findFirstOrThrow
   */
  export type ECenergyTypesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyTypes to fetch.
     */
    where?: ECenergyTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyTypes to fetch.
     */
    orderBy?: ECenergyTypesOrderByWithRelationInput | ECenergyTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ECenergyTypes.
     */
    cursor?: ECenergyTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ECenergyTypes.
     */
    distinct?: ECenergyTypesScalarFieldEnum | ECenergyTypesScalarFieldEnum[]
  }

  /**
   * ECenergyTypes findMany
   */
  export type ECenergyTypesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * Filter, which ECenergyTypes to fetch.
     */
    where?: ECenergyTypesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECenergyTypes to fetch.
     */
    orderBy?: ECenergyTypesOrderByWithRelationInput | ECenergyTypesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ECenergyTypes.
     */
    cursor?: ECenergyTypesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECenergyTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECenergyTypes.
     */
    skip?: number
    distinct?: ECenergyTypesScalarFieldEnum | ECenergyTypesScalarFieldEnum[]
  }

  /**
   * ECenergyTypes create
   */
  export type ECenergyTypesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * The data needed to create a ECenergyTypes.
     */
    data?: XOR<ECenergyTypesCreateInput, ECenergyTypesUncheckedCreateInput>
  }

  /**
   * ECenergyTypes createMany
   */
  export type ECenergyTypesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ECenergyTypes.
     */
    data: ECenergyTypesCreateManyInput | ECenergyTypesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ECenergyTypes update
   */
  export type ECenergyTypesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * The data needed to update a ECenergyTypes.
     */
    data: XOR<ECenergyTypesUpdateInput, ECenergyTypesUncheckedUpdateInput>
    /**
     * Choose, which ECenergyTypes to update.
     */
    where: ECenergyTypesWhereUniqueInput
  }

  /**
   * ECenergyTypes updateMany
   */
  export type ECenergyTypesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ECenergyTypes.
     */
    data: XOR<ECenergyTypesUpdateManyMutationInput, ECenergyTypesUncheckedUpdateManyInput>
    /**
     * Filter which ECenergyTypes to update
     */
    where?: ECenergyTypesWhereInput
    /**
     * Limit how many ECenergyTypes to update.
     */
    limit?: number
  }

  /**
   * ECenergyTypes upsert
   */
  export type ECenergyTypesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * The filter to search for the ECenergyTypes to update in case it exists.
     */
    where: ECenergyTypesWhereUniqueInput
    /**
     * In case the ECenergyTypes found by the `where` argument doesn't exist, create a new ECenergyTypes with this data.
     */
    create: XOR<ECenergyTypesCreateInput, ECenergyTypesUncheckedCreateInput>
    /**
     * In case the ECenergyTypes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ECenergyTypesUpdateInput, ECenergyTypesUncheckedUpdateInput>
  }

  /**
   * ECenergyTypes delete
   */
  export type ECenergyTypesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
    /**
     * Filter which ECenergyTypes to delete.
     */
    where: ECenergyTypesWhereUniqueInput
  }

  /**
   * ECenergyTypes deleteMany
   */
  export type ECenergyTypesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ECenergyTypes to delete
     */
    where?: ECenergyTypesWhereInput
    /**
     * Limit how many ECenergyTypes to delete.
     */
    limit?: number
  }

  /**
   * ECenergyTypes without action
   */
  export type ECenergyTypesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECenergyTypes
     */
    select?: ECenergyTypesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECenergyTypes
     */
    omit?: ECenergyTypesOmit<ExtArgs> | null
  }


  /**
   * Model EChistory
   */

  export type AggregateEChistory = {
    _count: EChistoryCountAggregateOutputType | null
    _avg: EChistoryAvgAggregateOutputType | null
    _sum: EChistorySumAggregateOutputType | null
    _min: EChistoryMinAggregateOutputType | null
    _max: EChistoryMaxAggregateOutputType | null
  }

  export type EChistoryAvgAggregateOutputType = {
    id: number | null
  }

  export type EChistorySumAggregateOutputType = {
    id: number | null
  }

  export type EChistoryMinAggregateOutputType = {
    id: number | null
    energy_type_id: string | null
    date_time: Date | null
    consumption: string | null
    generation: string | null
    status: string | null
  }

  export type EChistoryMaxAggregateOutputType = {
    id: number | null
    energy_type_id: string | null
    date_time: Date | null
    consumption: string | null
    generation: string | null
    status: string | null
  }

  export type EChistoryCountAggregateOutputType = {
    id: number
    energy_type_id: number
    date_time: number
    consumption: number
    generation: number
    status: number
    _all: number
  }


  export type EChistoryAvgAggregateInputType = {
    id?: true
  }

  export type EChistorySumAggregateInputType = {
    id?: true
  }

  export type EChistoryMinAggregateInputType = {
    id?: true
    energy_type_id?: true
    date_time?: true
    consumption?: true
    generation?: true
    status?: true
  }

  export type EChistoryMaxAggregateInputType = {
    id?: true
    energy_type_id?: true
    date_time?: true
    consumption?: true
    generation?: true
    status?: true
  }

  export type EChistoryCountAggregateInputType = {
    id?: true
    energy_type_id?: true
    date_time?: true
    consumption?: true
    generation?: true
    status?: true
    _all?: true
  }

  export type EChistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EChistory to aggregate.
     */
    where?: EChistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EChistories to fetch.
     */
    orderBy?: EChistoryOrderByWithRelationInput | EChistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EChistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EChistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EChistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EChistories
    **/
    _count?: true | EChistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EChistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EChistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EChistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EChistoryMaxAggregateInputType
  }

  export type GetEChistoryAggregateType<T extends EChistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEChistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEChistory[P]>
      : GetScalarType<T[P], AggregateEChistory[P]>
  }




  export type EChistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EChistoryWhereInput
    orderBy?: EChistoryOrderByWithAggregationInput | EChistoryOrderByWithAggregationInput[]
    by: EChistoryScalarFieldEnum[] | EChistoryScalarFieldEnum
    having?: EChistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EChistoryCountAggregateInputType | true
    _avg?: EChistoryAvgAggregateInputType
    _sum?: EChistorySumAggregateInputType
    _min?: EChistoryMinAggregateInputType
    _max?: EChistoryMaxAggregateInputType
  }

  export type EChistoryGroupByOutputType = {
    id: number
    energy_type_id: string | null
    date_time: Date | null
    consumption: string | null
    generation: string | null
    status: string | null
    _count: EChistoryCountAggregateOutputType | null
    _avg: EChistoryAvgAggregateOutputType | null
    _sum: EChistorySumAggregateOutputType | null
    _min: EChistoryMinAggregateOutputType | null
    _max: EChistoryMaxAggregateOutputType | null
  }

  type GetEChistoryGroupByPayload<T extends EChistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EChistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EChistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EChistoryGroupByOutputType[P]>
            : GetScalarType<T[P], EChistoryGroupByOutputType[P]>
        }
      >
    >


  export type EChistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    energy_type_id?: boolean
    date_time?: boolean
    consumption?: boolean
    generation?: boolean
    status?: boolean
  }, ExtArgs["result"]["eChistory"]>



  export type EChistorySelectScalar = {
    id?: boolean
    energy_type_id?: boolean
    date_time?: boolean
    consumption?: boolean
    generation?: boolean
    status?: boolean
  }

  export type EChistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "energy_type_id" | "date_time" | "consumption" | "generation" | "status", ExtArgs["result"]["eChistory"]>

  export type $EChistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EChistory"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      energy_type_id: string | null
      date_time: Date | null
      consumption: string | null
      generation: string | null
      status: string | null
    }, ExtArgs["result"]["eChistory"]>
    composites: {}
  }

  type EChistoryGetPayload<S extends boolean | null | undefined | EChistoryDefaultArgs> = $Result.GetResult<Prisma.$EChistoryPayload, S>

  type EChistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EChistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EChistoryCountAggregateInputType | true
    }

  export interface EChistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EChistory'], meta: { name: 'EChistory' } }
    /**
     * Find zero or one EChistory that matches the filter.
     * @param {EChistoryFindUniqueArgs} args - Arguments to find a EChistory
     * @example
     * // Get one EChistory
     * const eChistory = await prisma.eChistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EChistoryFindUniqueArgs>(args: SelectSubset<T, EChistoryFindUniqueArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EChistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EChistoryFindUniqueOrThrowArgs} args - Arguments to find a EChistory
     * @example
     * // Get one EChistory
     * const eChistory = await prisma.eChistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EChistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EChistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EChistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryFindFirstArgs} args - Arguments to find a EChistory
     * @example
     * // Get one EChistory
     * const eChistory = await prisma.eChistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EChistoryFindFirstArgs>(args?: SelectSubset<T, EChistoryFindFirstArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EChistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryFindFirstOrThrowArgs} args - Arguments to find a EChistory
     * @example
     * // Get one EChistory
     * const eChistory = await prisma.eChistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EChistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EChistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EChistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EChistories
     * const eChistories = await prisma.eChistory.findMany()
     * 
     * // Get first 10 EChistories
     * const eChistories = await prisma.eChistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eChistoryWithIdOnly = await prisma.eChistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EChistoryFindManyArgs>(args?: SelectSubset<T, EChistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EChistory.
     * @param {EChistoryCreateArgs} args - Arguments to create a EChistory.
     * @example
     * // Create one EChistory
     * const EChistory = await prisma.eChistory.create({
     *   data: {
     *     // ... data to create a EChistory
     *   }
     * })
     * 
     */
    create<T extends EChistoryCreateArgs>(args: SelectSubset<T, EChistoryCreateArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EChistories.
     * @param {EChistoryCreateManyArgs} args - Arguments to create many EChistories.
     * @example
     * // Create many EChistories
     * const eChistory = await prisma.eChistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EChistoryCreateManyArgs>(args?: SelectSubset<T, EChistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EChistory.
     * @param {EChistoryDeleteArgs} args - Arguments to delete one EChistory.
     * @example
     * // Delete one EChistory
     * const EChistory = await prisma.eChistory.delete({
     *   where: {
     *     // ... filter to delete one EChistory
     *   }
     * })
     * 
     */
    delete<T extends EChistoryDeleteArgs>(args: SelectSubset<T, EChistoryDeleteArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EChistory.
     * @param {EChistoryUpdateArgs} args - Arguments to update one EChistory.
     * @example
     * // Update one EChistory
     * const eChistory = await prisma.eChistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EChistoryUpdateArgs>(args: SelectSubset<T, EChistoryUpdateArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EChistories.
     * @param {EChistoryDeleteManyArgs} args - Arguments to filter EChistories to delete.
     * @example
     * // Delete a few EChistories
     * const { count } = await prisma.eChistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EChistoryDeleteManyArgs>(args?: SelectSubset<T, EChistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EChistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EChistories
     * const eChistory = await prisma.eChistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EChistoryUpdateManyArgs>(args: SelectSubset<T, EChistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EChistory.
     * @param {EChistoryUpsertArgs} args - Arguments to update or create a EChistory.
     * @example
     * // Update or create a EChistory
     * const eChistory = await prisma.eChistory.upsert({
     *   create: {
     *     // ... data to create a EChistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EChistory we want to update
     *   }
     * })
     */
    upsert<T extends EChistoryUpsertArgs>(args: SelectSubset<T, EChistoryUpsertArgs<ExtArgs>>): Prisma__EChistoryClient<$Result.GetResult<Prisma.$EChistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EChistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryCountArgs} args - Arguments to filter EChistories to count.
     * @example
     * // Count the number of EChistories
     * const count = await prisma.eChistory.count({
     *   where: {
     *     // ... the filter for the EChistories we want to count
     *   }
     * })
    **/
    count<T extends EChistoryCountArgs>(
      args?: Subset<T, EChistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EChistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EChistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EChistoryAggregateArgs>(args: Subset<T, EChistoryAggregateArgs>): Prisma.PrismaPromise<GetEChistoryAggregateType<T>>

    /**
     * Group by EChistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EChistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EChistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EChistoryGroupByArgs['orderBy'] }
        : { orderBy?: EChistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EChistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEChistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EChistory model
   */
  readonly fields: EChistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EChistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EChistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EChistory model
   */
  interface EChistoryFieldRefs {
    readonly id: FieldRef<"EChistory", 'Int'>
    readonly energy_type_id: FieldRef<"EChistory", 'String'>
    readonly date_time: FieldRef<"EChistory", 'DateTime'>
    readonly consumption: FieldRef<"EChistory", 'String'>
    readonly generation: FieldRef<"EChistory", 'String'>
    readonly status: FieldRef<"EChistory", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EChistory findUnique
   */
  export type EChistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * Filter, which EChistory to fetch.
     */
    where: EChistoryWhereUniqueInput
  }

  /**
   * EChistory findUniqueOrThrow
   */
  export type EChistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * Filter, which EChistory to fetch.
     */
    where: EChistoryWhereUniqueInput
  }

  /**
   * EChistory findFirst
   */
  export type EChistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * Filter, which EChistory to fetch.
     */
    where?: EChistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EChistories to fetch.
     */
    orderBy?: EChistoryOrderByWithRelationInput | EChistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EChistories.
     */
    cursor?: EChistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EChistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EChistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EChistories.
     */
    distinct?: EChistoryScalarFieldEnum | EChistoryScalarFieldEnum[]
  }

  /**
   * EChistory findFirstOrThrow
   */
  export type EChistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * Filter, which EChistory to fetch.
     */
    where?: EChistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EChistories to fetch.
     */
    orderBy?: EChistoryOrderByWithRelationInput | EChistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EChistories.
     */
    cursor?: EChistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EChistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EChistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EChistories.
     */
    distinct?: EChistoryScalarFieldEnum | EChistoryScalarFieldEnum[]
  }

  /**
   * EChistory findMany
   */
  export type EChistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * Filter, which EChistories to fetch.
     */
    where?: EChistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EChistories to fetch.
     */
    orderBy?: EChistoryOrderByWithRelationInput | EChistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EChistories.
     */
    cursor?: EChistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EChistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EChistories.
     */
    skip?: number
    distinct?: EChistoryScalarFieldEnum | EChistoryScalarFieldEnum[]
  }

  /**
   * EChistory create
   */
  export type EChistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * The data needed to create a EChistory.
     */
    data?: XOR<EChistoryCreateInput, EChistoryUncheckedCreateInput>
  }

  /**
   * EChistory createMany
   */
  export type EChistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EChistories.
     */
    data: EChistoryCreateManyInput | EChistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EChistory update
   */
  export type EChistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * The data needed to update a EChistory.
     */
    data: XOR<EChistoryUpdateInput, EChistoryUncheckedUpdateInput>
    /**
     * Choose, which EChistory to update.
     */
    where: EChistoryWhereUniqueInput
  }

  /**
   * EChistory updateMany
   */
  export type EChistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EChistories.
     */
    data: XOR<EChistoryUpdateManyMutationInput, EChistoryUncheckedUpdateManyInput>
    /**
     * Filter which EChistories to update
     */
    where?: EChistoryWhereInput
    /**
     * Limit how many EChistories to update.
     */
    limit?: number
  }

  /**
   * EChistory upsert
   */
  export type EChistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * The filter to search for the EChistory to update in case it exists.
     */
    where: EChistoryWhereUniqueInput
    /**
     * In case the EChistory found by the `where` argument doesn't exist, create a new EChistory with this data.
     */
    create: XOR<EChistoryCreateInput, EChistoryUncheckedCreateInput>
    /**
     * In case the EChistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EChistoryUpdateInput, EChistoryUncheckedUpdateInput>
  }

  /**
   * EChistory delete
   */
  export type EChistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
    /**
     * Filter which EChistory to delete.
     */
    where: EChistoryWhereUniqueInput
  }

  /**
   * EChistory deleteMany
   */
  export type EChistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EChistories to delete
     */
    where?: EChistoryWhereInput
    /**
     * Limit how many EChistories to delete.
     */
    limit?: number
  }

  /**
   * EChistory without action
   */
  export type EChistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EChistory
     */
    select?: EChistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the EChistory
     */
    omit?: EChistoryOmit<ExtArgs> | null
  }


  /**
   * Model ECrealTime
   */

  export type AggregateECrealTime = {
    _count: ECrealTimeCountAggregateOutputType | null
    _avg: ECrealTimeAvgAggregateOutputType | null
    _sum: ECrealTimeSumAggregateOutputType | null
    _min: ECrealTimeMinAggregateOutputType | null
    _max: ECrealTimeMaxAggregateOutputType | null
  }

  export type ECrealTimeAvgAggregateOutputType = {
    id: number | null
  }

  export type ECrealTimeSumAggregateOutputType = {
    id: number | null
  }

  export type ECrealTimeMinAggregateOutputType = {
    id: number | null
    energy_type_id: string | null
    current_value: string | null
    total_value: string | null
    unit: string | null
    timestamp: string | null
    status: string | null
  }

  export type ECrealTimeMaxAggregateOutputType = {
    id: number | null
    energy_type_id: string | null
    current_value: string | null
    total_value: string | null
    unit: string | null
    timestamp: string | null
    status: string | null
  }

  export type ECrealTimeCountAggregateOutputType = {
    id: number
    energy_type_id: number
    current_value: number
    total_value: number
    unit: number
    timestamp: number
    status: number
    _all: number
  }


  export type ECrealTimeAvgAggregateInputType = {
    id?: true
  }

  export type ECrealTimeSumAggregateInputType = {
    id?: true
  }

  export type ECrealTimeMinAggregateInputType = {
    id?: true
    energy_type_id?: true
    current_value?: true
    total_value?: true
    unit?: true
    timestamp?: true
    status?: true
  }

  export type ECrealTimeMaxAggregateInputType = {
    id?: true
    energy_type_id?: true
    current_value?: true
    total_value?: true
    unit?: true
    timestamp?: true
    status?: true
  }

  export type ECrealTimeCountAggregateInputType = {
    id?: true
    energy_type_id?: true
    current_value?: true
    total_value?: true
    unit?: true
    timestamp?: true
    status?: true
    _all?: true
  }

  export type ECrealTimeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ECrealTime to aggregate.
     */
    where?: ECrealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECrealTimes to fetch.
     */
    orderBy?: ECrealTimeOrderByWithRelationInput | ECrealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ECrealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECrealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECrealTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ECrealTimes
    **/
    _count?: true | ECrealTimeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ECrealTimeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ECrealTimeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ECrealTimeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ECrealTimeMaxAggregateInputType
  }

  export type GetECrealTimeAggregateType<T extends ECrealTimeAggregateArgs> = {
        [P in keyof T & keyof AggregateECrealTime]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateECrealTime[P]>
      : GetScalarType<T[P], AggregateECrealTime[P]>
  }




  export type ECrealTimeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ECrealTimeWhereInput
    orderBy?: ECrealTimeOrderByWithAggregationInput | ECrealTimeOrderByWithAggregationInput[]
    by: ECrealTimeScalarFieldEnum[] | ECrealTimeScalarFieldEnum
    having?: ECrealTimeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ECrealTimeCountAggregateInputType | true
    _avg?: ECrealTimeAvgAggregateInputType
    _sum?: ECrealTimeSumAggregateInputType
    _min?: ECrealTimeMinAggregateInputType
    _max?: ECrealTimeMaxAggregateInputType
  }

  export type ECrealTimeGroupByOutputType = {
    id: number
    energy_type_id: string | null
    current_value: string | null
    total_value: string | null
    unit: string | null
    timestamp: string | null
    status: string | null
    _count: ECrealTimeCountAggregateOutputType | null
    _avg: ECrealTimeAvgAggregateOutputType | null
    _sum: ECrealTimeSumAggregateOutputType | null
    _min: ECrealTimeMinAggregateOutputType | null
    _max: ECrealTimeMaxAggregateOutputType | null
  }

  type GetECrealTimeGroupByPayload<T extends ECrealTimeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ECrealTimeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ECrealTimeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ECrealTimeGroupByOutputType[P]>
            : GetScalarType<T[P], ECrealTimeGroupByOutputType[P]>
        }
      >
    >


  export type ECrealTimeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    energy_type_id?: boolean
    current_value?: boolean
    total_value?: boolean
    unit?: boolean
    timestamp?: boolean
    status?: boolean
  }, ExtArgs["result"]["eCrealTime"]>



  export type ECrealTimeSelectScalar = {
    id?: boolean
    energy_type_id?: boolean
    current_value?: boolean
    total_value?: boolean
    unit?: boolean
    timestamp?: boolean
    status?: boolean
  }

  export type ECrealTimeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "energy_type_id" | "current_value" | "total_value" | "unit" | "timestamp" | "status", ExtArgs["result"]["eCrealTime"]>

  export type $ECrealTimePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ECrealTime"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      energy_type_id: string | null
      current_value: string | null
      total_value: string | null
      unit: string | null
      timestamp: string | null
      status: string | null
    }, ExtArgs["result"]["eCrealTime"]>
    composites: {}
  }

  type ECrealTimeGetPayload<S extends boolean | null | undefined | ECrealTimeDefaultArgs> = $Result.GetResult<Prisma.$ECrealTimePayload, S>

  type ECrealTimeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ECrealTimeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ECrealTimeCountAggregateInputType | true
    }

  export interface ECrealTimeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ECrealTime'], meta: { name: 'ECrealTime' } }
    /**
     * Find zero or one ECrealTime that matches the filter.
     * @param {ECrealTimeFindUniqueArgs} args - Arguments to find a ECrealTime
     * @example
     * // Get one ECrealTime
     * const eCrealTime = await prisma.eCrealTime.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ECrealTimeFindUniqueArgs>(args: SelectSubset<T, ECrealTimeFindUniqueArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ECrealTime that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ECrealTimeFindUniqueOrThrowArgs} args - Arguments to find a ECrealTime
     * @example
     * // Get one ECrealTime
     * const eCrealTime = await prisma.eCrealTime.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ECrealTimeFindUniqueOrThrowArgs>(args: SelectSubset<T, ECrealTimeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ECrealTime that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeFindFirstArgs} args - Arguments to find a ECrealTime
     * @example
     * // Get one ECrealTime
     * const eCrealTime = await prisma.eCrealTime.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ECrealTimeFindFirstArgs>(args?: SelectSubset<T, ECrealTimeFindFirstArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ECrealTime that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeFindFirstOrThrowArgs} args - Arguments to find a ECrealTime
     * @example
     * // Get one ECrealTime
     * const eCrealTime = await prisma.eCrealTime.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ECrealTimeFindFirstOrThrowArgs>(args?: SelectSubset<T, ECrealTimeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ECrealTimes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ECrealTimes
     * const eCrealTimes = await prisma.eCrealTime.findMany()
     * 
     * // Get first 10 ECrealTimes
     * const eCrealTimes = await prisma.eCrealTime.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eCrealTimeWithIdOnly = await prisma.eCrealTime.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ECrealTimeFindManyArgs>(args?: SelectSubset<T, ECrealTimeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ECrealTime.
     * @param {ECrealTimeCreateArgs} args - Arguments to create a ECrealTime.
     * @example
     * // Create one ECrealTime
     * const ECrealTime = await prisma.eCrealTime.create({
     *   data: {
     *     // ... data to create a ECrealTime
     *   }
     * })
     * 
     */
    create<T extends ECrealTimeCreateArgs>(args: SelectSubset<T, ECrealTimeCreateArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ECrealTimes.
     * @param {ECrealTimeCreateManyArgs} args - Arguments to create many ECrealTimes.
     * @example
     * // Create many ECrealTimes
     * const eCrealTime = await prisma.eCrealTime.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ECrealTimeCreateManyArgs>(args?: SelectSubset<T, ECrealTimeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ECrealTime.
     * @param {ECrealTimeDeleteArgs} args - Arguments to delete one ECrealTime.
     * @example
     * // Delete one ECrealTime
     * const ECrealTime = await prisma.eCrealTime.delete({
     *   where: {
     *     // ... filter to delete one ECrealTime
     *   }
     * })
     * 
     */
    delete<T extends ECrealTimeDeleteArgs>(args: SelectSubset<T, ECrealTimeDeleteArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ECrealTime.
     * @param {ECrealTimeUpdateArgs} args - Arguments to update one ECrealTime.
     * @example
     * // Update one ECrealTime
     * const eCrealTime = await prisma.eCrealTime.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ECrealTimeUpdateArgs>(args: SelectSubset<T, ECrealTimeUpdateArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ECrealTimes.
     * @param {ECrealTimeDeleteManyArgs} args - Arguments to filter ECrealTimes to delete.
     * @example
     * // Delete a few ECrealTimes
     * const { count } = await prisma.eCrealTime.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ECrealTimeDeleteManyArgs>(args?: SelectSubset<T, ECrealTimeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ECrealTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ECrealTimes
     * const eCrealTime = await prisma.eCrealTime.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ECrealTimeUpdateManyArgs>(args: SelectSubset<T, ECrealTimeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ECrealTime.
     * @param {ECrealTimeUpsertArgs} args - Arguments to update or create a ECrealTime.
     * @example
     * // Update or create a ECrealTime
     * const eCrealTime = await prisma.eCrealTime.upsert({
     *   create: {
     *     // ... data to create a ECrealTime
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ECrealTime we want to update
     *   }
     * })
     */
    upsert<T extends ECrealTimeUpsertArgs>(args: SelectSubset<T, ECrealTimeUpsertArgs<ExtArgs>>): Prisma__ECrealTimeClient<$Result.GetResult<Prisma.$ECrealTimePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ECrealTimes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeCountArgs} args - Arguments to filter ECrealTimes to count.
     * @example
     * // Count the number of ECrealTimes
     * const count = await prisma.eCrealTime.count({
     *   where: {
     *     // ... the filter for the ECrealTimes we want to count
     *   }
     * })
    **/
    count<T extends ECrealTimeCountArgs>(
      args?: Subset<T, ECrealTimeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ECrealTimeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ECrealTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ECrealTimeAggregateArgs>(args: Subset<T, ECrealTimeAggregateArgs>): Prisma.PrismaPromise<GetECrealTimeAggregateType<T>>

    /**
     * Group by ECrealTime.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ECrealTimeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ECrealTimeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ECrealTimeGroupByArgs['orderBy'] }
        : { orderBy?: ECrealTimeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ECrealTimeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetECrealTimeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ECrealTime model
   */
  readonly fields: ECrealTimeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ECrealTime.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ECrealTimeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ECrealTime model
   */
  interface ECrealTimeFieldRefs {
    readonly id: FieldRef<"ECrealTime", 'Int'>
    readonly energy_type_id: FieldRef<"ECrealTime", 'String'>
    readonly current_value: FieldRef<"ECrealTime", 'String'>
    readonly total_value: FieldRef<"ECrealTime", 'String'>
    readonly unit: FieldRef<"ECrealTime", 'String'>
    readonly timestamp: FieldRef<"ECrealTime", 'String'>
    readonly status: FieldRef<"ECrealTime", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ECrealTime findUnique
   */
  export type ECrealTimeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECrealTime to fetch.
     */
    where: ECrealTimeWhereUniqueInput
  }

  /**
   * ECrealTime findUniqueOrThrow
   */
  export type ECrealTimeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECrealTime to fetch.
     */
    where: ECrealTimeWhereUniqueInput
  }

  /**
   * ECrealTime findFirst
   */
  export type ECrealTimeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECrealTime to fetch.
     */
    where?: ECrealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECrealTimes to fetch.
     */
    orderBy?: ECrealTimeOrderByWithRelationInput | ECrealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ECrealTimes.
     */
    cursor?: ECrealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECrealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECrealTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ECrealTimes.
     */
    distinct?: ECrealTimeScalarFieldEnum | ECrealTimeScalarFieldEnum[]
  }

  /**
   * ECrealTime findFirstOrThrow
   */
  export type ECrealTimeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECrealTime to fetch.
     */
    where?: ECrealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECrealTimes to fetch.
     */
    orderBy?: ECrealTimeOrderByWithRelationInput | ECrealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ECrealTimes.
     */
    cursor?: ECrealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECrealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECrealTimes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ECrealTimes.
     */
    distinct?: ECrealTimeScalarFieldEnum | ECrealTimeScalarFieldEnum[]
  }

  /**
   * ECrealTime findMany
   */
  export type ECrealTimeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * Filter, which ECrealTimes to fetch.
     */
    where?: ECrealTimeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ECrealTimes to fetch.
     */
    orderBy?: ECrealTimeOrderByWithRelationInput | ECrealTimeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ECrealTimes.
     */
    cursor?: ECrealTimeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ECrealTimes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ECrealTimes.
     */
    skip?: number
    distinct?: ECrealTimeScalarFieldEnum | ECrealTimeScalarFieldEnum[]
  }

  /**
   * ECrealTime create
   */
  export type ECrealTimeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * The data needed to create a ECrealTime.
     */
    data?: XOR<ECrealTimeCreateInput, ECrealTimeUncheckedCreateInput>
  }

  /**
   * ECrealTime createMany
   */
  export type ECrealTimeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ECrealTimes.
     */
    data: ECrealTimeCreateManyInput | ECrealTimeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ECrealTime update
   */
  export type ECrealTimeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * The data needed to update a ECrealTime.
     */
    data: XOR<ECrealTimeUpdateInput, ECrealTimeUncheckedUpdateInput>
    /**
     * Choose, which ECrealTime to update.
     */
    where: ECrealTimeWhereUniqueInput
  }

  /**
   * ECrealTime updateMany
   */
  export type ECrealTimeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ECrealTimes.
     */
    data: XOR<ECrealTimeUpdateManyMutationInput, ECrealTimeUncheckedUpdateManyInput>
    /**
     * Filter which ECrealTimes to update
     */
    where?: ECrealTimeWhereInput
    /**
     * Limit how many ECrealTimes to update.
     */
    limit?: number
  }

  /**
   * ECrealTime upsert
   */
  export type ECrealTimeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * The filter to search for the ECrealTime to update in case it exists.
     */
    where: ECrealTimeWhereUniqueInput
    /**
     * In case the ECrealTime found by the `where` argument doesn't exist, create a new ECrealTime with this data.
     */
    create: XOR<ECrealTimeCreateInput, ECrealTimeUncheckedCreateInput>
    /**
     * In case the ECrealTime was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ECrealTimeUpdateInput, ECrealTimeUncheckedUpdateInput>
  }

  /**
   * ECrealTime delete
   */
  export type ECrealTimeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
    /**
     * Filter which ECrealTime to delete.
     */
    where: ECrealTimeWhereUniqueInput
  }

  /**
   * ECrealTime deleteMany
   */
  export type ECrealTimeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ECrealTimes to delete
     */
    where?: ECrealTimeWhereInput
    /**
     * Limit how many ECrealTimes to delete.
     */
    limit?: number
  }

  /**
   * ECrealTime without action
   */
  export type ECrealTimeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ECrealTime
     */
    select?: ECrealTimeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ECrealTime
     */
    omit?: ECrealTimeOmit<ExtArgs> | null
  }


  /**
   * Model EEBenchmarkRankCards
   */

  export type AggregateEEBenchmarkRankCards = {
    _count: EEBenchmarkRankCardsCountAggregateOutputType | null
    _avg: EEBenchmarkRankCardsAvgAggregateOutputType | null
    _sum: EEBenchmarkRankCardsSumAggregateOutputType | null
    _min: EEBenchmarkRankCardsMinAggregateOutputType | null
    _max: EEBenchmarkRankCardsMaxAggregateOutputType | null
  }

  export type EEBenchmarkRankCardsAvgAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type EEBenchmarkRankCardsSumAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type EEBenchmarkRankCardsMinAggregateOutputType = {
    id: number | null
    rank: number | null
    name: string | null
    efficiency: string | null
    unit: string | null
    trend: string | null
  }

  export type EEBenchmarkRankCardsMaxAggregateOutputType = {
    id: number | null
    rank: number | null
    name: string | null
    efficiency: string | null
    unit: string | null
    trend: string | null
  }

  export type EEBenchmarkRankCardsCountAggregateOutputType = {
    id: number
    rank: number
    name: number
    efficiency: number
    unit: number
    trend: number
    _all: number
  }


  export type EEBenchmarkRankCardsAvgAggregateInputType = {
    id?: true
    rank?: true
  }

  export type EEBenchmarkRankCardsSumAggregateInputType = {
    id?: true
    rank?: true
  }

  export type EEBenchmarkRankCardsMinAggregateInputType = {
    id?: true
    rank?: true
    name?: true
    efficiency?: true
    unit?: true
    trend?: true
  }

  export type EEBenchmarkRankCardsMaxAggregateInputType = {
    id?: true
    rank?: true
    name?: true
    efficiency?: true
    unit?: true
    trend?: true
  }

  export type EEBenchmarkRankCardsCountAggregateInputType = {
    id?: true
    rank?: true
    name?: true
    efficiency?: true
    unit?: true
    trend?: true
    _all?: true
  }

  export type EEBenchmarkRankCardsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EEBenchmarkRankCards to aggregate.
     */
    where?: EEBenchmarkRankCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEBenchmarkRankCards to fetch.
     */
    orderBy?: EEBenchmarkRankCardsOrderByWithRelationInput | EEBenchmarkRankCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EEBenchmarkRankCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEBenchmarkRankCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEBenchmarkRankCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EEBenchmarkRankCards
    **/
    _count?: true | EEBenchmarkRankCardsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EEBenchmarkRankCardsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EEBenchmarkRankCardsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EEBenchmarkRankCardsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EEBenchmarkRankCardsMaxAggregateInputType
  }

  export type GetEEBenchmarkRankCardsAggregateType<T extends EEBenchmarkRankCardsAggregateArgs> = {
        [P in keyof T & keyof AggregateEEBenchmarkRankCards]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEEBenchmarkRankCards[P]>
      : GetScalarType<T[P], AggregateEEBenchmarkRankCards[P]>
  }




  export type EEBenchmarkRankCardsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EEBenchmarkRankCardsWhereInput
    orderBy?: EEBenchmarkRankCardsOrderByWithAggregationInput | EEBenchmarkRankCardsOrderByWithAggregationInput[]
    by: EEBenchmarkRankCardsScalarFieldEnum[] | EEBenchmarkRankCardsScalarFieldEnum
    having?: EEBenchmarkRankCardsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EEBenchmarkRankCardsCountAggregateInputType | true
    _avg?: EEBenchmarkRankCardsAvgAggregateInputType
    _sum?: EEBenchmarkRankCardsSumAggregateInputType
    _min?: EEBenchmarkRankCardsMinAggregateInputType
    _max?: EEBenchmarkRankCardsMaxAggregateInputType
  }

  export type EEBenchmarkRankCardsGroupByOutputType = {
    id: number
    rank: number | null
    name: string | null
    efficiency: string | null
    unit: string | null
    trend: string | null
    _count: EEBenchmarkRankCardsCountAggregateOutputType | null
    _avg: EEBenchmarkRankCardsAvgAggregateOutputType | null
    _sum: EEBenchmarkRankCardsSumAggregateOutputType | null
    _min: EEBenchmarkRankCardsMinAggregateOutputType | null
    _max: EEBenchmarkRankCardsMaxAggregateOutputType | null
  }

  type GetEEBenchmarkRankCardsGroupByPayload<T extends EEBenchmarkRankCardsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EEBenchmarkRankCardsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EEBenchmarkRankCardsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EEBenchmarkRankCardsGroupByOutputType[P]>
            : GetScalarType<T[P], EEBenchmarkRankCardsGroupByOutputType[P]>
        }
      >
    >


  export type EEBenchmarkRankCardsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    rank?: boolean
    name?: boolean
    efficiency?: boolean
    unit?: boolean
    trend?: boolean
  }, ExtArgs["result"]["eEBenchmarkRankCards"]>



  export type EEBenchmarkRankCardsSelectScalar = {
    id?: boolean
    rank?: boolean
    name?: boolean
    efficiency?: boolean
    unit?: boolean
    trend?: boolean
  }

  export type EEBenchmarkRankCardsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "rank" | "name" | "efficiency" | "unit" | "trend", ExtArgs["result"]["eEBenchmarkRankCards"]>

  export type $EEBenchmarkRankCardsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EEBenchmarkRankCards"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      rank: number | null
      name: string | null
      efficiency: string | null
      unit: string | null
      trend: string | null
    }, ExtArgs["result"]["eEBenchmarkRankCards"]>
    composites: {}
  }

  type EEBenchmarkRankCardsGetPayload<S extends boolean | null | undefined | EEBenchmarkRankCardsDefaultArgs> = $Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload, S>

  type EEBenchmarkRankCardsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EEBenchmarkRankCardsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EEBenchmarkRankCardsCountAggregateInputType | true
    }

  export interface EEBenchmarkRankCardsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EEBenchmarkRankCards'], meta: { name: 'EEBenchmarkRankCards' } }
    /**
     * Find zero or one EEBenchmarkRankCards that matches the filter.
     * @param {EEBenchmarkRankCardsFindUniqueArgs} args - Arguments to find a EEBenchmarkRankCards
     * @example
     * // Get one EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EEBenchmarkRankCardsFindUniqueArgs>(args: SelectSubset<T, EEBenchmarkRankCardsFindUniqueArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EEBenchmarkRankCards that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EEBenchmarkRankCardsFindUniqueOrThrowArgs} args - Arguments to find a EEBenchmarkRankCards
     * @example
     * // Get one EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EEBenchmarkRankCardsFindUniqueOrThrowArgs>(args: SelectSubset<T, EEBenchmarkRankCardsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EEBenchmarkRankCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsFindFirstArgs} args - Arguments to find a EEBenchmarkRankCards
     * @example
     * // Get one EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EEBenchmarkRankCardsFindFirstArgs>(args?: SelectSubset<T, EEBenchmarkRankCardsFindFirstArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EEBenchmarkRankCards that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsFindFirstOrThrowArgs} args - Arguments to find a EEBenchmarkRankCards
     * @example
     * // Get one EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EEBenchmarkRankCardsFindFirstOrThrowArgs>(args?: SelectSubset<T, EEBenchmarkRankCardsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EEBenchmarkRankCards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findMany()
     * 
     * // Get first 10 EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eEBenchmarkRankCardsWithIdOnly = await prisma.eEBenchmarkRankCards.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EEBenchmarkRankCardsFindManyArgs>(args?: SelectSubset<T, EEBenchmarkRankCardsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EEBenchmarkRankCards.
     * @param {EEBenchmarkRankCardsCreateArgs} args - Arguments to create a EEBenchmarkRankCards.
     * @example
     * // Create one EEBenchmarkRankCards
     * const EEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.create({
     *   data: {
     *     // ... data to create a EEBenchmarkRankCards
     *   }
     * })
     * 
     */
    create<T extends EEBenchmarkRankCardsCreateArgs>(args: SelectSubset<T, EEBenchmarkRankCardsCreateArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EEBenchmarkRankCards.
     * @param {EEBenchmarkRankCardsCreateManyArgs} args - Arguments to create many EEBenchmarkRankCards.
     * @example
     * // Create many EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EEBenchmarkRankCardsCreateManyArgs>(args?: SelectSubset<T, EEBenchmarkRankCardsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EEBenchmarkRankCards.
     * @param {EEBenchmarkRankCardsDeleteArgs} args - Arguments to delete one EEBenchmarkRankCards.
     * @example
     * // Delete one EEBenchmarkRankCards
     * const EEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.delete({
     *   where: {
     *     // ... filter to delete one EEBenchmarkRankCards
     *   }
     * })
     * 
     */
    delete<T extends EEBenchmarkRankCardsDeleteArgs>(args: SelectSubset<T, EEBenchmarkRankCardsDeleteArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EEBenchmarkRankCards.
     * @param {EEBenchmarkRankCardsUpdateArgs} args - Arguments to update one EEBenchmarkRankCards.
     * @example
     * // Update one EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EEBenchmarkRankCardsUpdateArgs>(args: SelectSubset<T, EEBenchmarkRankCardsUpdateArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EEBenchmarkRankCards.
     * @param {EEBenchmarkRankCardsDeleteManyArgs} args - Arguments to filter EEBenchmarkRankCards to delete.
     * @example
     * // Delete a few EEBenchmarkRankCards
     * const { count } = await prisma.eEBenchmarkRankCards.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EEBenchmarkRankCardsDeleteManyArgs>(args?: SelectSubset<T, EEBenchmarkRankCardsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EEBenchmarkRankCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EEBenchmarkRankCardsUpdateManyArgs>(args: SelectSubset<T, EEBenchmarkRankCardsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EEBenchmarkRankCards.
     * @param {EEBenchmarkRankCardsUpsertArgs} args - Arguments to update or create a EEBenchmarkRankCards.
     * @example
     * // Update or create a EEBenchmarkRankCards
     * const eEBenchmarkRankCards = await prisma.eEBenchmarkRankCards.upsert({
     *   create: {
     *     // ... data to create a EEBenchmarkRankCards
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EEBenchmarkRankCards we want to update
     *   }
     * })
     */
    upsert<T extends EEBenchmarkRankCardsUpsertArgs>(args: SelectSubset<T, EEBenchmarkRankCardsUpsertArgs<ExtArgs>>): Prisma__EEBenchmarkRankCardsClient<$Result.GetResult<Prisma.$EEBenchmarkRankCardsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EEBenchmarkRankCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsCountArgs} args - Arguments to filter EEBenchmarkRankCards to count.
     * @example
     * // Count the number of EEBenchmarkRankCards
     * const count = await prisma.eEBenchmarkRankCards.count({
     *   where: {
     *     // ... the filter for the EEBenchmarkRankCards we want to count
     *   }
     * })
    **/
    count<T extends EEBenchmarkRankCardsCountArgs>(
      args?: Subset<T, EEBenchmarkRankCardsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EEBenchmarkRankCardsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EEBenchmarkRankCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EEBenchmarkRankCardsAggregateArgs>(args: Subset<T, EEBenchmarkRankCardsAggregateArgs>): Prisma.PrismaPromise<GetEEBenchmarkRankCardsAggregateType<T>>

    /**
     * Group by EEBenchmarkRankCards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEBenchmarkRankCardsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EEBenchmarkRankCardsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EEBenchmarkRankCardsGroupByArgs['orderBy'] }
        : { orderBy?: EEBenchmarkRankCardsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EEBenchmarkRankCardsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEEBenchmarkRankCardsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EEBenchmarkRankCards model
   */
  readonly fields: EEBenchmarkRankCardsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EEBenchmarkRankCards.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EEBenchmarkRankCardsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EEBenchmarkRankCards model
   */
  interface EEBenchmarkRankCardsFieldRefs {
    readonly id: FieldRef<"EEBenchmarkRankCards", 'Int'>
    readonly rank: FieldRef<"EEBenchmarkRankCards", 'Int'>
    readonly name: FieldRef<"EEBenchmarkRankCards", 'String'>
    readonly efficiency: FieldRef<"EEBenchmarkRankCards", 'String'>
    readonly unit: FieldRef<"EEBenchmarkRankCards", 'String'>
    readonly trend: FieldRef<"EEBenchmarkRankCards", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EEBenchmarkRankCards findUnique
   */
  export type EEBenchmarkRankCardsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * Filter, which EEBenchmarkRankCards to fetch.
     */
    where: EEBenchmarkRankCardsWhereUniqueInput
  }

  /**
   * EEBenchmarkRankCards findUniqueOrThrow
   */
  export type EEBenchmarkRankCardsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * Filter, which EEBenchmarkRankCards to fetch.
     */
    where: EEBenchmarkRankCardsWhereUniqueInput
  }

  /**
   * EEBenchmarkRankCards findFirst
   */
  export type EEBenchmarkRankCardsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * Filter, which EEBenchmarkRankCards to fetch.
     */
    where?: EEBenchmarkRankCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEBenchmarkRankCards to fetch.
     */
    orderBy?: EEBenchmarkRankCardsOrderByWithRelationInput | EEBenchmarkRankCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EEBenchmarkRankCards.
     */
    cursor?: EEBenchmarkRankCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEBenchmarkRankCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEBenchmarkRankCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EEBenchmarkRankCards.
     */
    distinct?: EEBenchmarkRankCardsScalarFieldEnum | EEBenchmarkRankCardsScalarFieldEnum[]
  }

  /**
   * EEBenchmarkRankCards findFirstOrThrow
   */
  export type EEBenchmarkRankCardsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * Filter, which EEBenchmarkRankCards to fetch.
     */
    where?: EEBenchmarkRankCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEBenchmarkRankCards to fetch.
     */
    orderBy?: EEBenchmarkRankCardsOrderByWithRelationInput | EEBenchmarkRankCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EEBenchmarkRankCards.
     */
    cursor?: EEBenchmarkRankCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEBenchmarkRankCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEBenchmarkRankCards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EEBenchmarkRankCards.
     */
    distinct?: EEBenchmarkRankCardsScalarFieldEnum | EEBenchmarkRankCardsScalarFieldEnum[]
  }

  /**
   * EEBenchmarkRankCards findMany
   */
  export type EEBenchmarkRankCardsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * Filter, which EEBenchmarkRankCards to fetch.
     */
    where?: EEBenchmarkRankCardsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEBenchmarkRankCards to fetch.
     */
    orderBy?: EEBenchmarkRankCardsOrderByWithRelationInput | EEBenchmarkRankCardsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EEBenchmarkRankCards.
     */
    cursor?: EEBenchmarkRankCardsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEBenchmarkRankCards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEBenchmarkRankCards.
     */
    skip?: number
    distinct?: EEBenchmarkRankCardsScalarFieldEnum | EEBenchmarkRankCardsScalarFieldEnum[]
  }

  /**
   * EEBenchmarkRankCards create
   */
  export type EEBenchmarkRankCardsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * The data needed to create a EEBenchmarkRankCards.
     */
    data?: XOR<EEBenchmarkRankCardsCreateInput, EEBenchmarkRankCardsUncheckedCreateInput>
  }

  /**
   * EEBenchmarkRankCards createMany
   */
  export type EEBenchmarkRankCardsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EEBenchmarkRankCards.
     */
    data: EEBenchmarkRankCardsCreateManyInput | EEBenchmarkRankCardsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EEBenchmarkRankCards update
   */
  export type EEBenchmarkRankCardsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * The data needed to update a EEBenchmarkRankCards.
     */
    data: XOR<EEBenchmarkRankCardsUpdateInput, EEBenchmarkRankCardsUncheckedUpdateInput>
    /**
     * Choose, which EEBenchmarkRankCards to update.
     */
    where: EEBenchmarkRankCardsWhereUniqueInput
  }

  /**
   * EEBenchmarkRankCards updateMany
   */
  export type EEBenchmarkRankCardsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EEBenchmarkRankCards.
     */
    data: XOR<EEBenchmarkRankCardsUpdateManyMutationInput, EEBenchmarkRankCardsUncheckedUpdateManyInput>
    /**
     * Filter which EEBenchmarkRankCards to update
     */
    where?: EEBenchmarkRankCardsWhereInput
    /**
     * Limit how many EEBenchmarkRankCards to update.
     */
    limit?: number
  }

  /**
   * EEBenchmarkRankCards upsert
   */
  export type EEBenchmarkRankCardsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * The filter to search for the EEBenchmarkRankCards to update in case it exists.
     */
    where: EEBenchmarkRankCardsWhereUniqueInput
    /**
     * In case the EEBenchmarkRankCards found by the `where` argument doesn't exist, create a new EEBenchmarkRankCards with this data.
     */
    create: XOR<EEBenchmarkRankCardsCreateInput, EEBenchmarkRankCardsUncheckedCreateInput>
    /**
     * In case the EEBenchmarkRankCards was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EEBenchmarkRankCardsUpdateInput, EEBenchmarkRankCardsUncheckedUpdateInput>
  }

  /**
   * EEBenchmarkRankCards delete
   */
  export type EEBenchmarkRankCardsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
    /**
     * Filter which EEBenchmarkRankCards to delete.
     */
    where: EEBenchmarkRankCardsWhereUniqueInput
  }

  /**
   * EEBenchmarkRankCards deleteMany
   */
  export type EEBenchmarkRankCardsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EEBenchmarkRankCards to delete
     */
    where?: EEBenchmarkRankCardsWhereInput
    /**
     * Limit how many EEBenchmarkRankCards to delete.
     */
    limit?: number
  }

  /**
   * EEBenchmarkRankCards without action
   */
  export type EEBenchmarkRankCardsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEBenchmarkRankCards
     */
    select?: EEBenchmarkRankCardsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEBenchmarkRankCards
     */
    omit?: EEBenchmarkRankCardsOmit<ExtArgs> | null
  }


  /**
   * Model EEGaugeMetrics
   */

  export type AggregateEEGaugeMetrics = {
    _count: EEGaugeMetricsCountAggregateOutputType | null
    _avg: EEGaugeMetricsAvgAggregateOutputType | null
    _sum: EEGaugeMetricsSumAggregateOutputType | null
    _min: EEGaugeMetricsMinAggregateOutputType | null
    _max: EEGaugeMetricsMaxAggregateOutputType | null
  }

  export type EEGaugeMetricsAvgAggregateOutputType = {
    id: number | null
  }

  export type EEGaugeMetricsSumAggregateOutputType = {
    id: number | null
  }

  export type EEGaugeMetricsMinAggregateOutputType = {
    id: number | null
    current: string | null
    target: string | null
    label: string | null
  }

  export type EEGaugeMetricsMaxAggregateOutputType = {
    id: number | null
    current: string | null
    target: string | null
    label: string | null
  }

  export type EEGaugeMetricsCountAggregateOutputType = {
    id: number
    current: number
    target: number
    label: number
    _all: number
  }


  export type EEGaugeMetricsAvgAggregateInputType = {
    id?: true
  }

  export type EEGaugeMetricsSumAggregateInputType = {
    id?: true
  }

  export type EEGaugeMetricsMinAggregateInputType = {
    id?: true
    current?: true
    target?: true
    label?: true
  }

  export type EEGaugeMetricsMaxAggregateInputType = {
    id?: true
    current?: true
    target?: true
    label?: true
  }

  export type EEGaugeMetricsCountAggregateInputType = {
    id?: true
    current?: true
    target?: true
    label?: true
    _all?: true
  }

  export type EEGaugeMetricsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EEGaugeMetrics to aggregate.
     */
    where?: EEGaugeMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEGaugeMetrics to fetch.
     */
    orderBy?: EEGaugeMetricsOrderByWithRelationInput | EEGaugeMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EEGaugeMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEGaugeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEGaugeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EEGaugeMetrics
    **/
    _count?: true | EEGaugeMetricsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EEGaugeMetricsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EEGaugeMetricsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EEGaugeMetricsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EEGaugeMetricsMaxAggregateInputType
  }

  export type GetEEGaugeMetricsAggregateType<T extends EEGaugeMetricsAggregateArgs> = {
        [P in keyof T & keyof AggregateEEGaugeMetrics]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEEGaugeMetrics[P]>
      : GetScalarType<T[P], AggregateEEGaugeMetrics[P]>
  }




  export type EEGaugeMetricsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EEGaugeMetricsWhereInput
    orderBy?: EEGaugeMetricsOrderByWithAggregationInput | EEGaugeMetricsOrderByWithAggregationInput[]
    by: EEGaugeMetricsScalarFieldEnum[] | EEGaugeMetricsScalarFieldEnum
    having?: EEGaugeMetricsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EEGaugeMetricsCountAggregateInputType | true
    _avg?: EEGaugeMetricsAvgAggregateInputType
    _sum?: EEGaugeMetricsSumAggregateInputType
    _min?: EEGaugeMetricsMinAggregateInputType
    _max?: EEGaugeMetricsMaxAggregateInputType
  }

  export type EEGaugeMetricsGroupByOutputType = {
    id: number
    current: string | null
    target: string | null
    label: string | null
    _count: EEGaugeMetricsCountAggregateOutputType | null
    _avg: EEGaugeMetricsAvgAggregateOutputType | null
    _sum: EEGaugeMetricsSumAggregateOutputType | null
    _min: EEGaugeMetricsMinAggregateOutputType | null
    _max: EEGaugeMetricsMaxAggregateOutputType | null
  }

  type GetEEGaugeMetricsGroupByPayload<T extends EEGaugeMetricsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EEGaugeMetricsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EEGaugeMetricsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EEGaugeMetricsGroupByOutputType[P]>
            : GetScalarType<T[P], EEGaugeMetricsGroupByOutputType[P]>
        }
      >
    >


  export type EEGaugeMetricsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    current?: boolean
    target?: boolean
    label?: boolean
  }, ExtArgs["result"]["eEGaugeMetrics"]>



  export type EEGaugeMetricsSelectScalar = {
    id?: boolean
    current?: boolean
    target?: boolean
    label?: boolean
  }

  export type EEGaugeMetricsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "current" | "target" | "label", ExtArgs["result"]["eEGaugeMetrics"]>

  export type $EEGaugeMetricsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EEGaugeMetrics"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      current: string | null
      target: string | null
      label: string | null
    }, ExtArgs["result"]["eEGaugeMetrics"]>
    composites: {}
  }

  type EEGaugeMetricsGetPayload<S extends boolean | null | undefined | EEGaugeMetricsDefaultArgs> = $Result.GetResult<Prisma.$EEGaugeMetricsPayload, S>

  type EEGaugeMetricsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EEGaugeMetricsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EEGaugeMetricsCountAggregateInputType | true
    }

  export interface EEGaugeMetricsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EEGaugeMetrics'], meta: { name: 'EEGaugeMetrics' } }
    /**
     * Find zero or one EEGaugeMetrics that matches the filter.
     * @param {EEGaugeMetricsFindUniqueArgs} args - Arguments to find a EEGaugeMetrics
     * @example
     * // Get one EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EEGaugeMetricsFindUniqueArgs>(args: SelectSubset<T, EEGaugeMetricsFindUniqueArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EEGaugeMetrics that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EEGaugeMetricsFindUniqueOrThrowArgs} args - Arguments to find a EEGaugeMetrics
     * @example
     * // Get one EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EEGaugeMetricsFindUniqueOrThrowArgs>(args: SelectSubset<T, EEGaugeMetricsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EEGaugeMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsFindFirstArgs} args - Arguments to find a EEGaugeMetrics
     * @example
     * // Get one EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EEGaugeMetricsFindFirstArgs>(args?: SelectSubset<T, EEGaugeMetricsFindFirstArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EEGaugeMetrics that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsFindFirstOrThrowArgs} args - Arguments to find a EEGaugeMetrics
     * @example
     * // Get one EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EEGaugeMetricsFindFirstOrThrowArgs>(args?: SelectSubset<T, EEGaugeMetricsFindFirstOrThrowArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EEGaugeMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findMany()
     * 
     * // Get first 10 EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eEGaugeMetricsWithIdOnly = await prisma.eEGaugeMetrics.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EEGaugeMetricsFindManyArgs>(args?: SelectSubset<T, EEGaugeMetricsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EEGaugeMetrics.
     * @param {EEGaugeMetricsCreateArgs} args - Arguments to create a EEGaugeMetrics.
     * @example
     * // Create one EEGaugeMetrics
     * const EEGaugeMetrics = await prisma.eEGaugeMetrics.create({
     *   data: {
     *     // ... data to create a EEGaugeMetrics
     *   }
     * })
     * 
     */
    create<T extends EEGaugeMetricsCreateArgs>(args: SelectSubset<T, EEGaugeMetricsCreateArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EEGaugeMetrics.
     * @param {EEGaugeMetricsCreateManyArgs} args - Arguments to create many EEGaugeMetrics.
     * @example
     * // Create many EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EEGaugeMetricsCreateManyArgs>(args?: SelectSubset<T, EEGaugeMetricsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EEGaugeMetrics.
     * @param {EEGaugeMetricsDeleteArgs} args - Arguments to delete one EEGaugeMetrics.
     * @example
     * // Delete one EEGaugeMetrics
     * const EEGaugeMetrics = await prisma.eEGaugeMetrics.delete({
     *   where: {
     *     // ... filter to delete one EEGaugeMetrics
     *   }
     * })
     * 
     */
    delete<T extends EEGaugeMetricsDeleteArgs>(args: SelectSubset<T, EEGaugeMetricsDeleteArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EEGaugeMetrics.
     * @param {EEGaugeMetricsUpdateArgs} args - Arguments to update one EEGaugeMetrics.
     * @example
     * // Update one EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EEGaugeMetricsUpdateArgs>(args: SelectSubset<T, EEGaugeMetricsUpdateArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EEGaugeMetrics.
     * @param {EEGaugeMetricsDeleteManyArgs} args - Arguments to filter EEGaugeMetrics to delete.
     * @example
     * // Delete a few EEGaugeMetrics
     * const { count } = await prisma.eEGaugeMetrics.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EEGaugeMetricsDeleteManyArgs>(args?: SelectSubset<T, EEGaugeMetricsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EEGaugeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EEGaugeMetricsUpdateManyArgs>(args: SelectSubset<T, EEGaugeMetricsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EEGaugeMetrics.
     * @param {EEGaugeMetricsUpsertArgs} args - Arguments to update or create a EEGaugeMetrics.
     * @example
     * // Update or create a EEGaugeMetrics
     * const eEGaugeMetrics = await prisma.eEGaugeMetrics.upsert({
     *   create: {
     *     // ... data to create a EEGaugeMetrics
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EEGaugeMetrics we want to update
     *   }
     * })
     */
    upsert<T extends EEGaugeMetricsUpsertArgs>(args: SelectSubset<T, EEGaugeMetricsUpsertArgs<ExtArgs>>): Prisma__EEGaugeMetricsClient<$Result.GetResult<Prisma.$EEGaugeMetricsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EEGaugeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsCountArgs} args - Arguments to filter EEGaugeMetrics to count.
     * @example
     * // Count the number of EEGaugeMetrics
     * const count = await prisma.eEGaugeMetrics.count({
     *   where: {
     *     // ... the filter for the EEGaugeMetrics we want to count
     *   }
     * })
    **/
    count<T extends EEGaugeMetricsCountArgs>(
      args?: Subset<T, EEGaugeMetricsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EEGaugeMetricsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EEGaugeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EEGaugeMetricsAggregateArgs>(args: Subset<T, EEGaugeMetricsAggregateArgs>): Prisma.PrismaPromise<GetEEGaugeMetricsAggregateType<T>>

    /**
     * Group by EEGaugeMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EEGaugeMetricsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EEGaugeMetricsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EEGaugeMetricsGroupByArgs['orderBy'] }
        : { orderBy?: EEGaugeMetricsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EEGaugeMetricsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEEGaugeMetricsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EEGaugeMetrics model
   */
  readonly fields: EEGaugeMetricsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EEGaugeMetrics.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EEGaugeMetricsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EEGaugeMetrics model
   */
  interface EEGaugeMetricsFieldRefs {
    readonly id: FieldRef<"EEGaugeMetrics", 'Int'>
    readonly current: FieldRef<"EEGaugeMetrics", 'String'>
    readonly target: FieldRef<"EEGaugeMetrics", 'String'>
    readonly label: FieldRef<"EEGaugeMetrics", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EEGaugeMetrics findUnique
   */
  export type EEGaugeMetricsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * Filter, which EEGaugeMetrics to fetch.
     */
    where: EEGaugeMetricsWhereUniqueInput
  }

  /**
   * EEGaugeMetrics findUniqueOrThrow
   */
  export type EEGaugeMetricsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * Filter, which EEGaugeMetrics to fetch.
     */
    where: EEGaugeMetricsWhereUniqueInput
  }

  /**
   * EEGaugeMetrics findFirst
   */
  export type EEGaugeMetricsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * Filter, which EEGaugeMetrics to fetch.
     */
    where?: EEGaugeMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEGaugeMetrics to fetch.
     */
    orderBy?: EEGaugeMetricsOrderByWithRelationInput | EEGaugeMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EEGaugeMetrics.
     */
    cursor?: EEGaugeMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEGaugeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEGaugeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EEGaugeMetrics.
     */
    distinct?: EEGaugeMetricsScalarFieldEnum | EEGaugeMetricsScalarFieldEnum[]
  }

  /**
   * EEGaugeMetrics findFirstOrThrow
   */
  export type EEGaugeMetricsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * Filter, which EEGaugeMetrics to fetch.
     */
    where?: EEGaugeMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEGaugeMetrics to fetch.
     */
    orderBy?: EEGaugeMetricsOrderByWithRelationInput | EEGaugeMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EEGaugeMetrics.
     */
    cursor?: EEGaugeMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEGaugeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEGaugeMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EEGaugeMetrics.
     */
    distinct?: EEGaugeMetricsScalarFieldEnum | EEGaugeMetricsScalarFieldEnum[]
  }

  /**
   * EEGaugeMetrics findMany
   */
  export type EEGaugeMetricsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * Filter, which EEGaugeMetrics to fetch.
     */
    where?: EEGaugeMetricsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EEGaugeMetrics to fetch.
     */
    orderBy?: EEGaugeMetricsOrderByWithRelationInput | EEGaugeMetricsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EEGaugeMetrics.
     */
    cursor?: EEGaugeMetricsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EEGaugeMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EEGaugeMetrics.
     */
    skip?: number
    distinct?: EEGaugeMetricsScalarFieldEnum | EEGaugeMetricsScalarFieldEnum[]
  }

  /**
   * EEGaugeMetrics create
   */
  export type EEGaugeMetricsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * The data needed to create a EEGaugeMetrics.
     */
    data?: XOR<EEGaugeMetricsCreateInput, EEGaugeMetricsUncheckedCreateInput>
  }

  /**
   * EEGaugeMetrics createMany
   */
  export type EEGaugeMetricsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EEGaugeMetrics.
     */
    data: EEGaugeMetricsCreateManyInput | EEGaugeMetricsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EEGaugeMetrics update
   */
  export type EEGaugeMetricsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * The data needed to update a EEGaugeMetrics.
     */
    data: XOR<EEGaugeMetricsUpdateInput, EEGaugeMetricsUncheckedUpdateInput>
    /**
     * Choose, which EEGaugeMetrics to update.
     */
    where: EEGaugeMetricsWhereUniqueInput
  }

  /**
   * EEGaugeMetrics updateMany
   */
  export type EEGaugeMetricsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EEGaugeMetrics.
     */
    data: XOR<EEGaugeMetricsUpdateManyMutationInput, EEGaugeMetricsUncheckedUpdateManyInput>
    /**
     * Filter which EEGaugeMetrics to update
     */
    where?: EEGaugeMetricsWhereInput
    /**
     * Limit how many EEGaugeMetrics to update.
     */
    limit?: number
  }

  /**
   * EEGaugeMetrics upsert
   */
  export type EEGaugeMetricsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * The filter to search for the EEGaugeMetrics to update in case it exists.
     */
    where: EEGaugeMetricsWhereUniqueInput
    /**
     * In case the EEGaugeMetrics found by the `where` argument doesn't exist, create a new EEGaugeMetrics with this data.
     */
    create: XOR<EEGaugeMetricsCreateInput, EEGaugeMetricsUncheckedCreateInput>
    /**
     * In case the EEGaugeMetrics was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EEGaugeMetricsUpdateInput, EEGaugeMetricsUncheckedUpdateInput>
  }

  /**
   * EEGaugeMetrics delete
   */
  export type EEGaugeMetricsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
    /**
     * Filter which EEGaugeMetrics to delete.
     */
    where: EEGaugeMetricsWhereUniqueInput
  }

  /**
   * EEGaugeMetrics deleteMany
   */
  export type EEGaugeMetricsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EEGaugeMetrics to delete
     */
    where?: EEGaugeMetricsWhereInput
    /**
     * Limit how many EEGaugeMetrics to delete.
     */
    limit?: number
  }

  /**
   * EEGaugeMetrics without action
   */
  export type EEGaugeMetricsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EEGaugeMetrics
     */
    select?: EEGaugeMetricsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EEGaugeMetrics
     */
    omit?: EEGaugeMetricsOmit<ExtArgs> | null
  }


  /**
   * Model EERankingList
   */

  export type AggregateEERankingList = {
    _count: EERankingListCountAggregateOutputType | null
    _avg: EERankingListAvgAggregateOutputType | null
    _sum: EERankingListSumAggregateOutputType | null
    _min: EERankingListMinAggregateOutputType | null
    _max: EERankingListMaxAggregateOutputType | null
  }

  export type EERankingListAvgAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type EERankingListSumAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type EERankingListMinAggregateOutputType = {
    id: number | null
    enterprise: string | null
    rank: number | null
    efficiency: string | null
    benchmark: string | null
    delta: string | null
    status: string | null
  }

  export type EERankingListMaxAggregateOutputType = {
    id: number | null
    enterprise: string | null
    rank: number | null
    efficiency: string | null
    benchmark: string | null
    delta: string | null
    status: string | null
  }

  export type EERankingListCountAggregateOutputType = {
    id: number
    enterprise: number
    rank: number
    efficiency: number
    benchmark: number
    delta: number
    status: number
    _all: number
  }


  export type EERankingListAvgAggregateInputType = {
    id?: true
    rank?: true
  }

  export type EERankingListSumAggregateInputType = {
    id?: true
    rank?: true
  }

  export type EERankingListMinAggregateInputType = {
    id?: true
    enterprise?: true
    rank?: true
    efficiency?: true
    benchmark?: true
    delta?: true
    status?: true
  }

  export type EERankingListMaxAggregateInputType = {
    id?: true
    enterprise?: true
    rank?: true
    efficiency?: true
    benchmark?: true
    delta?: true
    status?: true
  }

  export type EERankingListCountAggregateInputType = {
    id?: true
    enterprise?: true
    rank?: true
    efficiency?: true
    benchmark?: true
    delta?: true
    status?: true
    _all?: true
  }

  export type EERankingListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EERankingList to aggregate.
     */
    where?: EERankingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EERankingLists to fetch.
     */
    orderBy?: EERankingListOrderByWithRelationInput | EERankingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EERankingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EERankingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EERankingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EERankingLists
    **/
    _count?: true | EERankingListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EERankingListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EERankingListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EERankingListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EERankingListMaxAggregateInputType
  }

  export type GetEERankingListAggregateType<T extends EERankingListAggregateArgs> = {
        [P in keyof T & keyof AggregateEERankingList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEERankingList[P]>
      : GetScalarType<T[P], AggregateEERankingList[P]>
  }




  export type EERankingListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EERankingListWhereInput
    orderBy?: EERankingListOrderByWithAggregationInput | EERankingListOrderByWithAggregationInput[]
    by: EERankingListScalarFieldEnum[] | EERankingListScalarFieldEnum
    having?: EERankingListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EERankingListCountAggregateInputType | true
    _avg?: EERankingListAvgAggregateInputType
    _sum?: EERankingListSumAggregateInputType
    _min?: EERankingListMinAggregateInputType
    _max?: EERankingListMaxAggregateInputType
  }

  export type EERankingListGroupByOutputType = {
    id: number
    enterprise: string | null
    rank: number | null
    efficiency: string | null
    benchmark: string | null
    delta: string | null
    status: string | null
    _count: EERankingListCountAggregateOutputType | null
    _avg: EERankingListAvgAggregateOutputType | null
    _sum: EERankingListSumAggregateOutputType | null
    _min: EERankingListMinAggregateOutputType | null
    _max: EERankingListMaxAggregateOutputType | null
  }

  type GetEERankingListGroupByPayload<T extends EERankingListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EERankingListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EERankingListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EERankingListGroupByOutputType[P]>
            : GetScalarType<T[P], EERankingListGroupByOutputType[P]>
        }
      >
    >


  export type EERankingListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    enterprise?: boolean
    rank?: boolean
    efficiency?: boolean
    benchmark?: boolean
    delta?: boolean
    status?: boolean
  }, ExtArgs["result"]["eERankingList"]>



  export type EERankingListSelectScalar = {
    id?: boolean
    enterprise?: boolean
    rank?: boolean
    efficiency?: boolean
    benchmark?: boolean
    delta?: boolean
    status?: boolean
  }

  export type EERankingListOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "enterprise" | "rank" | "efficiency" | "benchmark" | "delta" | "status", ExtArgs["result"]["eERankingList"]>

  export type $EERankingListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EERankingList"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      enterprise: string | null
      rank: number | null
      efficiency: string | null
      benchmark: string | null
      delta: string | null
      status: string | null
    }, ExtArgs["result"]["eERankingList"]>
    composites: {}
  }

  type EERankingListGetPayload<S extends boolean | null | undefined | EERankingListDefaultArgs> = $Result.GetResult<Prisma.$EERankingListPayload, S>

  type EERankingListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EERankingListFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EERankingListCountAggregateInputType | true
    }

  export interface EERankingListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EERankingList'], meta: { name: 'EERankingList' } }
    /**
     * Find zero or one EERankingList that matches the filter.
     * @param {EERankingListFindUniqueArgs} args - Arguments to find a EERankingList
     * @example
     * // Get one EERankingList
     * const eERankingList = await prisma.eERankingList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EERankingListFindUniqueArgs>(args: SelectSubset<T, EERankingListFindUniqueArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EERankingList that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EERankingListFindUniqueOrThrowArgs} args - Arguments to find a EERankingList
     * @example
     * // Get one EERankingList
     * const eERankingList = await prisma.eERankingList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EERankingListFindUniqueOrThrowArgs>(args: SelectSubset<T, EERankingListFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EERankingList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListFindFirstArgs} args - Arguments to find a EERankingList
     * @example
     * // Get one EERankingList
     * const eERankingList = await prisma.eERankingList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EERankingListFindFirstArgs>(args?: SelectSubset<T, EERankingListFindFirstArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EERankingList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListFindFirstOrThrowArgs} args - Arguments to find a EERankingList
     * @example
     * // Get one EERankingList
     * const eERankingList = await prisma.eERankingList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EERankingListFindFirstOrThrowArgs>(args?: SelectSubset<T, EERankingListFindFirstOrThrowArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EERankingLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EERankingLists
     * const eERankingLists = await prisma.eERankingList.findMany()
     * 
     * // Get first 10 EERankingLists
     * const eERankingLists = await prisma.eERankingList.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eERankingListWithIdOnly = await prisma.eERankingList.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EERankingListFindManyArgs>(args?: SelectSubset<T, EERankingListFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EERankingList.
     * @param {EERankingListCreateArgs} args - Arguments to create a EERankingList.
     * @example
     * // Create one EERankingList
     * const EERankingList = await prisma.eERankingList.create({
     *   data: {
     *     // ... data to create a EERankingList
     *   }
     * })
     * 
     */
    create<T extends EERankingListCreateArgs>(args: SelectSubset<T, EERankingListCreateArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EERankingLists.
     * @param {EERankingListCreateManyArgs} args - Arguments to create many EERankingLists.
     * @example
     * // Create many EERankingLists
     * const eERankingList = await prisma.eERankingList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EERankingListCreateManyArgs>(args?: SelectSubset<T, EERankingListCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EERankingList.
     * @param {EERankingListDeleteArgs} args - Arguments to delete one EERankingList.
     * @example
     * // Delete one EERankingList
     * const EERankingList = await prisma.eERankingList.delete({
     *   where: {
     *     // ... filter to delete one EERankingList
     *   }
     * })
     * 
     */
    delete<T extends EERankingListDeleteArgs>(args: SelectSubset<T, EERankingListDeleteArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EERankingList.
     * @param {EERankingListUpdateArgs} args - Arguments to update one EERankingList.
     * @example
     * // Update one EERankingList
     * const eERankingList = await prisma.eERankingList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EERankingListUpdateArgs>(args: SelectSubset<T, EERankingListUpdateArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EERankingLists.
     * @param {EERankingListDeleteManyArgs} args - Arguments to filter EERankingLists to delete.
     * @example
     * // Delete a few EERankingLists
     * const { count } = await prisma.eERankingList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EERankingListDeleteManyArgs>(args?: SelectSubset<T, EERankingListDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EERankingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EERankingLists
     * const eERankingList = await prisma.eERankingList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EERankingListUpdateManyArgs>(args: SelectSubset<T, EERankingListUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EERankingList.
     * @param {EERankingListUpsertArgs} args - Arguments to update or create a EERankingList.
     * @example
     * // Update or create a EERankingList
     * const eERankingList = await prisma.eERankingList.upsert({
     *   create: {
     *     // ... data to create a EERankingList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EERankingList we want to update
     *   }
     * })
     */
    upsert<T extends EERankingListUpsertArgs>(args: SelectSubset<T, EERankingListUpsertArgs<ExtArgs>>): Prisma__EERankingListClient<$Result.GetResult<Prisma.$EERankingListPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EERankingLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListCountArgs} args - Arguments to filter EERankingLists to count.
     * @example
     * // Count the number of EERankingLists
     * const count = await prisma.eERankingList.count({
     *   where: {
     *     // ... the filter for the EERankingLists we want to count
     *   }
     * })
    **/
    count<T extends EERankingListCountArgs>(
      args?: Subset<T, EERankingListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EERankingListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EERankingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EERankingListAggregateArgs>(args: Subset<T, EERankingListAggregateArgs>): Prisma.PrismaPromise<GetEERankingListAggregateType<T>>

    /**
     * Group by EERankingList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EERankingListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EERankingListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EERankingListGroupByArgs['orderBy'] }
        : { orderBy?: EERankingListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EERankingListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEERankingListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EERankingList model
   */
  readonly fields: EERankingListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EERankingList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EERankingListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EERankingList model
   */
  interface EERankingListFieldRefs {
    readonly id: FieldRef<"EERankingList", 'Int'>
    readonly enterprise: FieldRef<"EERankingList", 'String'>
    readonly rank: FieldRef<"EERankingList", 'Int'>
    readonly efficiency: FieldRef<"EERankingList", 'String'>
    readonly benchmark: FieldRef<"EERankingList", 'String'>
    readonly delta: FieldRef<"EERankingList", 'String'>
    readonly status: FieldRef<"EERankingList", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EERankingList findUnique
   */
  export type EERankingListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * Filter, which EERankingList to fetch.
     */
    where: EERankingListWhereUniqueInput
  }

  /**
   * EERankingList findUniqueOrThrow
   */
  export type EERankingListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * Filter, which EERankingList to fetch.
     */
    where: EERankingListWhereUniqueInput
  }

  /**
   * EERankingList findFirst
   */
  export type EERankingListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * Filter, which EERankingList to fetch.
     */
    where?: EERankingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EERankingLists to fetch.
     */
    orderBy?: EERankingListOrderByWithRelationInput | EERankingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EERankingLists.
     */
    cursor?: EERankingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EERankingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EERankingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EERankingLists.
     */
    distinct?: EERankingListScalarFieldEnum | EERankingListScalarFieldEnum[]
  }

  /**
   * EERankingList findFirstOrThrow
   */
  export type EERankingListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * Filter, which EERankingList to fetch.
     */
    where?: EERankingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EERankingLists to fetch.
     */
    orderBy?: EERankingListOrderByWithRelationInput | EERankingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EERankingLists.
     */
    cursor?: EERankingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EERankingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EERankingLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EERankingLists.
     */
    distinct?: EERankingListScalarFieldEnum | EERankingListScalarFieldEnum[]
  }

  /**
   * EERankingList findMany
   */
  export type EERankingListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * Filter, which EERankingLists to fetch.
     */
    where?: EERankingListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EERankingLists to fetch.
     */
    orderBy?: EERankingListOrderByWithRelationInput | EERankingListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EERankingLists.
     */
    cursor?: EERankingListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EERankingLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EERankingLists.
     */
    skip?: number
    distinct?: EERankingListScalarFieldEnum | EERankingListScalarFieldEnum[]
  }

  /**
   * EERankingList create
   */
  export type EERankingListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * The data needed to create a EERankingList.
     */
    data?: XOR<EERankingListCreateInput, EERankingListUncheckedCreateInput>
  }

  /**
   * EERankingList createMany
   */
  export type EERankingListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EERankingLists.
     */
    data: EERankingListCreateManyInput | EERankingListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EERankingList update
   */
  export type EERankingListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * The data needed to update a EERankingList.
     */
    data: XOR<EERankingListUpdateInput, EERankingListUncheckedUpdateInput>
    /**
     * Choose, which EERankingList to update.
     */
    where: EERankingListWhereUniqueInput
  }

  /**
   * EERankingList updateMany
   */
  export type EERankingListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EERankingLists.
     */
    data: XOR<EERankingListUpdateManyMutationInput, EERankingListUncheckedUpdateManyInput>
    /**
     * Filter which EERankingLists to update
     */
    where?: EERankingListWhereInput
    /**
     * Limit how many EERankingLists to update.
     */
    limit?: number
  }

  /**
   * EERankingList upsert
   */
  export type EERankingListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * The filter to search for the EERankingList to update in case it exists.
     */
    where: EERankingListWhereUniqueInput
    /**
     * In case the EERankingList found by the `where` argument doesn't exist, create a new EERankingList with this data.
     */
    create: XOR<EERankingListCreateInput, EERankingListUncheckedCreateInput>
    /**
     * In case the EERankingList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EERankingListUpdateInput, EERankingListUncheckedUpdateInput>
  }

  /**
   * EERankingList delete
   */
  export type EERankingListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
    /**
     * Filter which EERankingList to delete.
     */
    where: EERankingListWhereUniqueInput
  }

  /**
   * EERankingList deleteMany
   */
  export type EERankingListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EERankingLists to delete
     */
    where?: EERankingListWhereInput
    /**
     * Limit how many EERankingLists to delete.
     */
    limit?: number
  }

  /**
   * EERankingList without action
   */
  export type EERankingListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EERankingList
     */
    select?: EERankingListSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EERankingList
     */
    omit?: EERankingListOmit<ExtArgs> | null
  }


  /**
   * Model EETrendChartData
   */

  export type AggregateEETrendChartData = {
    _count: EETrendChartDataCountAggregateOutputType | null
    _avg: EETrendChartDataAvgAggregateOutputType | null
    _sum: EETrendChartDataSumAggregateOutputType | null
    _min: EETrendChartDataMinAggregateOutputType | null
    _max: EETrendChartDataMaxAggregateOutputType | null
  }

  export type EETrendChartDataAvgAggregateOutputType = {
    id: number | null
  }

  export type EETrendChartDataSumAggregateOutputType = {
    id: number | null
  }

  export type EETrendChartDataMinAggregateOutputType = {
    id: number | null
    month: string | null
    value: string | null
    benchmark: string | null
  }

  export type EETrendChartDataMaxAggregateOutputType = {
    id: number | null
    month: string | null
    value: string | null
    benchmark: string | null
  }

  export type EETrendChartDataCountAggregateOutputType = {
    id: number
    month: number
    value: number
    benchmark: number
    _all: number
  }


  export type EETrendChartDataAvgAggregateInputType = {
    id?: true
  }

  export type EETrendChartDataSumAggregateInputType = {
    id?: true
  }

  export type EETrendChartDataMinAggregateInputType = {
    id?: true
    month?: true
    value?: true
    benchmark?: true
  }

  export type EETrendChartDataMaxAggregateInputType = {
    id?: true
    month?: true
    value?: true
    benchmark?: true
  }

  export type EETrendChartDataCountAggregateInputType = {
    id?: true
    month?: true
    value?: true
    benchmark?: true
    _all?: true
  }

  export type EETrendChartDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EETrendChartData to aggregate.
     */
    where?: EETrendChartDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EETrendChartData to fetch.
     */
    orderBy?: EETrendChartDataOrderByWithRelationInput | EETrendChartDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EETrendChartDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EETrendChartData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EETrendChartData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EETrendChartData
    **/
    _count?: true | EETrendChartDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EETrendChartDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EETrendChartDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EETrendChartDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EETrendChartDataMaxAggregateInputType
  }

  export type GetEETrendChartDataAggregateType<T extends EETrendChartDataAggregateArgs> = {
        [P in keyof T & keyof AggregateEETrendChartData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEETrendChartData[P]>
      : GetScalarType<T[P], AggregateEETrendChartData[P]>
  }




  export type EETrendChartDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EETrendChartDataWhereInput
    orderBy?: EETrendChartDataOrderByWithAggregationInput | EETrendChartDataOrderByWithAggregationInput[]
    by: EETrendChartDataScalarFieldEnum[] | EETrendChartDataScalarFieldEnum
    having?: EETrendChartDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EETrendChartDataCountAggregateInputType | true
    _avg?: EETrendChartDataAvgAggregateInputType
    _sum?: EETrendChartDataSumAggregateInputType
    _min?: EETrendChartDataMinAggregateInputType
    _max?: EETrendChartDataMaxAggregateInputType
  }

  export type EETrendChartDataGroupByOutputType = {
    id: number
    month: string | null
    value: string | null
    benchmark: string | null
    _count: EETrendChartDataCountAggregateOutputType | null
    _avg: EETrendChartDataAvgAggregateOutputType | null
    _sum: EETrendChartDataSumAggregateOutputType | null
    _min: EETrendChartDataMinAggregateOutputType | null
    _max: EETrendChartDataMaxAggregateOutputType | null
  }

  type GetEETrendChartDataGroupByPayload<T extends EETrendChartDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EETrendChartDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EETrendChartDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EETrendChartDataGroupByOutputType[P]>
            : GetScalarType<T[P], EETrendChartDataGroupByOutputType[P]>
        }
      >
    >


  export type EETrendChartDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    value?: boolean
    benchmark?: boolean
  }, ExtArgs["result"]["eETrendChartData"]>



  export type EETrendChartDataSelectScalar = {
    id?: boolean
    month?: boolean
    value?: boolean
    benchmark?: boolean
  }

  export type EETrendChartDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "value" | "benchmark", ExtArgs["result"]["eETrendChartData"]>

  export type $EETrendChartDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EETrendChartData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      month: string | null
      value: string | null
      benchmark: string | null
    }, ExtArgs["result"]["eETrendChartData"]>
    composites: {}
  }

  type EETrendChartDataGetPayload<S extends boolean | null | undefined | EETrendChartDataDefaultArgs> = $Result.GetResult<Prisma.$EETrendChartDataPayload, S>

  type EETrendChartDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EETrendChartDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EETrendChartDataCountAggregateInputType | true
    }

  export interface EETrendChartDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EETrendChartData'], meta: { name: 'EETrendChartData' } }
    /**
     * Find zero or one EETrendChartData that matches the filter.
     * @param {EETrendChartDataFindUniqueArgs} args - Arguments to find a EETrendChartData
     * @example
     * // Get one EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EETrendChartDataFindUniqueArgs>(args: SelectSubset<T, EETrendChartDataFindUniqueArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EETrendChartData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EETrendChartDataFindUniqueOrThrowArgs} args - Arguments to find a EETrendChartData
     * @example
     * // Get one EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EETrendChartDataFindUniqueOrThrowArgs>(args: SelectSubset<T, EETrendChartDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EETrendChartData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataFindFirstArgs} args - Arguments to find a EETrendChartData
     * @example
     * // Get one EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EETrendChartDataFindFirstArgs>(args?: SelectSubset<T, EETrendChartDataFindFirstArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EETrendChartData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataFindFirstOrThrowArgs} args - Arguments to find a EETrendChartData
     * @example
     * // Get one EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EETrendChartDataFindFirstOrThrowArgs>(args?: SelectSubset<T, EETrendChartDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EETrendChartData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.findMany()
     * 
     * // Get first 10 EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eETrendChartDataWithIdOnly = await prisma.eETrendChartData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EETrendChartDataFindManyArgs>(args?: SelectSubset<T, EETrendChartDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EETrendChartData.
     * @param {EETrendChartDataCreateArgs} args - Arguments to create a EETrendChartData.
     * @example
     * // Create one EETrendChartData
     * const EETrendChartData = await prisma.eETrendChartData.create({
     *   data: {
     *     // ... data to create a EETrendChartData
     *   }
     * })
     * 
     */
    create<T extends EETrendChartDataCreateArgs>(args: SelectSubset<T, EETrendChartDataCreateArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EETrendChartData.
     * @param {EETrendChartDataCreateManyArgs} args - Arguments to create many EETrendChartData.
     * @example
     * // Create many EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EETrendChartDataCreateManyArgs>(args?: SelectSubset<T, EETrendChartDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EETrendChartData.
     * @param {EETrendChartDataDeleteArgs} args - Arguments to delete one EETrendChartData.
     * @example
     * // Delete one EETrendChartData
     * const EETrendChartData = await prisma.eETrendChartData.delete({
     *   where: {
     *     // ... filter to delete one EETrendChartData
     *   }
     * })
     * 
     */
    delete<T extends EETrendChartDataDeleteArgs>(args: SelectSubset<T, EETrendChartDataDeleteArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EETrendChartData.
     * @param {EETrendChartDataUpdateArgs} args - Arguments to update one EETrendChartData.
     * @example
     * // Update one EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EETrendChartDataUpdateArgs>(args: SelectSubset<T, EETrendChartDataUpdateArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EETrendChartData.
     * @param {EETrendChartDataDeleteManyArgs} args - Arguments to filter EETrendChartData to delete.
     * @example
     * // Delete a few EETrendChartData
     * const { count } = await prisma.eETrendChartData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EETrendChartDataDeleteManyArgs>(args?: SelectSubset<T, EETrendChartDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EETrendChartData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EETrendChartDataUpdateManyArgs>(args: SelectSubset<T, EETrendChartDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EETrendChartData.
     * @param {EETrendChartDataUpsertArgs} args - Arguments to update or create a EETrendChartData.
     * @example
     * // Update or create a EETrendChartData
     * const eETrendChartData = await prisma.eETrendChartData.upsert({
     *   create: {
     *     // ... data to create a EETrendChartData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EETrendChartData we want to update
     *   }
     * })
     */
    upsert<T extends EETrendChartDataUpsertArgs>(args: SelectSubset<T, EETrendChartDataUpsertArgs<ExtArgs>>): Prisma__EETrendChartDataClient<$Result.GetResult<Prisma.$EETrendChartDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EETrendChartData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataCountArgs} args - Arguments to filter EETrendChartData to count.
     * @example
     * // Count the number of EETrendChartData
     * const count = await prisma.eETrendChartData.count({
     *   where: {
     *     // ... the filter for the EETrendChartData we want to count
     *   }
     * })
    **/
    count<T extends EETrendChartDataCountArgs>(
      args?: Subset<T, EETrendChartDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EETrendChartDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EETrendChartData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EETrendChartDataAggregateArgs>(args: Subset<T, EETrendChartDataAggregateArgs>): Prisma.PrismaPromise<GetEETrendChartDataAggregateType<T>>

    /**
     * Group by EETrendChartData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EETrendChartDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EETrendChartDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EETrendChartDataGroupByArgs['orderBy'] }
        : { orderBy?: EETrendChartDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EETrendChartDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEETrendChartDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EETrendChartData model
   */
  readonly fields: EETrendChartDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EETrendChartData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EETrendChartDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EETrendChartData model
   */
  interface EETrendChartDataFieldRefs {
    readonly id: FieldRef<"EETrendChartData", 'Int'>
    readonly month: FieldRef<"EETrendChartData", 'String'>
    readonly value: FieldRef<"EETrendChartData", 'String'>
    readonly benchmark: FieldRef<"EETrendChartData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EETrendChartData findUnique
   */
  export type EETrendChartDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * Filter, which EETrendChartData to fetch.
     */
    where: EETrendChartDataWhereUniqueInput
  }

  /**
   * EETrendChartData findUniqueOrThrow
   */
  export type EETrendChartDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * Filter, which EETrendChartData to fetch.
     */
    where: EETrendChartDataWhereUniqueInput
  }

  /**
   * EETrendChartData findFirst
   */
  export type EETrendChartDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * Filter, which EETrendChartData to fetch.
     */
    where?: EETrendChartDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EETrendChartData to fetch.
     */
    orderBy?: EETrendChartDataOrderByWithRelationInput | EETrendChartDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EETrendChartData.
     */
    cursor?: EETrendChartDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EETrendChartData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EETrendChartData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EETrendChartData.
     */
    distinct?: EETrendChartDataScalarFieldEnum | EETrendChartDataScalarFieldEnum[]
  }

  /**
   * EETrendChartData findFirstOrThrow
   */
  export type EETrendChartDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * Filter, which EETrendChartData to fetch.
     */
    where?: EETrendChartDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EETrendChartData to fetch.
     */
    orderBy?: EETrendChartDataOrderByWithRelationInput | EETrendChartDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EETrendChartData.
     */
    cursor?: EETrendChartDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EETrendChartData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EETrendChartData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EETrendChartData.
     */
    distinct?: EETrendChartDataScalarFieldEnum | EETrendChartDataScalarFieldEnum[]
  }

  /**
   * EETrendChartData findMany
   */
  export type EETrendChartDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * Filter, which EETrendChartData to fetch.
     */
    where?: EETrendChartDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EETrendChartData to fetch.
     */
    orderBy?: EETrendChartDataOrderByWithRelationInput | EETrendChartDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EETrendChartData.
     */
    cursor?: EETrendChartDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EETrendChartData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EETrendChartData.
     */
    skip?: number
    distinct?: EETrendChartDataScalarFieldEnum | EETrendChartDataScalarFieldEnum[]
  }

  /**
   * EETrendChartData create
   */
  export type EETrendChartDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * The data needed to create a EETrendChartData.
     */
    data?: XOR<EETrendChartDataCreateInput, EETrendChartDataUncheckedCreateInput>
  }

  /**
   * EETrendChartData createMany
   */
  export type EETrendChartDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EETrendChartData.
     */
    data: EETrendChartDataCreateManyInput | EETrendChartDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EETrendChartData update
   */
  export type EETrendChartDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * The data needed to update a EETrendChartData.
     */
    data: XOR<EETrendChartDataUpdateInput, EETrendChartDataUncheckedUpdateInput>
    /**
     * Choose, which EETrendChartData to update.
     */
    where: EETrendChartDataWhereUniqueInput
  }

  /**
   * EETrendChartData updateMany
   */
  export type EETrendChartDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EETrendChartData.
     */
    data: XOR<EETrendChartDataUpdateManyMutationInput, EETrendChartDataUncheckedUpdateManyInput>
    /**
     * Filter which EETrendChartData to update
     */
    where?: EETrendChartDataWhereInput
    /**
     * Limit how many EETrendChartData to update.
     */
    limit?: number
  }

  /**
   * EETrendChartData upsert
   */
  export type EETrendChartDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * The filter to search for the EETrendChartData to update in case it exists.
     */
    where: EETrendChartDataWhereUniqueInput
    /**
     * In case the EETrendChartData found by the `where` argument doesn't exist, create a new EETrendChartData with this data.
     */
    create: XOR<EETrendChartDataCreateInput, EETrendChartDataUncheckedCreateInput>
    /**
     * In case the EETrendChartData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EETrendChartDataUpdateInput, EETrendChartDataUncheckedUpdateInput>
  }

  /**
   * EETrendChartData delete
   */
  export type EETrendChartDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
    /**
     * Filter which EETrendChartData to delete.
     */
    where: EETrendChartDataWhereUniqueInput
  }

  /**
   * EETrendChartData deleteMany
   */
  export type EETrendChartDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EETrendChartData to delete
     */
    where?: EETrendChartDataWhereInput
    /**
     * Limit how many EETrendChartData to delete.
     */
    limit?: number
  }

  /**
   * EETrendChartData without action
   */
  export type EETrendChartDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EETrendChartData
     */
    select?: EETrendChartDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EETrendChartData
     */
    omit?: EETrendChartDataOmit<ExtArgs> | null
  }


  /**
   * Model EFSankeyLinks
   */

  export type AggregateEFSankeyLinks = {
    _count: EFSankeyLinksCountAggregateOutputType | null
    _avg: EFSankeyLinksAvgAggregateOutputType | null
    _sum: EFSankeyLinksSumAggregateOutputType | null
    _min: EFSankeyLinksMinAggregateOutputType | null
    _max: EFSankeyLinksMaxAggregateOutputType | null
  }

  export type EFSankeyLinksAvgAggregateOutputType = {
    id: number | null
    source: number | null
    target: number | null
  }

  export type EFSankeyLinksSumAggregateOutputType = {
    id: number | null
    source: number | null
    target: number | null
  }

  export type EFSankeyLinksMinAggregateOutputType = {
    id: number | null
    source: number | null
    target: number | null
    value: string | null
    type: string | null
  }

  export type EFSankeyLinksMaxAggregateOutputType = {
    id: number | null
    source: number | null
    target: number | null
    value: string | null
    type: string | null
  }

  export type EFSankeyLinksCountAggregateOutputType = {
    id: number
    source: number
    target: number
    value: number
    type: number
    _all: number
  }


  export type EFSankeyLinksAvgAggregateInputType = {
    id?: true
    source?: true
    target?: true
  }

  export type EFSankeyLinksSumAggregateInputType = {
    id?: true
    source?: true
    target?: true
  }

  export type EFSankeyLinksMinAggregateInputType = {
    id?: true
    source?: true
    target?: true
    value?: true
    type?: true
  }

  export type EFSankeyLinksMaxAggregateInputType = {
    id?: true
    source?: true
    target?: true
    value?: true
    type?: true
  }

  export type EFSankeyLinksCountAggregateInputType = {
    id?: true
    source?: true
    target?: true
    value?: true
    type?: true
    _all?: true
  }

  export type EFSankeyLinksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFSankeyLinks to aggregate.
     */
    where?: EFSankeyLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyLinks to fetch.
     */
    orderBy?: EFSankeyLinksOrderByWithRelationInput | EFSankeyLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EFSankeyLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EFSankeyLinks
    **/
    _count?: true | EFSankeyLinksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EFSankeyLinksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EFSankeyLinksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EFSankeyLinksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EFSankeyLinksMaxAggregateInputType
  }

  export type GetEFSankeyLinksAggregateType<T extends EFSankeyLinksAggregateArgs> = {
        [P in keyof T & keyof AggregateEFSankeyLinks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEFSankeyLinks[P]>
      : GetScalarType<T[P], AggregateEFSankeyLinks[P]>
  }




  export type EFSankeyLinksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EFSankeyLinksWhereInput
    orderBy?: EFSankeyLinksOrderByWithAggregationInput | EFSankeyLinksOrderByWithAggregationInput[]
    by: EFSankeyLinksScalarFieldEnum[] | EFSankeyLinksScalarFieldEnum
    having?: EFSankeyLinksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EFSankeyLinksCountAggregateInputType | true
    _avg?: EFSankeyLinksAvgAggregateInputType
    _sum?: EFSankeyLinksSumAggregateInputType
    _min?: EFSankeyLinksMinAggregateInputType
    _max?: EFSankeyLinksMaxAggregateInputType
  }

  export type EFSankeyLinksGroupByOutputType = {
    id: number
    source: number | null
    target: number | null
    value: string | null
    type: string | null
    _count: EFSankeyLinksCountAggregateOutputType | null
    _avg: EFSankeyLinksAvgAggregateOutputType | null
    _sum: EFSankeyLinksSumAggregateOutputType | null
    _min: EFSankeyLinksMinAggregateOutputType | null
    _max: EFSankeyLinksMaxAggregateOutputType | null
  }

  type GetEFSankeyLinksGroupByPayload<T extends EFSankeyLinksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EFSankeyLinksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EFSankeyLinksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EFSankeyLinksGroupByOutputType[P]>
            : GetScalarType<T[P], EFSankeyLinksGroupByOutputType[P]>
        }
      >
    >


  export type EFSankeyLinksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    source?: boolean
    target?: boolean
    value?: boolean
    type?: boolean
  }, ExtArgs["result"]["eFSankeyLinks"]>



  export type EFSankeyLinksSelectScalar = {
    id?: boolean
    source?: boolean
    target?: boolean
    value?: boolean
    type?: boolean
  }

  export type EFSankeyLinksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "source" | "target" | "value" | "type", ExtArgs["result"]["eFSankeyLinks"]>

  export type $EFSankeyLinksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EFSankeyLinks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      source: number | null
      target: number | null
      value: string | null
      type: string | null
    }, ExtArgs["result"]["eFSankeyLinks"]>
    composites: {}
  }

  type EFSankeyLinksGetPayload<S extends boolean | null | undefined | EFSankeyLinksDefaultArgs> = $Result.GetResult<Prisma.$EFSankeyLinksPayload, S>

  type EFSankeyLinksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EFSankeyLinksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EFSankeyLinksCountAggregateInputType | true
    }

  export interface EFSankeyLinksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EFSankeyLinks'], meta: { name: 'EFSankeyLinks' } }
    /**
     * Find zero or one EFSankeyLinks that matches the filter.
     * @param {EFSankeyLinksFindUniqueArgs} args - Arguments to find a EFSankeyLinks
     * @example
     * // Get one EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFSankeyLinksFindUniqueArgs>(args: SelectSubset<T, EFSankeyLinksFindUniqueArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EFSankeyLinks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EFSankeyLinksFindUniqueOrThrowArgs} args - Arguments to find a EFSankeyLinks
     * @example
     * // Get one EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFSankeyLinksFindUniqueOrThrowArgs>(args: SelectSubset<T, EFSankeyLinksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFSankeyLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksFindFirstArgs} args - Arguments to find a EFSankeyLinks
     * @example
     * // Get one EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFSankeyLinksFindFirstArgs>(args?: SelectSubset<T, EFSankeyLinksFindFirstArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFSankeyLinks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksFindFirstOrThrowArgs} args - Arguments to find a EFSankeyLinks
     * @example
     * // Get one EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFSankeyLinksFindFirstOrThrowArgs>(args?: SelectSubset<T, EFSankeyLinksFindFirstOrThrowArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EFSankeyLinks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.findMany()
     * 
     * // Get first 10 EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eFSankeyLinksWithIdOnly = await prisma.eFSankeyLinks.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EFSankeyLinksFindManyArgs>(args?: SelectSubset<T, EFSankeyLinksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EFSankeyLinks.
     * @param {EFSankeyLinksCreateArgs} args - Arguments to create a EFSankeyLinks.
     * @example
     * // Create one EFSankeyLinks
     * const EFSankeyLinks = await prisma.eFSankeyLinks.create({
     *   data: {
     *     // ... data to create a EFSankeyLinks
     *   }
     * })
     * 
     */
    create<T extends EFSankeyLinksCreateArgs>(args: SelectSubset<T, EFSankeyLinksCreateArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EFSankeyLinks.
     * @param {EFSankeyLinksCreateManyArgs} args - Arguments to create many EFSankeyLinks.
     * @example
     * // Create many EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EFSankeyLinksCreateManyArgs>(args?: SelectSubset<T, EFSankeyLinksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EFSankeyLinks.
     * @param {EFSankeyLinksDeleteArgs} args - Arguments to delete one EFSankeyLinks.
     * @example
     * // Delete one EFSankeyLinks
     * const EFSankeyLinks = await prisma.eFSankeyLinks.delete({
     *   where: {
     *     // ... filter to delete one EFSankeyLinks
     *   }
     * })
     * 
     */
    delete<T extends EFSankeyLinksDeleteArgs>(args: SelectSubset<T, EFSankeyLinksDeleteArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EFSankeyLinks.
     * @param {EFSankeyLinksUpdateArgs} args - Arguments to update one EFSankeyLinks.
     * @example
     * // Update one EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EFSankeyLinksUpdateArgs>(args: SelectSubset<T, EFSankeyLinksUpdateArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EFSankeyLinks.
     * @param {EFSankeyLinksDeleteManyArgs} args - Arguments to filter EFSankeyLinks to delete.
     * @example
     * // Delete a few EFSankeyLinks
     * const { count } = await prisma.eFSankeyLinks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EFSankeyLinksDeleteManyArgs>(args?: SelectSubset<T, EFSankeyLinksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EFSankeyLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EFSankeyLinksUpdateManyArgs>(args: SelectSubset<T, EFSankeyLinksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EFSankeyLinks.
     * @param {EFSankeyLinksUpsertArgs} args - Arguments to update or create a EFSankeyLinks.
     * @example
     * // Update or create a EFSankeyLinks
     * const eFSankeyLinks = await prisma.eFSankeyLinks.upsert({
     *   create: {
     *     // ... data to create a EFSankeyLinks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EFSankeyLinks we want to update
     *   }
     * })
     */
    upsert<T extends EFSankeyLinksUpsertArgs>(args: SelectSubset<T, EFSankeyLinksUpsertArgs<ExtArgs>>): Prisma__EFSankeyLinksClient<$Result.GetResult<Prisma.$EFSankeyLinksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EFSankeyLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksCountArgs} args - Arguments to filter EFSankeyLinks to count.
     * @example
     * // Count the number of EFSankeyLinks
     * const count = await prisma.eFSankeyLinks.count({
     *   where: {
     *     // ... the filter for the EFSankeyLinks we want to count
     *   }
     * })
    **/
    count<T extends EFSankeyLinksCountArgs>(
      args?: Subset<T, EFSankeyLinksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EFSankeyLinksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EFSankeyLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EFSankeyLinksAggregateArgs>(args: Subset<T, EFSankeyLinksAggregateArgs>): Prisma.PrismaPromise<GetEFSankeyLinksAggregateType<T>>

    /**
     * Group by EFSankeyLinks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyLinksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EFSankeyLinksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EFSankeyLinksGroupByArgs['orderBy'] }
        : { orderBy?: EFSankeyLinksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EFSankeyLinksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEFSankeyLinksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EFSankeyLinks model
   */
  readonly fields: EFSankeyLinksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EFSankeyLinks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EFSankeyLinksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EFSankeyLinks model
   */
  interface EFSankeyLinksFieldRefs {
    readonly id: FieldRef<"EFSankeyLinks", 'Int'>
    readonly source: FieldRef<"EFSankeyLinks", 'Int'>
    readonly target: FieldRef<"EFSankeyLinks", 'Int'>
    readonly value: FieldRef<"EFSankeyLinks", 'String'>
    readonly type: FieldRef<"EFSankeyLinks", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EFSankeyLinks findUnique
   */
  export type EFSankeyLinksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyLinks to fetch.
     */
    where: EFSankeyLinksWhereUniqueInput
  }

  /**
   * EFSankeyLinks findUniqueOrThrow
   */
  export type EFSankeyLinksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyLinks to fetch.
     */
    where: EFSankeyLinksWhereUniqueInput
  }

  /**
   * EFSankeyLinks findFirst
   */
  export type EFSankeyLinksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyLinks to fetch.
     */
    where?: EFSankeyLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyLinks to fetch.
     */
    orderBy?: EFSankeyLinksOrderByWithRelationInput | EFSankeyLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFSankeyLinks.
     */
    cursor?: EFSankeyLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFSankeyLinks.
     */
    distinct?: EFSankeyLinksScalarFieldEnum | EFSankeyLinksScalarFieldEnum[]
  }

  /**
   * EFSankeyLinks findFirstOrThrow
   */
  export type EFSankeyLinksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyLinks to fetch.
     */
    where?: EFSankeyLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyLinks to fetch.
     */
    orderBy?: EFSankeyLinksOrderByWithRelationInput | EFSankeyLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFSankeyLinks.
     */
    cursor?: EFSankeyLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyLinks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFSankeyLinks.
     */
    distinct?: EFSankeyLinksScalarFieldEnum | EFSankeyLinksScalarFieldEnum[]
  }

  /**
   * EFSankeyLinks findMany
   */
  export type EFSankeyLinksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyLinks to fetch.
     */
    where?: EFSankeyLinksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyLinks to fetch.
     */
    orderBy?: EFSankeyLinksOrderByWithRelationInput | EFSankeyLinksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EFSankeyLinks.
     */
    cursor?: EFSankeyLinksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyLinks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyLinks.
     */
    skip?: number
    distinct?: EFSankeyLinksScalarFieldEnum | EFSankeyLinksScalarFieldEnum[]
  }

  /**
   * EFSankeyLinks create
   */
  export type EFSankeyLinksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * The data needed to create a EFSankeyLinks.
     */
    data?: XOR<EFSankeyLinksCreateInput, EFSankeyLinksUncheckedCreateInput>
  }

  /**
   * EFSankeyLinks createMany
   */
  export type EFSankeyLinksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EFSankeyLinks.
     */
    data: EFSankeyLinksCreateManyInput | EFSankeyLinksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EFSankeyLinks update
   */
  export type EFSankeyLinksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * The data needed to update a EFSankeyLinks.
     */
    data: XOR<EFSankeyLinksUpdateInput, EFSankeyLinksUncheckedUpdateInput>
    /**
     * Choose, which EFSankeyLinks to update.
     */
    where: EFSankeyLinksWhereUniqueInput
  }

  /**
   * EFSankeyLinks updateMany
   */
  export type EFSankeyLinksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EFSankeyLinks.
     */
    data: XOR<EFSankeyLinksUpdateManyMutationInput, EFSankeyLinksUncheckedUpdateManyInput>
    /**
     * Filter which EFSankeyLinks to update
     */
    where?: EFSankeyLinksWhereInput
    /**
     * Limit how many EFSankeyLinks to update.
     */
    limit?: number
  }

  /**
   * EFSankeyLinks upsert
   */
  export type EFSankeyLinksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * The filter to search for the EFSankeyLinks to update in case it exists.
     */
    where: EFSankeyLinksWhereUniqueInput
    /**
     * In case the EFSankeyLinks found by the `where` argument doesn't exist, create a new EFSankeyLinks with this data.
     */
    create: XOR<EFSankeyLinksCreateInput, EFSankeyLinksUncheckedCreateInput>
    /**
     * In case the EFSankeyLinks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EFSankeyLinksUpdateInput, EFSankeyLinksUncheckedUpdateInput>
  }

  /**
   * EFSankeyLinks delete
   */
  export type EFSankeyLinksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
    /**
     * Filter which EFSankeyLinks to delete.
     */
    where: EFSankeyLinksWhereUniqueInput
  }

  /**
   * EFSankeyLinks deleteMany
   */
  export type EFSankeyLinksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFSankeyLinks to delete
     */
    where?: EFSankeyLinksWhereInput
    /**
     * Limit how many EFSankeyLinks to delete.
     */
    limit?: number
  }

  /**
   * EFSankeyLinks without action
   */
  export type EFSankeyLinksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyLinks
     */
    select?: EFSankeyLinksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyLinks
     */
    omit?: EFSankeyLinksOmit<ExtArgs> | null
  }


  /**
   * Model EFSankeyNodes
   */

  export type AggregateEFSankeyNodes = {
    _count: EFSankeyNodesCountAggregateOutputType | null
    _avg: EFSankeyNodesAvgAggregateOutputType | null
    _sum: EFSankeyNodesSumAggregateOutputType | null
    _min: EFSankeyNodesMinAggregateOutputType | null
    _max: EFSankeyNodesMaxAggregateOutputType | null
  }

  export type EFSankeyNodesAvgAggregateOutputType = {
    id: number | null
    node: number | null
  }

  export type EFSankeyNodesSumAggregateOutputType = {
    id: number | null
    node: number | null
  }

  export type EFSankeyNodesMinAggregateOutputType = {
    id: number | null
    node: number | null
    name: string | null
    value: string | null
    unit: string | null
  }

  export type EFSankeyNodesMaxAggregateOutputType = {
    id: number | null
    node: number | null
    name: string | null
    value: string | null
    unit: string | null
  }

  export type EFSankeyNodesCountAggregateOutputType = {
    id: number
    node: number
    name: number
    value: number
    unit: number
    _all: number
  }


  export type EFSankeyNodesAvgAggregateInputType = {
    id?: true
    node?: true
  }

  export type EFSankeyNodesSumAggregateInputType = {
    id?: true
    node?: true
  }

  export type EFSankeyNodesMinAggregateInputType = {
    id?: true
    node?: true
    name?: true
    value?: true
    unit?: true
  }

  export type EFSankeyNodesMaxAggregateInputType = {
    id?: true
    node?: true
    name?: true
    value?: true
    unit?: true
  }

  export type EFSankeyNodesCountAggregateInputType = {
    id?: true
    node?: true
    name?: true
    value?: true
    unit?: true
    _all?: true
  }

  export type EFSankeyNodesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFSankeyNodes to aggregate.
     */
    where?: EFSankeyNodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyNodes to fetch.
     */
    orderBy?: EFSankeyNodesOrderByWithRelationInput | EFSankeyNodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EFSankeyNodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EFSankeyNodes
    **/
    _count?: true | EFSankeyNodesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EFSankeyNodesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EFSankeyNodesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EFSankeyNodesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EFSankeyNodesMaxAggregateInputType
  }

  export type GetEFSankeyNodesAggregateType<T extends EFSankeyNodesAggregateArgs> = {
        [P in keyof T & keyof AggregateEFSankeyNodes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEFSankeyNodes[P]>
      : GetScalarType<T[P], AggregateEFSankeyNodes[P]>
  }




  export type EFSankeyNodesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EFSankeyNodesWhereInput
    orderBy?: EFSankeyNodesOrderByWithAggregationInput | EFSankeyNodesOrderByWithAggregationInput[]
    by: EFSankeyNodesScalarFieldEnum[] | EFSankeyNodesScalarFieldEnum
    having?: EFSankeyNodesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EFSankeyNodesCountAggregateInputType | true
    _avg?: EFSankeyNodesAvgAggregateInputType
    _sum?: EFSankeyNodesSumAggregateInputType
    _min?: EFSankeyNodesMinAggregateInputType
    _max?: EFSankeyNodesMaxAggregateInputType
  }

  export type EFSankeyNodesGroupByOutputType = {
    id: number
    node: number | null
    name: string | null
    value: string | null
    unit: string | null
    _count: EFSankeyNodesCountAggregateOutputType | null
    _avg: EFSankeyNodesAvgAggregateOutputType | null
    _sum: EFSankeyNodesSumAggregateOutputType | null
    _min: EFSankeyNodesMinAggregateOutputType | null
    _max: EFSankeyNodesMaxAggregateOutputType | null
  }

  type GetEFSankeyNodesGroupByPayload<T extends EFSankeyNodesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EFSankeyNodesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EFSankeyNodesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EFSankeyNodesGroupByOutputType[P]>
            : GetScalarType<T[P], EFSankeyNodesGroupByOutputType[P]>
        }
      >
    >


  export type EFSankeyNodesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    node?: boolean
    name?: boolean
    value?: boolean
    unit?: boolean
  }, ExtArgs["result"]["eFSankeyNodes"]>



  export type EFSankeyNodesSelectScalar = {
    id?: boolean
    node?: boolean
    name?: boolean
    value?: boolean
    unit?: boolean
  }

  export type EFSankeyNodesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "node" | "name" | "value" | "unit", ExtArgs["result"]["eFSankeyNodes"]>

  export type $EFSankeyNodesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EFSankeyNodes"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      node: number | null
      name: string | null
      value: string | null
      unit: string | null
    }, ExtArgs["result"]["eFSankeyNodes"]>
    composites: {}
  }

  type EFSankeyNodesGetPayload<S extends boolean | null | undefined | EFSankeyNodesDefaultArgs> = $Result.GetResult<Prisma.$EFSankeyNodesPayload, S>

  type EFSankeyNodesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EFSankeyNodesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EFSankeyNodesCountAggregateInputType | true
    }

  export interface EFSankeyNodesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EFSankeyNodes'], meta: { name: 'EFSankeyNodes' } }
    /**
     * Find zero or one EFSankeyNodes that matches the filter.
     * @param {EFSankeyNodesFindUniqueArgs} args - Arguments to find a EFSankeyNodes
     * @example
     * // Get one EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFSankeyNodesFindUniqueArgs>(args: SelectSubset<T, EFSankeyNodesFindUniqueArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EFSankeyNodes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EFSankeyNodesFindUniqueOrThrowArgs} args - Arguments to find a EFSankeyNodes
     * @example
     * // Get one EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFSankeyNodesFindUniqueOrThrowArgs>(args: SelectSubset<T, EFSankeyNodesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFSankeyNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesFindFirstArgs} args - Arguments to find a EFSankeyNodes
     * @example
     * // Get one EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFSankeyNodesFindFirstArgs>(args?: SelectSubset<T, EFSankeyNodesFindFirstArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFSankeyNodes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesFindFirstOrThrowArgs} args - Arguments to find a EFSankeyNodes
     * @example
     * // Get one EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFSankeyNodesFindFirstOrThrowArgs>(args?: SelectSubset<T, EFSankeyNodesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EFSankeyNodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.findMany()
     * 
     * // Get first 10 EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eFSankeyNodesWithIdOnly = await prisma.eFSankeyNodes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EFSankeyNodesFindManyArgs>(args?: SelectSubset<T, EFSankeyNodesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EFSankeyNodes.
     * @param {EFSankeyNodesCreateArgs} args - Arguments to create a EFSankeyNodes.
     * @example
     * // Create one EFSankeyNodes
     * const EFSankeyNodes = await prisma.eFSankeyNodes.create({
     *   data: {
     *     // ... data to create a EFSankeyNodes
     *   }
     * })
     * 
     */
    create<T extends EFSankeyNodesCreateArgs>(args: SelectSubset<T, EFSankeyNodesCreateArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EFSankeyNodes.
     * @param {EFSankeyNodesCreateManyArgs} args - Arguments to create many EFSankeyNodes.
     * @example
     * // Create many EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EFSankeyNodesCreateManyArgs>(args?: SelectSubset<T, EFSankeyNodesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EFSankeyNodes.
     * @param {EFSankeyNodesDeleteArgs} args - Arguments to delete one EFSankeyNodes.
     * @example
     * // Delete one EFSankeyNodes
     * const EFSankeyNodes = await prisma.eFSankeyNodes.delete({
     *   where: {
     *     // ... filter to delete one EFSankeyNodes
     *   }
     * })
     * 
     */
    delete<T extends EFSankeyNodesDeleteArgs>(args: SelectSubset<T, EFSankeyNodesDeleteArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EFSankeyNodes.
     * @param {EFSankeyNodesUpdateArgs} args - Arguments to update one EFSankeyNodes.
     * @example
     * // Update one EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EFSankeyNodesUpdateArgs>(args: SelectSubset<T, EFSankeyNodesUpdateArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EFSankeyNodes.
     * @param {EFSankeyNodesDeleteManyArgs} args - Arguments to filter EFSankeyNodes to delete.
     * @example
     * // Delete a few EFSankeyNodes
     * const { count } = await prisma.eFSankeyNodes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EFSankeyNodesDeleteManyArgs>(args?: SelectSubset<T, EFSankeyNodesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EFSankeyNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EFSankeyNodesUpdateManyArgs>(args: SelectSubset<T, EFSankeyNodesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EFSankeyNodes.
     * @param {EFSankeyNodesUpsertArgs} args - Arguments to update or create a EFSankeyNodes.
     * @example
     * // Update or create a EFSankeyNodes
     * const eFSankeyNodes = await prisma.eFSankeyNodes.upsert({
     *   create: {
     *     // ... data to create a EFSankeyNodes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EFSankeyNodes we want to update
     *   }
     * })
     */
    upsert<T extends EFSankeyNodesUpsertArgs>(args: SelectSubset<T, EFSankeyNodesUpsertArgs<ExtArgs>>): Prisma__EFSankeyNodesClient<$Result.GetResult<Prisma.$EFSankeyNodesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EFSankeyNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesCountArgs} args - Arguments to filter EFSankeyNodes to count.
     * @example
     * // Count the number of EFSankeyNodes
     * const count = await prisma.eFSankeyNodes.count({
     *   where: {
     *     // ... the filter for the EFSankeyNodes we want to count
     *   }
     * })
    **/
    count<T extends EFSankeyNodesCountArgs>(
      args?: Subset<T, EFSankeyNodesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EFSankeyNodesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EFSankeyNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EFSankeyNodesAggregateArgs>(args: Subset<T, EFSankeyNodesAggregateArgs>): Prisma.PrismaPromise<GetEFSankeyNodesAggregateType<T>>

    /**
     * Group by EFSankeyNodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSankeyNodesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EFSankeyNodesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EFSankeyNodesGroupByArgs['orderBy'] }
        : { orderBy?: EFSankeyNodesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EFSankeyNodesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEFSankeyNodesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EFSankeyNodes model
   */
  readonly fields: EFSankeyNodesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EFSankeyNodes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EFSankeyNodesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EFSankeyNodes model
   */
  interface EFSankeyNodesFieldRefs {
    readonly id: FieldRef<"EFSankeyNodes", 'Int'>
    readonly node: FieldRef<"EFSankeyNodes", 'Int'>
    readonly name: FieldRef<"EFSankeyNodes", 'String'>
    readonly value: FieldRef<"EFSankeyNodes", 'String'>
    readonly unit: FieldRef<"EFSankeyNodes", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EFSankeyNodes findUnique
   */
  export type EFSankeyNodesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyNodes to fetch.
     */
    where: EFSankeyNodesWhereUniqueInput
  }

  /**
   * EFSankeyNodes findUniqueOrThrow
   */
  export type EFSankeyNodesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyNodes to fetch.
     */
    where: EFSankeyNodesWhereUniqueInput
  }

  /**
   * EFSankeyNodes findFirst
   */
  export type EFSankeyNodesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyNodes to fetch.
     */
    where?: EFSankeyNodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyNodes to fetch.
     */
    orderBy?: EFSankeyNodesOrderByWithRelationInput | EFSankeyNodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFSankeyNodes.
     */
    cursor?: EFSankeyNodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFSankeyNodes.
     */
    distinct?: EFSankeyNodesScalarFieldEnum | EFSankeyNodesScalarFieldEnum[]
  }

  /**
   * EFSankeyNodes findFirstOrThrow
   */
  export type EFSankeyNodesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyNodes to fetch.
     */
    where?: EFSankeyNodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyNodes to fetch.
     */
    orderBy?: EFSankeyNodesOrderByWithRelationInput | EFSankeyNodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFSankeyNodes.
     */
    cursor?: EFSankeyNodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyNodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFSankeyNodes.
     */
    distinct?: EFSankeyNodesScalarFieldEnum | EFSankeyNodesScalarFieldEnum[]
  }

  /**
   * EFSankeyNodes findMany
   */
  export type EFSankeyNodesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * Filter, which EFSankeyNodes to fetch.
     */
    where?: EFSankeyNodesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSankeyNodes to fetch.
     */
    orderBy?: EFSankeyNodesOrderByWithRelationInput | EFSankeyNodesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EFSankeyNodes.
     */
    cursor?: EFSankeyNodesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSankeyNodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSankeyNodes.
     */
    skip?: number
    distinct?: EFSankeyNodesScalarFieldEnum | EFSankeyNodesScalarFieldEnum[]
  }

  /**
   * EFSankeyNodes create
   */
  export type EFSankeyNodesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * The data needed to create a EFSankeyNodes.
     */
    data?: XOR<EFSankeyNodesCreateInput, EFSankeyNodesUncheckedCreateInput>
  }

  /**
   * EFSankeyNodes createMany
   */
  export type EFSankeyNodesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EFSankeyNodes.
     */
    data: EFSankeyNodesCreateManyInput | EFSankeyNodesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EFSankeyNodes update
   */
  export type EFSankeyNodesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * The data needed to update a EFSankeyNodes.
     */
    data: XOR<EFSankeyNodesUpdateInput, EFSankeyNodesUncheckedUpdateInput>
    /**
     * Choose, which EFSankeyNodes to update.
     */
    where: EFSankeyNodesWhereUniqueInput
  }

  /**
   * EFSankeyNodes updateMany
   */
  export type EFSankeyNodesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EFSankeyNodes.
     */
    data: XOR<EFSankeyNodesUpdateManyMutationInput, EFSankeyNodesUncheckedUpdateManyInput>
    /**
     * Filter which EFSankeyNodes to update
     */
    where?: EFSankeyNodesWhereInput
    /**
     * Limit how many EFSankeyNodes to update.
     */
    limit?: number
  }

  /**
   * EFSankeyNodes upsert
   */
  export type EFSankeyNodesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * The filter to search for the EFSankeyNodes to update in case it exists.
     */
    where: EFSankeyNodesWhereUniqueInput
    /**
     * In case the EFSankeyNodes found by the `where` argument doesn't exist, create a new EFSankeyNodes with this data.
     */
    create: XOR<EFSankeyNodesCreateInput, EFSankeyNodesUncheckedCreateInput>
    /**
     * In case the EFSankeyNodes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EFSankeyNodesUpdateInput, EFSankeyNodesUncheckedUpdateInput>
  }

  /**
   * EFSankeyNodes delete
   */
  export type EFSankeyNodesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
    /**
     * Filter which EFSankeyNodes to delete.
     */
    where: EFSankeyNodesWhereUniqueInput
  }

  /**
   * EFSankeyNodes deleteMany
   */
  export type EFSankeyNodesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFSankeyNodes to delete
     */
    where?: EFSankeyNodesWhereInput
    /**
     * Limit how many EFSankeyNodes to delete.
     */
    limit?: number
  }

  /**
   * EFSankeyNodes without action
   */
  export type EFSankeyNodesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSankeyNodes
     */
    select?: EFSankeyNodesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSankeyNodes
     */
    omit?: EFSankeyNodesOmit<ExtArgs> | null
  }


  /**
   * Model EFSummaryTable
   */

  export type AggregateEFSummaryTable = {
    _count: EFSummaryTableCountAggregateOutputType | null
    _avg: EFSummaryTableAvgAggregateOutputType | null
    _sum: EFSummaryTableSumAggregateOutputType | null
    _min: EFSummaryTableMinAggregateOutputType | null
    _max: EFSummaryTableMaxAggregateOutputType | null
  }

  export type EFSummaryTableAvgAggregateOutputType = {
    id: number | null
  }

  export type EFSummaryTableSumAggregateOutputType = {
    id: number | null
  }

  export type EFSummaryTableMinAggregateOutputType = {
    id: number | null
    name: string | null
    total: string | null
    percentage: string | null
    unit: string | null
  }

  export type EFSummaryTableMaxAggregateOutputType = {
    id: number | null
    name: string | null
    total: string | null
    percentage: string | null
    unit: string | null
  }

  export type EFSummaryTableCountAggregateOutputType = {
    id: number
    name: number
    total: number
    percentage: number
    unit: number
    _all: number
  }


  export type EFSummaryTableAvgAggregateInputType = {
    id?: true
  }

  export type EFSummaryTableSumAggregateInputType = {
    id?: true
  }

  export type EFSummaryTableMinAggregateInputType = {
    id?: true
    name?: true
    total?: true
    percentage?: true
    unit?: true
  }

  export type EFSummaryTableMaxAggregateInputType = {
    id?: true
    name?: true
    total?: true
    percentage?: true
    unit?: true
  }

  export type EFSummaryTableCountAggregateInputType = {
    id?: true
    name?: true
    total?: true
    percentage?: true
    unit?: true
    _all?: true
  }

  export type EFSummaryTableAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFSummaryTable to aggregate.
     */
    where?: EFSummaryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSummaryTables to fetch.
     */
    orderBy?: EFSummaryTableOrderByWithRelationInput | EFSummaryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EFSummaryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSummaryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSummaryTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EFSummaryTables
    **/
    _count?: true | EFSummaryTableCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EFSummaryTableAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EFSummaryTableSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EFSummaryTableMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EFSummaryTableMaxAggregateInputType
  }

  export type GetEFSummaryTableAggregateType<T extends EFSummaryTableAggregateArgs> = {
        [P in keyof T & keyof AggregateEFSummaryTable]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEFSummaryTable[P]>
      : GetScalarType<T[P], AggregateEFSummaryTable[P]>
  }




  export type EFSummaryTableGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EFSummaryTableWhereInput
    orderBy?: EFSummaryTableOrderByWithAggregationInput | EFSummaryTableOrderByWithAggregationInput[]
    by: EFSummaryTableScalarFieldEnum[] | EFSummaryTableScalarFieldEnum
    having?: EFSummaryTableScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EFSummaryTableCountAggregateInputType | true
    _avg?: EFSummaryTableAvgAggregateInputType
    _sum?: EFSummaryTableSumAggregateInputType
    _min?: EFSummaryTableMinAggregateInputType
    _max?: EFSummaryTableMaxAggregateInputType
  }

  export type EFSummaryTableGroupByOutputType = {
    id: number
    name: string | null
    total: string | null
    percentage: string | null
    unit: string | null
    _count: EFSummaryTableCountAggregateOutputType | null
    _avg: EFSummaryTableAvgAggregateOutputType | null
    _sum: EFSummaryTableSumAggregateOutputType | null
    _min: EFSummaryTableMinAggregateOutputType | null
    _max: EFSummaryTableMaxAggregateOutputType | null
  }

  type GetEFSummaryTableGroupByPayload<T extends EFSummaryTableGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EFSummaryTableGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EFSummaryTableGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EFSummaryTableGroupByOutputType[P]>
            : GetScalarType<T[P], EFSummaryTableGroupByOutputType[P]>
        }
      >
    >


  export type EFSummaryTableSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    total?: boolean
    percentage?: boolean
    unit?: boolean
  }, ExtArgs["result"]["eFSummaryTable"]>



  export type EFSummaryTableSelectScalar = {
    id?: boolean
    name?: boolean
    total?: boolean
    percentage?: boolean
    unit?: boolean
  }

  export type EFSummaryTableOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "total" | "percentage" | "unit", ExtArgs["result"]["eFSummaryTable"]>

  export type $EFSummaryTablePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EFSummaryTable"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string | null
      total: string | null
      percentage: string | null
      unit: string | null
    }, ExtArgs["result"]["eFSummaryTable"]>
    composites: {}
  }

  type EFSummaryTableGetPayload<S extends boolean | null | undefined | EFSummaryTableDefaultArgs> = $Result.GetResult<Prisma.$EFSummaryTablePayload, S>

  type EFSummaryTableCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EFSummaryTableFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EFSummaryTableCountAggregateInputType | true
    }

  export interface EFSummaryTableDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EFSummaryTable'], meta: { name: 'EFSummaryTable' } }
    /**
     * Find zero or one EFSummaryTable that matches the filter.
     * @param {EFSummaryTableFindUniqueArgs} args - Arguments to find a EFSummaryTable
     * @example
     * // Get one EFSummaryTable
     * const eFSummaryTable = await prisma.eFSummaryTable.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EFSummaryTableFindUniqueArgs>(args: SelectSubset<T, EFSummaryTableFindUniqueArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EFSummaryTable that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EFSummaryTableFindUniqueOrThrowArgs} args - Arguments to find a EFSummaryTable
     * @example
     * // Get one EFSummaryTable
     * const eFSummaryTable = await prisma.eFSummaryTable.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EFSummaryTableFindUniqueOrThrowArgs>(args: SelectSubset<T, EFSummaryTableFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFSummaryTable that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableFindFirstArgs} args - Arguments to find a EFSummaryTable
     * @example
     * // Get one EFSummaryTable
     * const eFSummaryTable = await prisma.eFSummaryTable.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EFSummaryTableFindFirstArgs>(args?: SelectSubset<T, EFSummaryTableFindFirstArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EFSummaryTable that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableFindFirstOrThrowArgs} args - Arguments to find a EFSummaryTable
     * @example
     * // Get one EFSummaryTable
     * const eFSummaryTable = await prisma.eFSummaryTable.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EFSummaryTableFindFirstOrThrowArgs>(args?: SelectSubset<T, EFSummaryTableFindFirstOrThrowArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EFSummaryTables that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EFSummaryTables
     * const eFSummaryTables = await prisma.eFSummaryTable.findMany()
     * 
     * // Get first 10 EFSummaryTables
     * const eFSummaryTables = await prisma.eFSummaryTable.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eFSummaryTableWithIdOnly = await prisma.eFSummaryTable.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EFSummaryTableFindManyArgs>(args?: SelectSubset<T, EFSummaryTableFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EFSummaryTable.
     * @param {EFSummaryTableCreateArgs} args - Arguments to create a EFSummaryTable.
     * @example
     * // Create one EFSummaryTable
     * const EFSummaryTable = await prisma.eFSummaryTable.create({
     *   data: {
     *     // ... data to create a EFSummaryTable
     *   }
     * })
     * 
     */
    create<T extends EFSummaryTableCreateArgs>(args: SelectSubset<T, EFSummaryTableCreateArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EFSummaryTables.
     * @param {EFSummaryTableCreateManyArgs} args - Arguments to create many EFSummaryTables.
     * @example
     * // Create many EFSummaryTables
     * const eFSummaryTable = await prisma.eFSummaryTable.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EFSummaryTableCreateManyArgs>(args?: SelectSubset<T, EFSummaryTableCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EFSummaryTable.
     * @param {EFSummaryTableDeleteArgs} args - Arguments to delete one EFSummaryTable.
     * @example
     * // Delete one EFSummaryTable
     * const EFSummaryTable = await prisma.eFSummaryTable.delete({
     *   where: {
     *     // ... filter to delete one EFSummaryTable
     *   }
     * })
     * 
     */
    delete<T extends EFSummaryTableDeleteArgs>(args: SelectSubset<T, EFSummaryTableDeleteArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EFSummaryTable.
     * @param {EFSummaryTableUpdateArgs} args - Arguments to update one EFSummaryTable.
     * @example
     * // Update one EFSummaryTable
     * const eFSummaryTable = await prisma.eFSummaryTable.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EFSummaryTableUpdateArgs>(args: SelectSubset<T, EFSummaryTableUpdateArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EFSummaryTables.
     * @param {EFSummaryTableDeleteManyArgs} args - Arguments to filter EFSummaryTables to delete.
     * @example
     * // Delete a few EFSummaryTables
     * const { count } = await prisma.eFSummaryTable.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EFSummaryTableDeleteManyArgs>(args?: SelectSubset<T, EFSummaryTableDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EFSummaryTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EFSummaryTables
     * const eFSummaryTable = await prisma.eFSummaryTable.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EFSummaryTableUpdateManyArgs>(args: SelectSubset<T, EFSummaryTableUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EFSummaryTable.
     * @param {EFSummaryTableUpsertArgs} args - Arguments to update or create a EFSummaryTable.
     * @example
     * // Update or create a EFSummaryTable
     * const eFSummaryTable = await prisma.eFSummaryTable.upsert({
     *   create: {
     *     // ... data to create a EFSummaryTable
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EFSummaryTable we want to update
     *   }
     * })
     */
    upsert<T extends EFSummaryTableUpsertArgs>(args: SelectSubset<T, EFSummaryTableUpsertArgs<ExtArgs>>): Prisma__EFSummaryTableClient<$Result.GetResult<Prisma.$EFSummaryTablePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EFSummaryTables.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableCountArgs} args - Arguments to filter EFSummaryTables to count.
     * @example
     * // Count the number of EFSummaryTables
     * const count = await prisma.eFSummaryTable.count({
     *   where: {
     *     // ... the filter for the EFSummaryTables we want to count
     *   }
     * })
    **/
    count<T extends EFSummaryTableCountArgs>(
      args?: Subset<T, EFSummaryTableCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EFSummaryTableCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EFSummaryTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EFSummaryTableAggregateArgs>(args: Subset<T, EFSummaryTableAggregateArgs>): Prisma.PrismaPromise<GetEFSummaryTableAggregateType<T>>

    /**
     * Group by EFSummaryTable.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EFSummaryTableGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EFSummaryTableGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EFSummaryTableGroupByArgs['orderBy'] }
        : { orderBy?: EFSummaryTableGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EFSummaryTableGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEFSummaryTableGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EFSummaryTable model
   */
  readonly fields: EFSummaryTableFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EFSummaryTable.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EFSummaryTableClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EFSummaryTable model
   */
  interface EFSummaryTableFieldRefs {
    readonly id: FieldRef<"EFSummaryTable", 'Int'>
    readonly name: FieldRef<"EFSummaryTable", 'String'>
    readonly total: FieldRef<"EFSummaryTable", 'String'>
    readonly percentage: FieldRef<"EFSummaryTable", 'String'>
    readonly unit: FieldRef<"EFSummaryTable", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EFSummaryTable findUnique
   */
  export type EFSummaryTableFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * Filter, which EFSummaryTable to fetch.
     */
    where: EFSummaryTableWhereUniqueInput
  }

  /**
   * EFSummaryTable findUniqueOrThrow
   */
  export type EFSummaryTableFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * Filter, which EFSummaryTable to fetch.
     */
    where: EFSummaryTableWhereUniqueInput
  }

  /**
   * EFSummaryTable findFirst
   */
  export type EFSummaryTableFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * Filter, which EFSummaryTable to fetch.
     */
    where?: EFSummaryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSummaryTables to fetch.
     */
    orderBy?: EFSummaryTableOrderByWithRelationInput | EFSummaryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFSummaryTables.
     */
    cursor?: EFSummaryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSummaryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSummaryTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFSummaryTables.
     */
    distinct?: EFSummaryTableScalarFieldEnum | EFSummaryTableScalarFieldEnum[]
  }

  /**
   * EFSummaryTable findFirstOrThrow
   */
  export type EFSummaryTableFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * Filter, which EFSummaryTable to fetch.
     */
    where?: EFSummaryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSummaryTables to fetch.
     */
    orderBy?: EFSummaryTableOrderByWithRelationInput | EFSummaryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EFSummaryTables.
     */
    cursor?: EFSummaryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSummaryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSummaryTables.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EFSummaryTables.
     */
    distinct?: EFSummaryTableScalarFieldEnum | EFSummaryTableScalarFieldEnum[]
  }

  /**
   * EFSummaryTable findMany
   */
  export type EFSummaryTableFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * Filter, which EFSummaryTables to fetch.
     */
    where?: EFSummaryTableWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EFSummaryTables to fetch.
     */
    orderBy?: EFSummaryTableOrderByWithRelationInput | EFSummaryTableOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EFSummaryTables.
     */
    cursor?: EFSummaryTableWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EFSummaryTables from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EFSummaryTables.
     */
    skip?: number
    distinct?: EFSummaryTableScalarFieldEnum | EFSummaryTableScalarFieldEnum[]
  }

  /**
   * EFSummaryTable create
   */
  export type EFSummaryTableCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * The data needed to create a EFSummaryTable.
     */
    data?: XOR<EFSummaryTableCreateInput, EFSummaryTableUncheckedCreateInput>
  }

  /**
   * EFSummaryTable createMany
   */
  export type EFSummaryTableCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EFSummaryTables.
     */
    data: EFSummaryTableCreateManyInput | EFSummaryTableCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EFSummaryTable update
   */
  export type EFSummaryTableUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * The data needed to update a EFSummaryTable.
     */
    data: XOR<EFSummaryTableUpdateInput, EFSummaryTableUncheckedUpdateInput>
    /**
     * Choose, which EFSummaryTable to update.
     */
    where: EFSummaryTableWhereUniqueInput
  }

  /**
   * EFSummaryTable updateMany
   */
  export type EFSummaryTableUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EFSummaryTables.
     */
    data: XOR<EFSummaryTableUpdateManyMutationInput, EFSummaryTableUncheckedUpdateManyInput>
    /**
     * Filter which EFSummaryTables to update
     */
    where?: EFSummaryTableWhereInput
    /**
     * Limit how many EFSummaryTables to update.
     */
    limit?: number
  }

  /**
   * EFSummaryTable upsert
   */
  export type EFSummaryTableUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * The filter to search for the EFSummaryTable to update in case it exists.
     */
    where: EFSummaryTableWhereUniqueInput
    /**
     * In case the EFSummaryTable found by the `where` argument doesn't exist, create a new EFSummaryTable with this data.
     */
    create: XOR<EFSummaryTableCreateInput, EFSummaryTableUncheckedCreateInput>
    /**
     * In case the EFSummaryTable was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EFSummaryTableUpdateInput, EFSummaryTableUncheckedUpdateInput>
  }

  /**
   * EFSummaryTable delete
   */
  export type EFSummaryTableDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
    /**
     * Filter which EFSummaryTable to delete.
     */
    where: EFSummaryTableWhereUniqueInput
  }

  /**
   * EFSummaryTable deleteMany
   */
  export type EFSummaryTableDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EFSummaryTables to delete
     */
    where?: EFSummaryTableWhereInput
    /**
     * Limit how many EFSummaryTables to delete.
     */
    limit?: number
  }

  /**
   * EFSummaryTable without action
   */
  export type EFSummaryTableDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EFSummaryTable
     */
    select?: EFSummaryTableSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EFSummaryTable
     */
    omit?: EFSummaryTableOmit<ExtArgs> | null
  }


  /**
   * Model SCRanking
   */

  export type AggregateSCRanking = {
    _count: SCRankingCountAggregateOutputType | null
    _avg: SCRankingAvgAggregateOutputType | null
    _sum: SCRankingSumAggregateOutputType | null
    _min: SCRankingMinAggregateOutputType | null
    _max: SCRankingMaxAggregateOutputType | null
  }

  export type SCRankingAvgAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type SCRankingSumAggregateOutputType = {
    id: number | null
    rank: number | null
  }

  export type SCRankingMinAggregateOutputType = {
    id: number | null
    supplier: string | null
    emission: string | null
    intensity: string | null
    rank: number | null
    compliance: string | null
  }

  export type SCRankingMaxAggregateOutputType = {
    id: number | null
    supplier: string | null
    emission: string | null
    intensity: string | null
    rank: number | null
    compliance: string | null
  }

  export type SCRankingCountAggregateOutputType = {
    id: number
    supplier: number
    emission: number
    intensity: number
    rank: number
    compliance: number
    _all: number
  }


  export type SCRankingAvgAggregateInputType = {
    id?: true
    rank?: true
  }

  export type SCRankingSumAggregateInputType = {
    id?: true
    rank?: true
  }

  export type SCRankingMinAggregateInputType = {
    id?: true
    supplier?: true
    emission?: true
    intensity?: true
    rank?: true
    compliance?: true
  }

  export type SCRankingMaxAggregateInputType = {
    id?: true
    supplier?: true
    emission?: true
    intensity?: true
    rank?: true
    compliance?: true
  }

  export type SCRankingCountAggregateInputType = {
    id?: true
    supplier?: true
    emission?: true
    intensity?: true
    rank?: true
    compliance?: true
    _all?: true
  }

  export type SCRankingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SCRanking to aggregate.
     */
    where?: SCRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCRankings to fetch.
     */
    orderBy?: SCRankingOrderByWithRelationInput | SCRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SCRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SCRankings
    **/
    _count?: true | SCRankingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SCRankingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SCRankingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SCRankingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SCRankingMaxAggregateInputType
  }

  export type GetSCRankingAggregateType<T extends SCRankingAggregateArgs> = {
        [P in keyof T & keyof AggregateSCRanking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSCRanking[P]>
      : GetScalarType<T[P], AggregateSCRanking[P]>
  }




  export type SCRankingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SCRankingWhereInput
    orderBy?: SCRankingOrderByWithAggregationInput | SCRankingOrderByWithAggregationInput[]
    by: SCRankingScalarFieldEnum[] | SCRankingScalarFieldEnum
    having?: SCRankingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SCRankingCountAggregateInputType | true
    _avg?: SCRankingAvgAggregateInputType
    _sum?: SCRankingSumAggregateInputType
    _min?: SCRankingMinAggregateInputType
    _max?: SCRankingMaxAggregateInputType
  }

  export type SCRankingGroupByOutputType = {
    id: number
    supplier: string | null
    emission: string | null
    intensity: string | null
    rank: number | null
    compliance: string | null
    _count: SCRankingCountAggregateOutputType | null
    _avg: SCRankingAvgAggregateOutputType | null
    _sum: SCRankingSumAggregateOutputType | null
    _min: SCRankingMinAggregateOutputType | null
    _max: SCRankingMaxAggregateOutputType | null
  }

  type GetSCRankingGroupByPayload<T extends SCRankingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SCRankingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SCRankingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SCRankingGroupByOutputType[P]>
            : GetScalarType<T[P], SCRankingGroupByOutputType[P]>
        }
      >
    >


  export type SCRankingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    supplier?: boolean
    emission?: boolean
    intensity?: boolean
    rank?: boolean
    compliance?: boolean
  }, ExtArgs["result"]["sCRanking"]>



  export type SCRankingSelectScalar = {
    id?: boolean
    supplier?: boolean
    emission?: boolean
    intensity?: boolean
    rank?: boolean
    compliance?: boolean
  }

  export type SCRankingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "supplier" | "emission" | "intensity" | "rank" | "compliance", ExtArgs["result"]["sCRanking"]>

  export type $SCRankingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SCRanking"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      supplier: string | null
      emission: string | null
      intensity: string | null
      rank: number | null
      compliance: string | null
    }, ExtArgs["result"]["sCRanking"]>
    composites: {}
  }

  type SCRankingGetPayload<S extends boolean | null | undefined | SCRankingDefaultArgs> = $Result.GetResult<Prisma.$SCRankingPayload, S>

  type SCRankingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SCRankingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SCRankingCountAggregateInputType | true
    }

  export interface SCRankingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SCRanking'], meta: { name: 'SCRanking' } }
    /**
     * Find zero or one SCRanking that matches the filter.
     * @param {SCRankingFindUniqueArgs} args - Arguments to find a SCRanking
     * @example
     * // Get one SCRanking
     * const sCRanking = await prisma.sCRanking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SCRankingFindUniqueArgs>(args: SelectSubset<T, SCRankingFindUniqueArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SCRanking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SCRankingFindUniqueOrThrowArgs} args - Arguments to find a SCRanking
     * @example
     * // Get one SCRanking
     * const sCRanking = await prisma.sCRanking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SCRankingFindUniqueOrThrowArgs>(args: SelectSubset<T, SCRankingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SCRanking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingFindFirstArgs} args - Arguments to find a SCRanking
     * @example
     * // Get one SCRanking
     * const sCRanking = await prisma.sCRanking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SCRankingFindFirstArgs>(args?: SelectSubset<T, SCRankingFindFirstArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SCRanking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingFindFirstOrThrowArgs} args - Arguments to find a SCRanking
     * @example
     * // Get one SCRanking
     * const sCRanking = await prisma.sCRanking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SCRankingFindFirstOrThrowArgs>(args?: SelectSubset<T, SCRankingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SCRankings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SCRankings
     * const sCRankings = await prisma.sCRanking.findMany()
     * 
     * // Get first 10 SCRankings
     * const sCRankings = await prisma.sCRanking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sCRankingWithIdOnly = await prisma.sCRanking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SCRankingFindManyArgs>(args?: SelectSubset<T, SCRankingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SCRanking.
     * @param {SCRankingCreateArgs} args - Arguments to create a SCRanking.
     * @example
     * // Create one SCRanking
     * const SCRanking = await prisma.sCRanking.create({
     *   data: {
     *     // ... data to create a SCRanking
     *   }
     * })
     * 
     */
    create<T extends SCRankingCreateArgs>(args: SelectSubset<T, SCRankingCreateArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SCRankings.
     * @param {SCRankingCreateManyArgs} args - Arguments to create many SCRankings.
     * @example
     * // Create many SCRankings
     * const sCRanking = await prisma.sCRanking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SCRankingCreateManyArgs>(args?: SelectSubset<T, SCRankingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SCRanking.
     * @param {SCRankingDeleteArgs} args - Arguments to delete one SCRanking.
     * @example
     * // Delete one SCRanking
     * const SCRanking = await prisma.sCRanking.delete({
     *   where: {
     *     // ... filter to delete one SCRanking
     *   }
     * })
     * 
     */
    delete<T extends SCRankingDeleteArgs>(args: SelectSubset<T, SCRankingDeleteArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SCRanking.
     * @param {SCRankingUpdateArgs} args - Arguments to update one SCRanking.
     * @example
     * // Update one SCRanking
     * const sCRanking = await prisma.sCRanking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SCRankingUpdateArgs>(args: SelectSubset<T, SCRankingUpdateArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SCRankings.
     * @param {SCRankingDeleteManyArgs} args - Arguments to filter SCRankings to delete.
     * @example
     * // Delete a few SCRankings
     * const { count } = await prisma.sCRanking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SCRankingDeleteManyArgs>(args?: SelectSubset<T, SCRankingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SCRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SCRankings
     * const sCRanking = await prisma.sCRanking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SCRankingUpdateManyArgs>(args: SelectSubset<T, SCRankingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SCRanking.
     * @param {SCRankingUpsertArgs} args - Arguments to update or create a SCRanking.
     * @example
     * // Update or create a SCRanking
     * const sCRanking = await prisma.sCRanking.upsert({
     *   create: {
     *     // ... data to create a SCRanking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SCRanking we want to update
     *   }
     * })
     */
    upsert<T extends SCRankingUpsertArgs>(args: SelectSubset<T, SCRankingUpsertArgs<ExtArgs>>): Prisma__SCRankingClient<$Result.GetResult<Prisma.$SCRankingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SCRankings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingCountArgs} args - Arguments to filter SCRankings to count.
     * @example
     * // Count the number of SCRankings
     * const count = await prisma.sCRanking.count({
     *   where: {
     *     // ... the filter for the SCRankings we want to count
     *   }
     * })
    **/
    count<T extends SCRankingCountArgs>(
      args?: Subset<T, SCRankingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SCRankingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SCRanking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SCRankingAggregateArgs>(args: Subset<T, SCRankingAggregateArgs>): Prisma.PrismaPromise<GetSCRankingAggregateType<T>>

    /**
     * Group by SCRanking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCRankingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SCRankingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SCRankingGroupByArgs['orderBy'] }
        : { orderBy?: SCRankingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SCRankingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSCRankingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SCRanking model
   */
  readonly fields: SCRankingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SCRanking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SCRankingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SCRanking model
   */
  interface SCRankingFieldRefs {
    readonly id: FieldRef<"SCRanking", 'Int'>
    readonly supplier: FieldRef<"SCRanking", 'String'>
    readonly emission: FieldRef<"SCRanking", 'String'>
    readonly intensity: FieldRef<"SCRanking", 'String'>
    readonly rank: FieldRef<"SCRanking", 'Int'>
    readonly compliance: FieldRef<"SCRanking", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SCRanking findUnique
   */
  export type SCRankingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * Filter, which SCRanking to fetch.
     */
    where: SCRankingWhereUniqueInput
  }

  /**
   * SCRanking findUniqueOrThrow
   */
  export type SCRankingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * Filter, which SCRanking to fetch.
     */
    where: SCRankingWhereUniqueInput
  }

  /**
   * SCRanking findFirst
   */
  export type SCRankingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * Filter, which SCRanking to fetch.
     */
    where?: SCRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCRankings to fetch.
     */
    orderBy?: SCRankingOrderByWithRelationInput | SCRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SCRankings.
     */
    cursor?: SCRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SCRankings.
     */
    distinct?: SCRankingScalarFieldEnum | SCRankingScalarFieldEnum[]
  }

  /**
   * SCRanking findFirstOrThrow
   */
  export type SCRankingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * Filter, which SCRanking to fetch.
     */
    where?: SCRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCRankings to fetch.
     */
    orderBy?: SCRankingOrderByWithRelationInput | SCRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SCRankings.
     */
    cursor?: SCRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCRankings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SCRankings.
     */
    distinct?: SCRankingScalarFieldEnum | SCRankingScalarFieldEnum[]
  }

  /**
   * SCRanking findMany
   */
  export type SCRankingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * Filter, which SCRankings to fetch.
     */
    where?: SCRankingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCRankings to fetch.
     */
    orderBy?: SCRankingOrderByWithRelationInput | SCRankingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SCRankings.
     */
    cursor?: SCRankingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCRankings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCRankings.
     */
    skip?: number
    distinct?: SCRankingScalarFieldEnum | SCRankingScalarFieldEnum[]
  }

  /**
   * SCRanking create
   */
  export type SCRankingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * The data needed to create a SCRanking.
     */
    data?: XOR<SCRankingCreateInput, SCRankingUncheckedCreateInput>
  }

  /**
   * SCRanking createMany
   */
  export type SCRankingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SCRankings.
     */
    data: SCRankingCreateManyInput | SCRankingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SCRanking update
   */
  export type SCRankingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * The data needed to update a SCRanking.
     */
    data: XOR<SCRankingUpdateInput, SCRankingUncheckedUpdateInput>
    /**
     * Choose, which SCRanking to update.
     */
    where: SCRankingWhereUniqueInput
  }

  /**
   * SCRanking updateMany
   */
  export type SCRankingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SCRankings.
     */
    data: XOR<SCRankingUpdateManyMutationInput, SCRankingUncheckedUpdateManyInput>
    /**
     * Filter which SCRankings to update
     */
    where?: SCRankingWhereInput
    /**
     * Limit how many SCRankings to update.
     */
    limit?: number
  }

  /**
   * SCRanking upsert
   */
  export type SCRankingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * The filter to search for the SCRanking to update in case it exists.
     */
    where: SCRankingWhereUniqueInput
    /**
     * In case the SCRanking found by the `where` argument doesn't exist, create a new SCRanking with this data.
     */
    create: XOR<SCRankingCreateInput, SCRankingUncheckedCreateInput>
    /**
     * In case the SCRanking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SCRankingUpdateInput, SCRankingUncheckedUpdateInput>
  }

  /**
   * SCRanking delete
   */
  export type SCRankingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
    /**
     * Filter which SCRanking to delete.
     */
    where: SCRankingWhereUniqueInput
  }

  /**
   * SCRanking deleteMany
   */
  export type SCRankingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SCRankings to delete
     */
    where?: SCRankingWhereInput
    /**
     * Limit how many SCRankings to delete.
     */
    limit?: number
  }

  /**
   * SCRanking without action
   */
  export type SCRankingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCRanking
     */
    select?: SCRankingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCRanking
     */
    omit?: SCRankingOmit<ExtArgs> | null
  }


  /**
   * Model SCSankeyData
   */

  export type AggregateSCSankeyData = {
    _count: SCSankeyDataCountAggregateOutputType | null
    _avg: SCSankeyDataAvgAggregateOutputType | null
    _sum: SCSankeyDataSumAggregateOutputType | null
    _min: SCSankeyDataMinAggregateOutputType | null
    _max: SCSankeyDataMaxAggregateOutputType | null
  }

  export type SCSankeyDataAvgAggregateOutputType = {
    id: number | null
    node: number | null
    source: number | null
    target: number | null
  }

  export type SCSankeyDataSumAggregateOutputType = {
    id: number | null
    node: number | null
    source: number | null
    target: number | null
  }

  export type SCSankeyDataMinAggregateOutputType = {
    id: number | null
    node: number | null
    name: string | null
    value: string | null
    source: number | null
    target: number | null
    co2: string | null
    type: string | null
  }

  export type SCSankeyDataMaxAggregateOutputType = {
    id: number | null
    node: number | null
    name: string | null
    value: string | null
    source: number | null
    target: number | null
    co2: string | null
    type: string | null
  }

  export type SCSankeyDataCountAggregateOutputType = {
    id: number
    node: number
    name: number
    value: number
    source: number
    target: number
    co2: number
    type: number
    _all: number
  }


  export type SCSankeyDataAvgAggregateInputType = {
    id?: true
    node?: true
    source?: true
    target?: true
  }

  export type SCSankeyDataSumAggregateInputType = {
    id?: true
    node?: true
    source?: true
    target?: true
  }

  export type SCSankeyDataMinAggregateInputType = {
    id?: true
    node?: true
    name?: true
    value?: true
    source?: true
    target?: true
    co2?: true
    type?: true
  }

  export type SCSankeyDataMaxAggregateInputType = {
    id?: true
    node?: true
    name?: true
    value?: true
    source?: true
    target?: true
    co2?: true
    type?: true
  }

  export type SCSankeyDataCountAggregateInputType = {
    id?: true
    node?: true
    name?: true
    value?: true
    source?: true
    target?: true
    co2?: true
    type?: true
    _all?: true
  }

  export type SCSankeyDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SCSankeyData to aggregate.
     */
    where?: SCSankeyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCSankeyData to fetch.
     */
    orderBy?: SCSankeyDataOrderByWithRelationInput | SCSankeyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SCSankeyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCSankeyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCSankeyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SCSankeyData
    **/
    _count?: true | SCSankeyDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SCSankeyDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SCSankeyDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SCSankeyDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SCSankeyDataMaxAggregateInputType
  }

  export type GetSCSankeyDataAggregateType<T extends SCSankeyDataAggregateArgs> = {
        [P in keyof T & keyof AggregateSCSankeyData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSCSankeyData[P]>
      : GetScalarType<T[P], AggregateSCSankeyData[P]>
  }




  export type SCSankeyDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SCSankeyDataWhereInput
    orderBy?: SCSankeyDataOrderByWithAggregationInput | SCSankeyDataOrderByWithAggregationInput[]
    by: SCSankeyDataScalarFieldEnum[] | SCSankeyDataScalarFieldEnum
    having?: SCSankeyDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SCSankeyDataCountAggregateInputType | true
    _avg?: SCSankeyDataAvgAggregateInputType
    _sum?: SCSankeyDataSumAggregateInputType
    _min?: SCSankeyDataMinAggregateInputType
    _max?: SCSankeyDataMaxAggregateInputType
  }

  export type SCSankeyDataGroupByOutputType = {
    id: number
    node: number | null
    name: string | null
    value: string | null
    source: number | null
    target: number | null
    co2: string | null
    type: string | null
    _count: SCSankeyDataCountAggregateOutputType | null
    _avg: SCSankeyDataAvgAggregateOutputType | null
    _sum: SCSankeyDataSumAggregateOutputType | null
    _min: SCSankeyDataMinAggregateOutputType | null
    _max: SCSankeyDataMaxAggregateOutputType | null
  }

  type GetSCSankeyDataGroupByPayload<T extends SCSankeyDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SCSankeyDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SCSankeyDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SCSankeyDataGroupByOutputType[P]>
            : GetScalarType<T[P], SCSankeyDataGroupByOutputType[P]>
        }
      >
    >


  export type SCSankeyDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    node?: boolean
    name?: boolean
    value?: boolean
    source?: boolean
    target?: boolean
    co2?: boolean
    type?: boolean
  }, ExtArgs["result"]["sCSankeyData"]>



  export type SCSankeyDataSelectScalar = {
    id?: boolean
    node?: boolean
    name?: boolean
    value?: boolean
    source?: boolean
    target?: boolean
    co2?: boolean
    type?: boolean
  }

  export type SCSankeyDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "node" | "name" | "value" | "source" | "target" | "co2" | "type", ExtArgs["result"]["sCSankeyData"]>

  export type $SCSankeyDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SCSankeyData"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      node: number | null
      name: string | null
      value: string | null
      source: number | null
      target: number | null
      co2: string | null
      type: string | null
    }, ExtArgs["result"]["sCSankeyData"]>
    composites: {}
  }

  type SCSankeyDataGetPayload<S extends boolean | null | undefined | SCSankeyDataDefaultArgs> = $Result.GetResult<Prisma.$SCSankeyDataPayload, S>

  type SCSankeyDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SCSankeyDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SCSankeyDataCountAggregateInputType | true
    }

  export interface SCSankeyDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SCSankeyData'], meta: { name: 'SCSankeyData' } }
    /**
     * Find zero or one SCSankeyData that matches the filter.
     * @param {SCSankeyDataFindUniqueArgs} args - Arguments to find a SCSankeyData
     * @example
     * // Get one SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SCSankeyDataFindUniqueArgs>(args: SelectSubset<T, SCSankeyDataFindUniqueArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SCSankeyData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SCSankeyDataFindUniqueOrThrowArgs} args - Arguments to find a SCSankeyData
     * @example
     * // Get one SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SCSankeyDataFindUniqueOrThrowArgs>(args: SelectSubset<T, SCSankeyDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SCSankeyData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataFindFirstArgs} args - Arguments to find a SCSankeyData
     * @example
     * // Get one SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SCSankeyDataFindFirstArgs>(args?: SelectSubset<T, SCSankeyDataFindFirstArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SCSankeyData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataFindFirstOrThrowArgs} args - Arguments to find a SCSankeyData
     * @example
     * // Get one SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SCSankeyDataFindFirstOrThrowArgs>(args?: SelectSubset<T, SCSankeyDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SCSankeyData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.findMany()
     * 
     * // Get first 10 SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sCSankeyDataWithIdOnly = await prisma.sCSankeyData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SCSankeyDataFindManyArgs>(args?: SelectSubset<T, SCSankeyDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SCSankeyData.
     * @param {SCSankeyDataCreateArgs} args - Arguments to create a SCSankeyData.
     * @example
     * // Create one SCSankeyData
     * const SCSankeyData = await prisma.sCSankeyData.create({
     *   data: {
     *     // ... data to create a SCSankeyData
     *   }
     * })
     * 
     */
    create<T extends SCSankeyDataCreateArgs>(args: SelectSubset<T, SCSankeyDataCreateArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SCSankeyData.
     * @param {SCSankeyDataCreateManyArgs} args - Arguments to create many SCSankeyData.
     * @example
     * // Create many SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SCSankeyDataCreateManyArgs>(args?: SelectSubset<T, SCSankeyDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SCSankeyData.
     * @param {SCSankeyDataDeleteArgs} args - Arguments to delete one SCSankeyData.
     * @example
     * // Delete one SCSankeyData
     * const SCSankeyData = await prisma.sCSankeyData.delete({
     *   where: {
     *     // ... filter to delete one SCSankeyData
     *   }
     * })
     * 
     */
    delete<T extends SCSankeyDataDeleteArgs>(args: SelectSubset<T, SCSankeyDataDeleteArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SCSankeyData.
     * @param {SCSankeyDataUpdateArgs} args - Arguments to update one SCSankeyData.
     * @example
     * // Update one SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SCSankeyDataUpdateArgs>(args: SelectSubset<T, SCSankeyDataUpdateArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SCSankeyData.
     * @param {SCSankeyDataDeleteManyArgs} args - Arguments to filter SCSankeyData to delete.
     * @example
     * // Delete a few SCSankeyData
     * const { count } = await prisma.sCSankeyData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SCSankeyDataDeleteManyArgs>(args?: SelectSubset<T, SCSankeyDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SCSankeyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SCSankeyDataUpdateManyArgs>(args: SelectSubset<T, SCSankeyDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SCSankeyData.
     * @param {SCSankeyDataUpsertArgs} args - Arguments to update or create a SCSankeyData.
     * @example
     * // Update or create a SCSankeyData
     * const sCSankeyData = await prisma.sCSankeyData.upsert({
     *   create: {
     *     // ... data to create a SCSankeyData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SCSankeyData we want to update
     *   }
     * })
     */
    upsert<T extends SCSankeyDataUpsertArgs>(args: SelectSubset<T, SCSankeyDataUpsertArgs<ExtArgs>>): Prisma__SCSankeyDataClient<$Result.GetResult<Prisma.$SCSankeyDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SCSankeyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataCountArgs} args - Arguments to filter SCSankeyData to count.
     * @example
     * // Count the number of SCSankeyData
     * const count = await prisma.sCSankeyData.count({
     *   where: {
     *     // ... the filter for the SCSankeyData we want to count
     *   }
     * })
    **/
    count<T extends SCSankeyDataCountArgs>(
      args?: Subset<T, SCSankeyDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SCSankeyDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SCSankeyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SCSankeyDataAggregateArgs>(args: Subset<T, SCSankeyDataAggregateArgs>): Prisma.PrismaPromise<GetSCSankeyDataAggregateType<T>>

    /**
     * Group by SCSankeyData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SCSankeyDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SCSankeyDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SCSankeyDataGroupByArgs['orderBy'] }
        : { orderBy?: SCSankeyDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SCSankeyDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSCSankeyDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SCSankeyData model
   */
  readonly fields: SCSankeyDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SCSankeyData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SCSankeyDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SCSankeyData model
   */
  interface SCSankeyDataFieldRefs {
    readonly id: FieldRef<"SCSankeyData", 'Int'>
    readonly node: FieldRef<"SCSankeyData", 'Int'>
    readonly name: FieldRef<"SCSankeyData", 'String'>
    readonly value: FieldRef<"SCSankeyData", 'String'>
    readonly source: FieldRef<"SCSankeyData", 'Int'>
    readonly target: FieldRef<"SCSankeyData", 'Int'>
    readonly co2: FieldRef<"SCSankeyData", 'String'>
    readonly type: FieldRef<"SCSankeyData", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SCSankeyData findUnique
   */
  export type SCSankeyDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * Filter, which SCSankeyData to fetch.
     */
    where: SCSankeyDataWhereUniqueInput
  }

  /**
   * SCSankeyData findUniqueOrThrow
   */
  export type SCSankeyDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * Filter, which SCSankeyData to fetch.
     */
    where: SCSankeyDataWhereUniqueInput
  }

  /**
   * SCSankeyData findFirst
   */
  export type SCSankeyDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * Filter, which SCSankeyData to fetch.
     */
    where?: SCSankeyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCSankeyData to fetch.
     */
    orderBy?: SCSankeyDataOrderByWithRelationInput | SCSankeyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SCSankeyData.
     */
    cursor?: SCSankeyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCSankeyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCSankeyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SCSankeyData.
     */
    distinct?: SCSankeyDataScalarFieldEnum | SCSankeyDataScalarFieldEnum[]
  }

  /**
   * SCSankeyData findFirstOrThrow
   */
  export type SCSankeyDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * Filter, which SCSankeyData to fetch.
     */
    where?: SCSankeyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCSankeyData to fetch.
     */
    orderBy?: SCSankeyDataOrderByWithRelationInput | SCSankeyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SCSankeyData.
     */
    cursor?: SCSankeyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCSankeyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCSankeyData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SCSankeyData.
     */
    distinct?: SCSankeyDataScalarFieldEnum | SCSankeyDataScalarFieldEnum[]
  }

  /**
   * SCSankeyData findMany
   */
  export type SCSankeyDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * Filter, which SCSankeyData to fetch.
     */
    where?: SCSankeyDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SCSankeyData to fetch.
     */
    orderBy?: SCSankeyDataOrderByWithRelationInput | SCSankeyDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SCSankeyData.
     */
    cursor?: SCSankeyDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SCSankeyData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SCSankeyData.
     */
    skip?: number
    distinct?: SCSankeyDataScalarFieldEnum | SCSankeyDataScalarFieldEnum[]
  }

  /**
   * SCSankeyData create
   */
  export type SCSankeyDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * The data needed to create a SCSankeyData.
     */
    data?: XOR<SCSankeyDataCreateInput, SCSankeyDataUncheckedCreateInput>
  }

  /**
   * SCSankeyData createMany
   */
  export type SCSankeyDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SCSankeyData.
     */
    data: SCSankeyDataCreateManyInput | SCSankeyDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SCSankeyData update
   */
  export type SCSankeyDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * The data needed to update a SCSankeyData.
     */
    data: XOR<SCSankeyDataUpdateInput, SCSankeyDataUncheckedUpdateInput>
    /**
     * Choose, which SCSankeyData to update.
     */
    where: SCSankeyDataWhereUniqueInput
  }

  /**
   * SCSankeyData updateMany
   */
  export type SCSankeyDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SCSankeyData.
     */
    data: XOR<SCSankeyDataUpdateManyMutationInput, SCSankeyDataUncheckedUpdateManyInput>
    /**
     * Filter which SCSankeyData to update
     */
    where?: SCSankeyDataWhereInput
    /**
     * Limit how many SCSankeyData to update.
     */
    limit?: number
  }

  /**
   * SCSankeyData upsert
   */
  export type SCSankeyDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * The filter to search for the SCSankeyData to update in case it exists.
     */
    where: SCSankeyDataWhereUniqueInput
    /**
     * In case the SCSankeyData found by the `where` argument doesn't exist, create a new SCSankeyData with this data.
     */
    create: XOR<SCSankeyDataCreateInput, SCSankeyDataUncheckedCreateInput>
    /**
     * In case the SCSankeyData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SCSankeyDataUpdateInput, SCSankeyDataUncheckedUpdateInput>
  }

  /**
   * SCSankeyData delete
   */
  export type SCSankeyDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
    /**
     * Filter which SCSankeyData to delete.
     */
    where: SCSankeyDataWhereUniqueInput
  }

  /**
   * SCSankeyData deleteMany
   */
  export type SCSankeyDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SCSankeyData to delete
     */
    where?: SCSankeyDataWhereInput
    /**
     * Limit how many SCSankeyData to delete.
     */
    limit?: number
  }

  /**
   * SCSankeyData without action
   */
  export type SCSankeyDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SCSankeyData
     */
    select?: SCSankeyDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SCSankeyData
     */
    omit?: SCSankeyDataOmit<ExtArgs> | null
  }


  /**
   * Model receiptfc
   */

  export type AggregateReceiptfc = {
    _count: ReceiptfcCountAggregateOutputType | null
    _avg: ReceiptfcAvgAggregateOutputType | null
    _sum: ReceiptfcSumAggregateOutputType | null
    _min: ReceiptfcMinAggregateOutputType | null
    _max: ReceiptfcMaxAggregateOutputType | null
  }

  export type ReceiptfcAvgAggregateOutputType = {
    id: number | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    weight: Decimal | null
  }

  export type ReceiptfcSumAggregateOutputType = {
    id: number | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    weight: Decimal | null
  }

  export type ReceiptfcMinAggregateOutputType = {
    id: number | null
    saleMemberId: string | null
    saleMemberName: string | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    wasteTypeName: string | null
    imgUrls: string | null
    weight: Decimal | null
    orderTime: Date | null
    carNumber: string | null
    carBrand: string | null
    createTime: Date | null
    queryDate: Date | null
  }

  export type ReceiptfcMaxAggregateOutputType = {
    id: number | null
    saleMemberId: string | null
    saleMemberName: string | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    wasteTypeName: string | null
    imgUrls: string | null
    weight: Decimal | null
    orderTime: Date | null
    carNumber: string | null
    carBrand: string | null
    createTime: Date | null
    queryDate: Date | null
  }

  export type ReceiptfcCountAggregateOutputType = {
    id: number
    saleMemberId: number
    saleMemberName: number
    taxInclu: number
    unitpriceIncluTax: number
    wasteTypeName: number
    imgUrls: number
    weight: number
    orderTime: number
    carNumber: number
    carBrand: number
    createTime: number
    queryDate: number
    _all: number
  }


  export type ReceiptfcAvgAggregateInputType = {
    id?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    weight?: true
  }

  export type ReceiptfcSumAggregateInputType = {
    id?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    weight?: true
  }

  export type ReceiptfcMinAggregateInputType = {
    id?: true
    saleMemberId?: true
    saleMemberName?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    wasteTypeName?: true
    imgUrls?: true
    weight?: true
    orderTime?: true
    carNumber?: true
    carBrand?: true
    createTime?: true
    queryDate?: true
  }

  export type ReceiptfcMaxAggregateInputType = {
    id?: true
    saleMemberId?: true
    saleMemberName?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    wasteTypeName?: true
    imgUrls?: true
    weight?: true
    orderTime?: true
    carNumber?: true
    carBrand?: true
    createTime?: true
    queryDate?: true
  }

  export type ReceiptfcCountAggregateInputType = {
    id?: true
    saleMemberId?: true
    saleMemberName?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    wasteTypeName?: true
    imgUrls?: true
    weight?: true
    orderTime?: true
    carNumber?: true
    carBrand?: true
    createTime?: true
    queryDate?: true
    _all?: true
  }

  export type ReceiptfcAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receiptfc to aggregate.
     */
    where?: receiptfcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfcs to fetch.
     */
    orderBy?: receiptfcOrderByWithRelationInput | receiptfcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: receiptfcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned receiptfcs
    **/
    _count?: true | ReceiptfcCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptfcAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptfcSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptfcMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptfcMaxAggregateInputType
  }

  export type GetReceiptfcAggregateType<T extends ReceiptfcAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptfc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptfc[P]>
      : GetScalarType<T[P], AggregateReceiptfc[P]>
  }




  export type receiptfcGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: receiptfcWhereInput
    orderBy?: receiptfcOrderByWithAggregationInput | receiptfcOrderByWithAggregationInput[]
    by: ReceiptfcScalarFieldEnum[] | ReceiptfcScalarFieldEnum
    having?: receiptfcScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptfcCountAggregateInputType | true
    _avg?: ReceiptfcAvgAggregateInputType
    _sum?: ReceiptfcSumAggregateInputType
    _min?: ReceiptfcMinAggregateInputType
    _max?: ReceiptfcMaxAggregateInputType
  }

  export type ReceiptfcGroupByOutputType = {
    id: number
    saleMemberId: string | null
    saleMemberName: string | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    wasteTypeName: string | null
    imgUrls: string | null
    weight: Decimal | null
    orderTime: Date | null
    carNumber: string | null
    carBrand: string | null
    createTime: Date | null
    queryDate: Date | null
    _count: ReceiptfcCountAggregateOutputType | null
    _avg: ReceiptfcAvgAggregateOutputType | null
    _sum: ReceiptfcSumAggregateOutputType | null
    _min: ReceiptfcMinAggregateOutputType | null
    _max: ReceiptfcMaxAggregateOutputType | null
  }

  type GetReceiptfcGroupByPayload<T extends receiptfcGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptfcGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptfcGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptfcGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptfcGroupByOutputType[P]>
        }
      >
    >


  export type receiptfcSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleMemberId?: boolean
    saleMemberName?: boolean
    taxInclu?: boolean
    unitpriceIncluTax?: boolean
    wasteTypeName?: boolean
    imgUrls?: boolean
    weight?: boolean
    orderTime?: boolean
    carNumber?: boolean
    carBrand?: boolean
    createTime?: boolean
    queryDate?: boolean
  }, ExtArgs["result"]["receiptfc"]>



  export type receiptfcSelectScalar = {
    id?: boolean
    saleMemberId?: boolean
    saleMemberName?: boolean
    taxInclu?: boolean
    unitpriceIncluTax?: boolean
    wasteTypeName?: boolean
    imgUrls?: boolean
    weight?: boolean
    orderTime?: boolean
    carNumber?: boolean
    carBrand?: boolean
    createTime?: boolean
    queryDate?: boolean
  }

  export type receiptfcOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleMemberId" | "saleMemberName" | "taxInclu" | "unitpriceIncluTax" | "wasteTypeName" | "imgUrls" | "weight" | "orderTime" | "carNumber" | "carBrand" | "createTime" | "queryDate", ExtArgs["result"]["receiptfc"]>

  export type $receiptfcPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "receiptfc"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      saleMemberId: string | null
      saleMemberName: string | null
      taxInclu: Prisma.Decimal | null
      unitpriceIncluTax: Prisma.Decimal | null
      wasteTypeName: string | null
      imgUrls: string | null
      weight: Prisma.Decimal | null
      orderTime: Date | null
      carNumber: string | null
      carBrand: string | null
      createTime: Date | null
      queryDate: Date | null
    }, ExtArgs["result"]["receiptfc"]>
    composites: {}
  }

  type receiptfcGetPayload<S extends boolean | null | undefined | receiptfcDefaultArgs> = $Result.GetResult<Prisma.$receiptfcPayload, S>

  type receiptfcCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<receiptfcFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptfcCountAggregateInputType | true
    }

  export interface receiptfcDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['receiptfc'], meta: { name: 'receiptfc' } }
    /**
     * Find zero or one Receiptfc that matches the filter.
     * @param {receiptfcFindUniqueArgs} args - Arguments to find a Receiptfc
     * @example
     * // Get one Receiptfc
     * const receiptfc = await prisma.receiptfc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends receiptfcFindUniqueArgs>(args: SelectSubset<T, receiptfcFindUniqueArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receiptfc that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {receiptfcFindUniqueOrThrowArgs} args - Arguments to find a Receiptfc
     * @example
     * // Get one Receiptfc
     * const receiptfc = await prisma.receiptfc.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends receiptfcFindUniqueOrThrowArgs>(args: SelectSubset<T, receiptfcFindUniqueOrThrowArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receiptfc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfcFindFirstArgs} args - Arguments to find a Receiptfc
     * @example
     * // Get one Receiptfc
     * const receiptfc = await prisma.receiptfc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends receiptfcFindFirstArgs>(args?: SelectSubset<T, receiptfcFindFirstArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receiptfc that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfcFindFirstOrThrowArgs} args - Arguments to find a Receiptfc
     * @example
     * // Get one Receiptfc
     * const receiptfc = await prisma.receiptfc.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends receiptfcFindFirstOrThrowArgs>(args?: SelectSubset<T, receiptfcFindFirstOrThrowArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receiptfcs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfcFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receiptfcs
     * const receiptfcs = await prisma.receiptfc.findMany()
     * 
     * // Get first 10 Receiptfcs
     * const receiptfcs = await prisma.receiptfc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptfcWithIdOnly = await prisma.receiptfc.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends receiptfcFindManyArgs>(args?: SelectSubset<T, receiptfcFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receiptfc.
     * @param {receiptfcCreateArgs} args - Arguments to create a Receiptfc.
     * @example
     * // Create one Receiptfc
     * const Receiptfc = await prisma.receiptfc.create({
     *   data: {
     *     // ... data to create a Receiptfc
     *   }
     * })
     * 
     */
    create<T extends receiptfcCreateArgs>(args: SelectSubset<T, receiptfcCreateArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receiptfcs.
     * @param {receiptfcCreateManyArgs} args - Arguments to create many Receiptfcs.
     * @example
     * // Create many Receiptfcs
     * const receiptfc = await prisma.receiptfc.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends receiptfcCreateManyArgs>(args?: SelectSubset<T, receiptfcCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receiptfc.
     * @param {receiptfcDeleteArgs} args - Arguments to delete one Receiptfc.
     * @example
     * // Delete one Receiptfc
     * const Receiptfc = await prisma.receiptfc.delete({
     *   where: {
     *     // ... filter to delete one Receiptfc
     *   }
     * })
     * 
     */
    delete<T extends receiptfcDeleteArgs>(args: SelectSubset<T, receiptfcDeleteArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receiptfc.
     * @param {receiptfcUpdateArgs} args - Arguments to update one Receiptfc.
     * @example
     * // Update one Receiptfc
     * const receiptfc = await prisma.receiptfc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends receiptfcUpdateArgs>(args: SelectSubset<T, receiptfcUpdateArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receiptfcs.
     * @param {receiptfcDeleteManyArgs} args - Arguments to filter Receiptfcs to delete.
     * @example
     * // Delete a few Receiptfcs
     * const { count } = await prisma.receiptfc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends receiptfcDeleteManyArgs>(args?: SelectSubset<T, receiptfcDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receiptfcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfcUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receiptfcs
     * const receiptfc = await prisma.receiptfc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends receiptfcUpdateManyArgs>(args: SelectSubset<T, receiptfcUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receiptfc.
     * @param {receiptfcUpsertArgs} args - Arguments to update or create a Receiptfc.
     * @example
     * // Update or create a Receiptfc
     * const receiptfc = await prisma.receiptfc.upsert({
     *   create: {
     *     // ... data to create a Receiptfc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receiptfc we want to update
     *   }
     * })
     */
    upsert<T extends receiptfcUpsertArgs>(args: SelectSubset<T, receiptfcUpsertArgs<ExtArgs>>): Prisma__receiptfcClient<$Result.GetResult<Prisma.$receiptfcPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receiptfcs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfcCountArgs} args - Arguments to filter Receiptfcs to count.
     * @example
     * // Count the number of Receiptfcs
     * const count = await prisma.receiptfc.count({
     *   where: {
     *     // ... the filter for the Receiptfcs we want to count
     *   }
     * })
    **/
    count<T extends receiptfcCountArgs>(
      args?: Subset<T, receiptfcCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptfcCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receiptfc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptfcAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptfcAggregateArgs>(args: Subset<T, ReceiptfcAggregateArgs>): Prisma.PrismaPromise<GetReceiptfcAggregateType<T>>

    /**
     * Group by Receiptfc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfcGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends receiptfcGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: receiptfcGroupByArgs['orderBy'] }
        : { orderBy?: receiptfcGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, receiptfcGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptfcGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the receiptfc model
   */
  readonly fields: receiptfcFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for receiptfc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__receiptfcClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the receiptfc model
   */
  interface receiptfcFieldRefs {
    readonly id: FieldRef<"receiptfc", 'Int'>
    readonly saleMemberId: FieldRef<"receiptfc", 'String'>
    readonly saleMemberName: FieldRef<"receiptfc", 'String'>
    readonly taxInclu: FieldRef<"receiptfc", 'Decimal'>
    readonly unitpriceIncluTax: FieldRef<"receiptfc", 'Decimal'>
    readonly wasteTypeName: FieldRef<"receiptfc", 'String'>
    readonly imgUrls: FieldRef<"receiptfc", 'String'>
    readonly weight: FieldRef<"receiptfc", 'Decimal'>
    readonly orderTime: FieldRef<"receiptfc", 'DateTime'>
    readonly carNumber: FieldRef<"receiptfc", 'String'>
    readonly carBrand: FieldRef<"receiptfc", 'String'>
    readonly createTime: FieldRef<"receiptfc", 'DateTime'>
    readonly queryDate: FieldRef<"receiptfc", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * receiptfc findUnique
   */
  export type receiptfcFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * Filter, which receiptfc to fetch.
     */
    where: receiptfcWhereUniqueInput
  }

  /**
   * receiptfc findUniqueOrThrow
   */
  export type receiptfcFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * Filter, which receiptfc to fetch.
     */
    where: receiptfcWhereUniqueInput
  }

  /**
   * receiptfc findFirst
   */
  export type receiptfcFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * Filter, which receiptfc to fetch.
     */
    where?: receiptfcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfcs to fetch.
     */
    orderBy?: receiptfcOrderByWithRelationInput | receiptfcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receiptfcs.
     */
    cursor?: receiptfcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receiptfcs.
     */
    distinct?: ReceiptfcScalarFieldEnum | ReceiptfcScalarFieldEnum[]
  }

  /**
   * receiptfc findFirstOrThrow
   */
  export type receiptfcFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * Filter, which receiptfc to fetch.
     */
    where?: receiptfcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfcs to fetch.
     */
    orderBy?: receiptfcOrderByWithRelationInput | receiptfcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receiptfcs.
     */
    cursor?: receiptfcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfcs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receiptfcs.
     */
    distinct?: ReceiptfcScalarFieldEnum | ReceiptfcScalarFieldEnum[]
  }

  /**
   * receiptfc findMany
   */
  export type receiptfcFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * Filter, which receiptfcs to fetch.
     */
    where?: receiptfcWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfcs to fetch.
     */
    orderBy?: receiptfcOrderByWithRelationInput | receiptfcOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing receiptfcs.
     */
    cursor?: receiptfcWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfcs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfcs.
     */
    skip?: number
    distinct?: ReceiptfcScalarFieldEnum | ReceiptfcScalarFieldEnum[]
  }

  /**
   * receiptfc create
   */
  export type receiptfcCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * The data needed to create a receiptfc.
     */
    data?: XOR<receiptfcCreateInput, receiptfcUncheckedCreateInput>
  }

  /**
   * receiptfc createMany
   */
  export type receiptfcCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many receiptfcs.
     */
    data: receiptfcCreateManyInput | receiptfcCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * receiptfc update
   */
  export type receiptfcUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * The data needed to update a receiptfc.
     */
    data: XOR<receiptfcUpdateInput, receiptfcUncheckedUpdateInput>
    /**
     * Choose, which receiptfc to update.
     */
    where: receiptfcWhereUniqueInput
  }

  /**
   * receiptfc updateMany
   */
  export type receiptfcUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update receiptfcs.
     */
    data: XOR<receiptfcUpdateManyMutationInput, receiptfcUncheckedUpdateManyInput>
    /**
     * Filter which receiptfcs to update
     */
    where?: receiptfcWhereInput
    /**
     * Limit how many receiptfcs to update.
     */
    limit?: number
  }

  /**
   * receiptfc upsert
   */
  export type receiptfcUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * The filter to search for the receiptfc to update in case it exists.
     */
    where: receiptfcWhereUniqueInput
    /**
     * In case the receiptfc found by the `where` argument doesn't exist, create a new receiptfc with this data.
     */
    create: XOR<receiptfcCreateInput, receiptfcUncheckedCreateInput>
    /**
     * In case the receiptfc was found with the provided `where` argument, update it with this data.
     */
    update: XOR<receiptfcUpdateInput, receiptfcUncheckedUpdateInput>
  }

  /**
   * receiptfc delete
   */
  export type receiptfcDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
    /**
     * Filter which receiptfc to delete.
     */
    where: receiptfcWhereUniqueInput
  }

  /**
   * receiptfc deleteMany
   */
  export type receiptfcDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receiptfcs to delete
     */
    where?: receiptfcWhereInput
    /**
     * Limit how many receiptfcs to delete.
     */
    limit?: number
  }

  /**
   * receiptfc without action
   */
  export type receiptfcDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfc
     */
    select?: receiptfcSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfc
     */
    omit?: receiptfcOmit<ExtArgs> | null
  }


  /**
   * Model receiptfg
   */

  export type AggregateReceiptfg = {
    _count: ReceiptfgCountAggregateOutputType | null
    _avg: ReceiptfgAvgAggregateOutputType | null
    _sum: ReceiptfgSumAggregateOutputType | null
    _min: ReceiptfgMinAggregateOutputType | null
    _max: ReceiptfgMaxAggregateOutputType | null
  }

  export type ReceiptfgAvgAggregateOutputType = {
    id: number | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    weight: Decimal | null
  }

  export type ReceiptfgSumAggregateOutputType = {
    id: number | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    weight: Decimal | null
  }

  export type ReceiptfgMinAggregateOutputType = {
    id: number | null
    saleMemberId: string | null
    saleMemberName: string | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    wasteTypeName: string | null
    imgUrls: string | null
    weight: Decimal | null
    orderTime: Date | null
    carNumber: string | null
    carBrand: string | null
    createTime: Date | null
    queryDate: Date | null
  }

  export type ReceiptfgMaxAggregateOutputType = {
    id: number | null
    saleMemberId: string | null
    saleMemberName: string | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    wasteTypeName: string | null
    imgUrls: string | null
    weight: Decimal | null
    orderTime: Date | null
    carNumber: string | null
    carBrand: string | null
    createTime: Date | null
    queryDate: Date | null
  }

  export type ReceiptfgCountAggregateOutputType = {
    id: number
    saleMemberId: number
    saleMemberName: number
    taxInclu: number
    unitpriceIncluTax: number
    wasteTypeName: number
    imgUrls: number
    weight: number
    orderTime: number
    carNumber: number
    carBrand: number
    createTime: number
    queryDate: number
    _all: number
  }


  export type ReceiptfgAvgAggregateInputType = {
    id?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    weight?: true
  }

  export type ReceiptfgSumAggregateInputType = {
    id?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    weight?: true
  }

  export type ReceiptfgMinAggregateInputType = {
    id?: true
    saleMemberId?: true
    saleMemberName?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    wasteTypeName?: true
    imgUrls?: true
    weight?: true
    orderTime?: true
    carNumber?: true
    carBrand?: true
    createTime?: true
    queryDate?: true
  }

  export type ReceiptfgMaxAggregateInputType = {
    id?: true
    saleMemberId?: true
    saleMemberName?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    wasteTypeName?: true
    imgUrls?: true
    weight?: true
    orderTime?: true
    carNumber?: true
    carBrand?: true
    createTime?: true
    queryDate?: true
  }

  export type ReceiptfgCountAggregateInputType = {
    id?: true
    saleMemberId?: true
    saleMemberName?: true
    taxInclu?: true
    unitpriceIncluTax?: true
    wasteTypeName?: true
    imgUrls?: true
    weight?: true
    orderTime?: true
    carNumber?: true
    carBrand?: true
    createTime?: true
    queryDate?: true
    _all?: true
  }

  export type ReceiptfgAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receiptfg to aggregate.
     */
    where?: receiptfgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfgs to fetch.
     */
    orderBy?: receiptfgOrderByWithRelationInput | receiptfgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: receiptfgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned receiptfgs
    **/
    _count?: true | ReceiptfgCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReceiptfgAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReceiptfgSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReceiptfgMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReceiptfgMaxAggregateInputType
  }

  export type GetReceiptfgAggregateType<T extends ReceiptfgAggregateArgs> = {
        [P in keyof T & keyof AggregateReceiptfg]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReceiptfg[P]>
      : GetScalarType<T[P], AggregateReceiptfg[P]>
  }




  export type receiptfgGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: receiptfgWhereInput
    orderBy?: receiptfgOrderByWithAggregationInput | receiptfgOrderByWithAggregationInput[]
    by: ReceiptfgScalarFieldEnum[] | ReceiptfgScalarFieldEnum
    having?: receiptfgScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReceiptfgCountAggregateInputType | true
    _avg?: ReceiptfgAvgAggregateInputType
    _sum?: ReceiptfgSumAggregateInputType
    _min?: ReceiptfgMinAggregateInputType
    _max?: ReceiptfgMaxAggregateInputType
  }

  export type ReceiptfgGroupByOutputType = {
    id: number
    saleMemberId: string | null
    saleMemberName: string | null
    taxInclu: Decimal | null
    unitpriceIncluTax: Decimal | null
    wasteTypeName: string | null
    imgUrls: string | null
    weight: Decimal | null
    orderTime: Date | null
    carNumber: string | null
    carBrand: string | null
    createTime: Date | null
    queryDate: Date | null
    _count: ReceiptfgCountAggregateOutputType | null
    _avg: ReceiptfgAvgAggregateOutputType | null
    _sum: ReceiptfgSumAggregateOutputType | null
    _min: ReceiptfgMinAggregateOutputType | null
    _max: ReceiptfgMaxAggregateOutputType | null
  }

  type GetReceiptfgGroupByPayload<T extends receiptfgGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReceiptfgGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReceiptfgGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReceiptfgGroupByOutputType[P]>
            : GetScalarType<T[P], ReceiptfgGroupByOutputType[P]>
        }
      >
    >


  export type receiptfgSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    saleMemberId?: boolean
    saleMemberName?: boolean
    taxInclu?: boolean
    unitpriceIncluTax?: boolean
    wasteTypeName?: boolean
    imgUrls?: boolean
    weight?: boolean
    orderTime?: boolean
    carNumber?: boolean
    carBrand?: boolean
    createTime?: boolean
    queryDate?: boolean
  }, ExtArgs["result"]["receiptfg"]>



  export type receiptfgSelectScalar = {
    id?: boolean
    saleMemberId?: boolean
    saleMemberName?: boolean
    taxInclu?: boolean
    unitpriceIncluTax?: boolean
    wasteTypeName?: boolean
    imgUrls?: boolean
    weight?: boolean
    orderTime?: boolean
    carNumber?: boolean
    carBrand?: boolean
    createTime?: boolean
    queryDate?: boolean
  }

  export type receiptfgOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "saleMemberId" | "saleMemberName" | "taxInclu" | "unitpriceIncluTax" | "wasteTypeName" | "imgUrls" | "weight" | "orderTime" | "carNumber" | "carBrand" | "createTime" | "queryDate", ExtArgs["result"]["receiptfg"]>

  export type $receiptfgPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "receiptfg"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      saleMemberId: string | null
      saleMemberName: string | null
      taxInclu: Prisma.Decimal | null
      unitpriceIncluTax: Prisma.Decimal | null
      wasteTypeName: string | null
      imgUrls: string | null
      weight: Prisma.Decimal | null
      orderTime: Date | null
      carNumber: string | null
      carBrand: string | null
      createTime: Date | null
      queryDate: Date | null
    }, ExtArgs["result"]["receiptfg"]>
    composites: {}
  }

  type receiptfgGetPayload<S extends boolean | null | undefined | receiptfgDefaultArgs> = $Result.GetResult<Prisma.$receiptfgPayload, S>

  type receiptfgCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<receiptfgFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReceiptfgCountAggregateInputType | true
    }

  export interface receiptfgDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['receiptfg'], meta: { name: 'receiptfg' } }
    /**
     * Find zero or one Receiptfg that matches the filter.
     * @param {receiptfgFindUniqueArgs} args - Arguments to find a Receiptfg
     * @example
     * // Get one Receiptfg
     * const receiptfg = await prisma.receiptfg.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends receiptfgFindUniqueArgs>(args: SelectSubset<T, receiptfgFindUniqueArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Receiptfg that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {receiptfgFindUniqueOrThrowArgs} args - Arguments to find a Receiptfg
     * @example
     * // Get one Receiptfg
     * const receiptfg = await prisma.receiptfg.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends receiptfgFindUniqueOrThrowArgs>(args: SelectSubset<T, receiptfgFindUniqueOrThrowArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receiptfg that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfgFindFirstArgs} args - Arguments to find a Receiptfg
     * @example
     * // Get one Receiptfg
     * const receiptfg = await prisma.receiptfg.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends receiptfgFindFirstArgs>(args?: SelectSubset<T, receiptfgFindFirstArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Receiptfg that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfgFindFirstOrThrowArgs} args - Arguments to find a Receiptfg
     * @example
     * // Get one Receiptfg
     * const receiptfg = await prisma.receiptfg.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends receiptfgFindFirstOrThrowArgs>(args?: SelectSubset<T, receiptfgFindFirstOrThrowArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Receiptfgs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfgFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Receiptfgs
     * const receiptfgs = await prisma.receiptfg.findMany()
     * 
     * // Get first 10 Receiptfgs
     * const receiptfgs = await prisma.receiptfg.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const receiptfgWithIdOnly = await prisma.receiptfg.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends receiptfgFindManyArgs>(args?: SelectSubset<T, receiptfgFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Receiptfg.
     * @param {receiptfgCreateArgs} args - Arguments to create a Receiptfg.
     * @example
     * // Create one Receiptfg
     * const Receiptfg = await prisma.receiptfg.create({
     *   data: {
     *     // ... data to create a Receiptfg
     *   }
     * })
     * 
     */
    create<T extends receiptfgCreateArgs>(args: SelectSubset<T, receiptfgCreateArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Receiptfgs.
     * @param {receiptfgCreateManyArgs} args - Arguments to create many Receiptfgs.
     * @example
     * // Create many Receiptfgs
     * const receiptfg = await prisma.receiptfg.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends receiptfgCreateManyArgs>(args?: SelectSubset<T, receiptfgCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Receiptfg.
     * @param {receiptfgDeleteArgs} args - Arguments to delete one Receiptfg.
     * @example
     * // Delete one Receiptfg
     * const Receiptfg = await prisma.receiptfg.delete({
     *   where: {
     *     // ... filter to delete one Receiptfg
     *   }
     * })
     * 
     */
    delete<T extends receiptfgDeleteArgs>(args: SelectSubset<T, receiptfgDeleteArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Receiptfg.
     * @param {receiptfgUpdateArgs} args - Arguments to update one Receiptfg.
     * @example
     * // Update one Receiptfg
     * const receiptfg = await prisma.receiptfg.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends receiptfgUpdateArgs>(args: SelectSubset<T, receiptfgUpdateArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Receiptfgs.
     * @param {receiptfgDeleteManyArgs} args - Arguments to filter Receiptfgs to delete.
     * @example
     * // Delete a few Receiptfgs
     * const { count } = await prisma.receiptfg.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends receiptfgDeleteManyArgs>(args?: SelectSubset<T, receiptfgDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Receiptfgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfgUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Receiptfgs
     * const receiptfg = await prisma.receiptfg.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends receiptfgUpdateManyArgs>(args: SelectSubset<T, receiptfgUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Receiptfg.
     * @param {receiptfgUpsertArgs} args - Arguments to update or create a Receiptfg.
     * @example
     * // Update or create a Receiptfg
     * const receiptfg = await prisma.receiptfg.upsert({
     *   create: {
     *     // ... data to create a Receiptfg
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Receiptfg we want to update
     *   }
     * })
     */
    upsert<T extends receiptfgUpsertArgs>(args: SelectSubset<T, receiptfgUpsertArgs<ExtArgs>>): Prisma__receiptfgClient<$Result.GetResult<Prisma.$receiptfgPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Receiptfgs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfgCountArgs} args - Arguments to filter Receiptfgs to count.
     * @example
     * // Count the number of Receiptfgs
     * const count = await prisma.receiptfg.count({
     *   where: {
     *     // ... the filter for the Receiptfgs we want to count
     *   }
     * })
    **/
    count<T extends receiptfgCountArgs>(
      args?: Subset<T, receiptfgCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReceiptfgCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Receiptfg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReceiptfgAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReceiptfgAggregateArgs>(args: Subset<T, ReceiptfgAggregateArgs>): Prisma.PrismaPromise<GetReceiptfgAggregateType<T>>

    /**
     * Group by Receiptfg.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {receiptfgGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends receiptfgGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: receiptfgGroupByArgs['orderBy'] }
        : { orderBy?: receiptfgGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, receiptfgGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReceiptfgGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the receiptfg model
   */
  readonly fields: receiptfgFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for receiptfg.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__receiptfgClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the receiptfg model
   */
  interface receiptfgFieldRefs {
    readonly id: FieldRef<"receiptfg", 'Int'>
    readonly saleMemberId: FieldRef<"receiptfg", 'String'>
    readonly saleMemberName: FieldRef<"receiptfg", 'String'>
    readonly taxInclu: FieldRef<"receiptfg", 'Decimal'>
    readonly unitpriceIncluTax: FieldRef<"receiptfg", 'Decimal'>
    readonly wasteTypeName: FieldRef<"receiptfg", 'String'>
    readonly imgUrls: FieldRef<"receiptfg", 'String'>
    readonly weight: FieldRef<"receiptfg", 'Decimal'>
    readonly orderTime: FieldRef<"receiptfg", 'DateTime'>
    readonly carNumber: FieldRef<"receiptfg", 'String'>
    readonly carBrand: FieldRef<"receiptfg", 'String'>
    readonly createTime: FieldRef<"receiptfg", 'DateTime'>
    readonly queryDate: FieldRef<"receiptfg", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * receiptfg findUnique
   */
  export type receiptfgFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * Filter, which receiptfg to fetch.
     */
    where: receiptfgWhereUniqueInput
  }

  /**
   * receiptfg findUniqueOrThrow
   */
  export type receiptfgFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * Filter, which receiptfg to fetch.
     */
    where: receiptfgWhereUniqueInput
  }

  /**
   * receiptfg findFirst
   */
  export type receiptfgFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * Filter, which receiptfg to fetch.
     */
    where?: receiptfgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfgs to fetch.
     */
    orderBy?: receiptfgOrderByWithRelationInput | receiptfgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receiptfgs.
     */
    cursor?: receiptfgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receiptfgs.
     */
    distinct?: ReceiptfgScalarFieldEnum | ReceiptfgScalarFieldEnum[]
  }

  /**
   * receiptfg findFirstOrThrow
   */
  export type receiptfgFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * Filter, which receiptfg to fetch.
     */
    where?: receiptfgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfgs to fetch.
     */
    orderBy?: receiptfgOrderByWithRelationInput | receiptfgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for receiptfgs.
     */
    cursor?: receiptfgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfgs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of receiptfgs.
     */
    distinct?: ReceiptfgScalarFieldEnum | ReceiptfgScalarFieldEnum[]
  }

  /**
   * receiptfg findMany
   */
  export type receiptfgFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * Filter, which receiptfgs to fetch.
     */
    where?: receiptfgWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of receiptfgs to fetch.
     */
    orderBy?: receiptfgOrderByWithRelationInput | receiptfgOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing receiptfgs.
     */
    cursor?: receiptfgWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` receiptfgs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` receiptfgs.
     */
    skip?: number
    distinct?: ReceiptfgScalarFieldEnum | ReceiptfgScalarFieldEnum[]
  }

  /**
   * receiptfg create
   */
  export type receiptfgCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * The data needed to create a receiptfg.
     */
    data?: XOR<receiptfgCreateInput, receiptfgUncheckedCreateInput>
  }

  /**
   * receiptfg createMany
   */
  export type receiptfgCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many receiptfgs.
     */
    data: receiptfgCreateManyInput | receiptfgCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * receiptfg update
   */
  export type receiptfgUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * The data needed to update a receiptfg.
     */
    data: XOR<receiptfgUpdateInput, receiptfgUncheckedUpdateInput>
    /**
     * Choose, which receiptfg to update.
     */
    where: receiptfgWhereUniqueInput
  }

  /**
   * receiptfg updateMany
   */
  export type receiptfgUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update receiptfgs.
     */
    data: XOR<receiptfgUpdateManyMutationInput, receiptfgUncheckedUpdateManyInput>
    /**
     * Filter which receiptfgs to update
     */
    where?: receiptfgWhereInput
    /**
     * Limit how many receiptfgs to update.
     */
    limit?: number
  }

  /**
   * receiptfg upsert
   */
  export type receiptfgUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * The filter to search for the receiptfg to update in case it exists.
     */
    where: receiptfgWhereUniqueInput
    /**
     * In case the receiptfg found by the `where` argument doesn't exist, create a new receiptfg with this data.
     */
    create: XOR<receiptfgCreateInput, receiptfgUncheckedCreateInput>
    /**
     * In case the receiptfg was found with the provided `where` argument, update it with this data.
     */
    update: XOR<receiptfgUpdateInput, receiptfgUncheckedUpdateInput>
  }

  /**
   * receiptfg delete
   */
  export type receiptfgDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
    /**
     * Filter which receiptfg to delete.
     */
    where: receiptfgWhereUniqueInput
  }

  /**
   * receiptfg deleteMany
   */
  export type receiptfgDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which receiptfgs to delete
     */
    where?: receiptfgWhereInput
    /**
     * Limit how many receiptfgs to delete.
     */
    limit?: number
  }

  /**
   * receiptfg without action
   */
  export type receiptfgDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the receiptfg
     */
    select?: receiptfgSelect<ExtArgs> | null
    /**
     * Omit specific fields from the receiptfg
     */
    omit?: receiptfgOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const CAHoldingsScalarFieldEnum: {
    id: 'id',
    asset: 'asset',
    quantity: 'quantity',
    value: 'value',
    status: 'status'
  };

  export type CAHoldingsScalarFieldEnum = (typeof CAHoldingsScalarFieldEnum)[keyof typeof CAHoldingsScalarFieldEnum]


  export const CAMarketCardsScalarFieldEnum: {
    id: 'id',
    price: 'price',
    volume: 'volume',
    change: 'change',
    unit: 'unit'
  };

  export type CAMarketCardsScalarFieldEnum = (typeof CAMarketCardsScalarFieldEnum)[keyof typeof CAMarketCardsScalarFieldEnum]


  export const CAPieChartScalarFieldEnum: {
    id: 'id',
    type: 'type',
    value: 'value',
    percentage: 'percentage'
  };

  export type CAPieChartScalarFieldEnum = (typeof CAPieChartScalarFieldEnum)[keyof typeof CAPieChartScalarFieldEnum]


  export const CAPriceChartScalarFieldEnum: {
    id: 'id',
    date: 'date',
    price: 'price',
    volume: 'volume'
  };

  export type CAPriceChartScalarFieldEnum = (typeof CAPriceChartScalarFieldEnum)[keyof typeof CAPriceChartScalarFieldEnum]


  export const CBComparisonChartScalarFieldEnum: {
    id: 'id',
    month: 'month',
    actual: 'actual',
    budget: 'budget'
  };

  export type CBComparisonChartScalarFieldEnum = (typeof CBComparisonChartScalarFieldEnum)[keyof typeof CBComparisonChartScalarFieldEnum]


  export const CBMonthlyDetailsScalarFieldEnum: {
    id: 'id',
    month: 'month',
    energy_budget: 'energy_budget',
    actual: 'actual',
    variance: 'variance',
    status: 'status'
  };

  export type CBMonthlyDetailsScalarFieldEnum = (typeof CBMonthlyDetailsScalarFieldEnum)[keyof typeof CBMonthlyDetailsScalarFieldEnum]


  export const CBSummaryCardsScalarFieldEnum: {
    id: 'id',
    total_energy: 'total_energy',
    used: 'used',
    remaining: 'remaining',
    overrun_rate: 'overrun_rate',
    unit: 'unit'
  };

  export type CBSummaryCardsScalarFieldEnum = (typeof CBSummaryCardsScalarFieldEnum)[keyof typeof CBSummaryCardsScalarFieldEnum]


  export const CFDetailsScalarFieldEnum: {
    id: 'id',
    process: 'process',
    scope: 'scope',
    emission: 'emission',
    factor: 'factor',
    total: 'total'
  };

  export type CFDetailsScalarFieldEnum = (typeof CFDetailsScalarFieldEnum)[keyof typeof CFDetailsScalarFieldEnum]


  export const CFPieChartScalarFieldEnum: {
    id: 'id',
    scope: 'scope',
    value: 'value',
    percentage: 'percentage'
  };

  export type CFPieChartScalarFieldEnum = (typeof CFPieChartScalarFieldEnum)[keyof typeof CFPieChartScalarFieldEnum]


  export const CFTrendChartScalarFieldEnum: {
    id: 'id',
    month: 'month',
    footprint: 'footprint',
    scope1: 'scope1',
    scope2: 'scope2',
    scope3: 'scope3'
  };

  export type CFTrendChartScalarFieldEnum = (typeof CFTrendChartScalarFieldEnum)[keyof typeof CFTrendChartScalarFieldEnum]


  export const EAConsumptionTrendScalarFieldEnum: {
    id: 'id',
    date: 'date',
    total: 'total',
    upstream: 'upstream',
    downstream: 'downstream',
    forecast: 'forecast'
  };

  export type EAConsumptionTrendScalarFieldEnum = (typeof EAConsumptionTrendScalarFieldEnum)[keyof typeof EAConsumptionTrendScalarFieldEnum]


  export const EAMonthSummaryScalarFieldEnum: {
    id: 'id',
    month: 'month',
    total: 'total',
    upstream: 'upstream',
    growth_rate: 'growth_rate',
    forecast_growth: 'forecast_growth'
  };

  export type EAMonthSummaryScalarFieldEnum = (typeof EAMonthSummaryScalarFieldEnum)[keyof typeof EAMonthSummaryScalarFieldEnum]


  export const EAStrategyScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    impact: 'impact',
    action: 'action'
  };

  export type EAStrategyScalarFieldEnum = (typeof EAStrategyScalarFieldEnum)[keyof typeof EAStrategyScalarFieldEnum]


  export const EATypeComparisonScalarFieldEnum: {
    id: 'id',
    month: 'month',
    coal: 'coal',
    gas: 'gas',
    electric: 'electric'
  };

  export type EATypeComparisonScalarFieldEnum = (typeof EATypeComparisonScalarFieldEnum)[keyof typeof EATypeComparisonScalarFieldEnum]


  export const EBParamCardsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    unit: 'unit',
    trend: 'trend'
  };

  export type EBParamCardsScalarFieldEnum = (typeof EBParamCardsScalarFieldEnum)[keyof typeof EBParamCardsScalarFieldEnum]


  export const EBPieChartScalarFieldEnum: {
    id: 'id',
    type: 'type',
    value: 'value',
    color: 'color'
  };

  export type EBPieChartScalarFieldEnum = (typeof EBPieChartScalarFieldEnum)[keyof typeof EBPieChartScalarFieldEnum]


  export const EBResultsScalarFieldEnum: {
    id: 'id',
    before: 'before',
    after: 'after',
    savings: 'savings'
  };

  export type EBResultsScalarFieldEnum = (typeof EBResultsScalarFieldEnum)[keyof typeof EBResultsScalarFieldEnum]


  export const EBTrendChartScalarFieldEnum: {
    id: 'id',
    time: 'time',
    generation: 'generation',
    consumption: 'consumption'
  };

  export type EBTrendChartScalarFieldEnum = (typeof EBTrendChartScalarFieldEnum)[keyof typeof EBTrendChartScalarFieldEnum]


  export const ECenergyFlowRealTimeScalarFieldEnum: {
    id: 'id',
    device_id: 'device_id',
    energy_type_id: 'energy_type_id',
    flow_value: 'flow_value',
    temperature: 'temperature',
    pressure: 'pressure',
    timestamp: 'timestamp'
  };

  export type ECenergyFlowRealTimeScalarFieldEnum = (typeof ECenergyFlowRealTimeScalarFieldEnum)[keyof typeof ECenergyFlowRealTimeScalarFieldEnum]


  export const ECenergyTypesScalarFieldEnum: {
    id: 'id',
    type: 'type',
    name: 'name',
    unit: 'unit',
    icon: 'icon',
    conversion_factor: 'conversion_factor',
    created_at: 'created_at'
  };

  export type ECenergyTypesScalarFieldEnum = (typeof ECenergyTypesScalarFieldEnum)[keyof typeof ECenergyTypesScalarFieldEnum]


  export const EChistoryScalarFieldEnum: {
    id: 'id',
    energy_type_id: 'energy_type_id',
    date_time: 'date_time',
    consumption: 'consumption',
    generation: 'generation',
    status: 'status'
  };

  export type EChistoryScalarFieldEnum = (typeof EChistoryScalarFieldEnum)[keyof typeof EChistoryScalarFieldEnum]


  export const ECrealTimeScalarFieldEnum: {
    id: 'id',
    energy_type_id: 'energy_type_id',
    current_value: 'current_value',
    total_value: 'total_value',
    unit: 'unit',
    timestamp: 'timestamp',
    status: 'status'
  };

  export type ECrealTimeScalarFieldEnum = (typeof ECrealTimeScalarFieldEnum)[keyof typeof ECrealTimeScalarFieldEnum]


  export const EEBenchmarkRankCardsScalarFieldEnum: {
    id: 'id',
    rank: 'rank',
    name: 'name',
    efficiency: 'efficiency',
    unit: 'unit',
    trend: 'trend'
  };

  export type EEBenchmarkRankCardsScalarFieldEnum = (typeof EEBenchmarkRankCardsScalarFieldEnum)[keyof typeof EEBenchmarkRankCardsScalarFieldEnum]


  export const EEGaugeMetricsScalarFieldEnum: {
    id: 'id',
    current: 'current',
    target: 'target',
    label: 'label'
  };

  export type EEGaugeMetricsScalarFieldEnum = (typeof EEGaugeMetricsScalarFieldEnum)[keyof typeof EEGaugeMetricsScalarFieldEnum]


  export const EERankingListScalarFieldEnum: {
    id: 'id',
    enterprise: 'enterprise',
    rank: 'rank',
    efficiency: 'efficiency',
    benchmark: 'benchmark',
    delta: 'delta',
    status: 'status'
  };

  export type EERankingListScalarFieldEnum = (typeof EERankingListScalarFieldEnum)[keyof typeof EERankingListScalarFieldEnum]


  export const EETrendChartDataScalarFieldEnum: {
    id: 'id',
    month: 'month',
    value: 'value',
    benchmark: 'benchmark'
  };

  export type EETrendChartDataScalarFieldEnum = (typeof EETrendChartDataScalarFieldEnum)[keyof typeof EETrendChartDataScalarFieldEnum]


  export const EFSankeyLinksScalarFieldEnum: {
    id: 'id',
    source: 'source',
    target: 'target',
    value: 'value',
    type: 'type'
  };

  export type EFSankeyLinksScalarFieldEnum = (typeof EFSankeyLinksScalarFieldEnum)[keyof typeof EFSankeyLinksScalarFieldEnum]


  export const EFSankeyNodesScalarFieldEnum: {
    id: 'id',
    node: 'node',
    name: 'name',
    value: 'value',
    unit: 'unit'
  };

  export type EFSankeyNodesScalarFieldEnum = (typeof EFSankeyNodesScalarFieldEnum)[keyof typeof EFSankeyNodesScalarFieldEnum]


  export const EFSummaryTableScalarFieldEnum: {
    id: 'id',
    name: 'name',
    total: 'total',
    percentage: 'percentage',
    unit: 'unit'
  };

  export type EFSummaryTableScalarFieldEnum = (typeof EFSummaryTableScalarFieldEnum)[keyof typeof EFSummaryTableScalarFieldEnum]


  export const SCRankingScalarFieldEnum: {
    id: 'id',
    supplier: 'supplier',
    emission: 'emission',
    intensity: 'intensity',
    rank: 'rank',
    compliance: 'compliance'
  };

  export type SCRankingScalarFieldEnum = (typeof SCRankingScalarFieldEnum)[keyof typeof SCRankingScalarFieldEnum]


  export const SCSankeyDataScalarFieldEnum: {
    id: 'id',
    node: 'node',
    name: 'name',
    value: 'value',
    source: 'source',
    target: 'target',
    co2: 'co2',
    type: 'type'
  };

  export type SCSankeyDataScalarFieldEnum = (typeof SCSankeyDataScalarFieldEnum)[keyof typeof SCSankeyDataScalarFieldEnum]


  export const ReceiptfcScalarFieldEnum: {
    id: 'id',
    saleMemberId: 'saleMemberId',
    saleMemberName: 'saleMemberName',
    taxInclu: 'taxInclu',
    unitpriceIncluTax: 'unitpriceIncluTax',
    wasteTypeName: 'wasteTypeName',
    imgUrls: 'imgUrls',
    weight: 'weight',
    orderTime: 'orderTime',
    carNumber: 'carNumber',
    carBrand: 'carBrand',
    createTime: 'createTime',
    queryDate: 'queryDate'
  };

  export type ReceiptfcScalarFieldEnum = (typeof ReceiptfcScalarFieldEnum)[keyof typeof ReceiptfcScalarFieldEnum]


  export const ReceiptfgScalarFieldEnum: {
    id: 'id',
    saleMemberId: 'saleMemberId',
    saleMemberName: 'saleMemberName',
    taxInclu: 'taxInclu',
    unitpriceIncluTax: 'unitpriceIncluTax',
    wasteTypeName: 'wasteTypeName',
    imgUrls: 'imgUrls',
    weight: 'weight',
    orderTime: 'orderTime',
    carNumber: 'carNumber',
    carBrand: 'carBrand',
    createTime: 'createTime',
    queryDate: 'queryDate'
  };

  export type ReceiptfgScalarFieldEnum = (typeof ReceiptfgScalarFieldEnum)[keyof typeof ReceiptfgScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const CAHoldingsOrderByRelevanceFieldEnum: {
    asset: 'asset',
    quantity: 'quantity',
    value: 'value',
    status: 'status'
  };

  export type CAHoldingsOrderByRelevanceFieldEnum = (typeof CAHoldingsOrderByRelevanceFieldEnum)[keyof typeof CAHoldingsOrderByRelevanceFieldEnum]


  export const CAMarketCardsOrderByRelevanceFieldEnum: {
    price: 'price',
    volume: 'volume',
    change: 'change',
    unit: 'unit'
  };

  export type CAMarketCardsOrderByRelevanceFieldEnum = (typeof CAMarketCardsOrderByRelevanceFieldEnum)[keyof typeof CAMarketCardsOrderByRelevanceFieldEnum]


  export const CAPieChartOrderByRelevanceFieldEnum: {
    type: 'type',
    value: 'value',
    percentage: 'percentage'
  };

  export type CAPieChartOrderByRelevanceFieldEnum = (typeof CAPieChartOrderByRelevanceFieldEnum)[keyof typeof CAPieChartOrderByRelevanceFieldEnum]


  export const CAPriceChartOrderByRelevanceFieldEnum: {
    date: 'date',
    price: 'price',
    volume: 'volume'
  };

  export type CAPriceChartOrderByRelevanceFieldEnum = (typeof CAPriceChartOrderByRelevanceFieldEnum)[keyof typeof CAPriceChartOrderByRelevanceFieldEnum]


  export const CBComparisonChartOrderByRelevanceFieldEnum: {
    month: 'month',
    actual: 'actual',
    budget: 'budget'
  };

  export type CBComparisonChartOrderByRelevanceFieldEnum = (typeof CBComparisonChartOrderByRelevanceFieldEnum)[keyof typeof CBComparisonChartOrderByRelevanceFieldEnum]


  export const CBMonthlyDetailsOrderByRelevanceFieldEnum: {
    month: 'month',
    energy_budget: 'energy_budget',
    actual: 'actual',
    variance: 'variance',
    status: 'status'
  };

  export type CBMonthlyDetailsOrderByRelevanceFieldEnum = (typeof CBMonthlyDetailsOrderByRelevanceFieldEnum)[keyof typeof CBMonthlyDetailsOrderByRelevanceFieldEnum]


  export const CBSummaryCardsOrderByRelevanceFieldEnum: {
    total_energy: 'total_energy',
    used: 'used',
    remaining: 'remaining',
    overrun_rate: 'overrun_rate',
    unit: 'unit'
  };

  export type CBSummaryCardsOrderByRelevanceFieldEnum = (typeof CBSummaryCardsOrderByRelevanceFieldEnum)[keyof typeof CBSummaryCardsOrderByRelevanceFieldEnum]


  export const CFDetailsOrderByRelevanceFieldEnum: {
    process: 'process',
    scope: 'scope'
  };

  export type CFDetailsOrderByRelevanceFieldEnum = (typeof CFDetailsOrderByRelevanceFieldEnum)[keyof typeof CFDetailsOrderByRelevanceFieldEnum]


  export const CFPieChartOrderByRelevanceFieldEnum: {
    scope: 'scope',
    value: 'value',
    percentage: 'percentage'
  };

  export type CFPieChartOrderByRelevanceFieldEnum = (typeof CFPieChartOrderByRelevanceFieldEnum)[keyof typeof CFPieChartOrderByRelevanceFieldEnum]


  export const CFTrendChartOrderByRelevanceFieldEnum: {
    month: 'month',
    footprint: 'footprint',
    scope1: 'scope1',
    scope2: 'scope2',
    scope3: 'scope3'
  };

  export type CFTrendChartOrderByRelevanceFieldEnum = (typeof CFTrendChartOrderByRelevanceFieldEnum)[keyof typeof CFTrendChartOrderByRelevanceFieldEnum]


  export const EAConsumptionTrendOrderByRelevanceFieldEnum: {
    date: 'date'
  };

  export type EAConsumptionTrendOrderByRelevanceFieldEnum = (typeof EAConsumptionTrendOrderByRelevanceFieldEnum)[keyof typeof EAConsumptionTrendOrderByRelevanceFieldEnum]


  export const EAMonthSummaryOrderByRelevanceFieldEnum: {
    month: 'month'
  };

  export type EAMonthSummaryOrderByRelevanceFieldEnum = (typeof EAMonthSummaryOrderByRelevanceFieldEnum)[keyof typeof EAMonthSummaryOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const EAStrategyOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    action: 'action'
  };

  export type EAStrategyOrderByRelevanceFieldEnum = (typeof EAStrategyOrderByRelevanceFieldEnum)[keyof typeof EAStrategyOrderByRelevanceFieldEnum]


  export const EATypeComparisonOrderByRelevanceFieldEnum: {
    month: 'month'
  };

  export type EATypeComparisonOrderByRelevanceFieldEnum = (typeof EATypeComparisonOrderByRelevanceFieldEnum)[keyof typeof EATypeComparisonOrderByRelevanceFieldEnum]


  export const EBParamCardsOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value',
    unit: 'unit',
    trend: 'trend'
  };

  export type EBParamCardsOrderByRelevanceFieldEnum = (typeof EBParamCardsOrderByRelevanceFieldEnum)[keyof typeof EBParamCardsOrderByRelevanceFieldEnum]


  export const EBPieChartOrderByRelevanceFieldEnum: {
    type: 'type',
    value: 'value',
    color: 'color'
  };

  export type EBPieChartOrderByRelevanceFieldEnum = (typeof EBPieChartOrderByRelevanceFieldEnum)[keyof typeof EBPieChartOrderByRelevanceFieldEnum]


  export const EBResultsOrderByRelevanceFieldEnum: {
    savings: 'savings'
  };

  export type EBResultsOrderByRelevanceFieldEnum = (typeof EBResultsOrderByRelevanceFieldEnum)[keyof typeof EBResultsOrderByRelevanceFieldEnum]


  export const EBTrendChartOrderByRelevanceFieldEnum: {
    time: 'time',
    generation: 'generation',
    consumption: 'consumption'
  };

  export type EBTrendChartOrderByRelevanceFieldEnum = (typeof EBTrendChartOrderByRelevanceFieldEnum)[keyof typeof EBTrendChartOrderByRelevanceFieldEnum]


  export const ECenergyFlowRealTimeOrderByRelevanceFieldEnum: {
    energy_type_id: 'energy_type_id',
    flow_value: 'flow_value',
    temperature: 'temperature',
    pressure: 'pressure',
    timestamp: 'timestamp'
  };

  export type ECenergyFlowRealTimeOrderByRelevanceFieldEnum = (typeof ECenergyFlowRealTimeOrderByRelevanceFieldEnum)[keyof typeof ECenergyFlowRealTimeOrderByRelevanceFieldEnum]


  export const ECenergyTypesOrderByRelevanceFieldEnum: {
    type: 'type',
    name: 'name',
    unit: 'unit',
    icon: 'icon',
    conversion_factor: 'conversion_factor',
    created_at: 'created_at'
  };

  export type ECenergyTypesOrderByRelevanceFieldEnum = (typeof ECenergyTypesOrderByRelevanceFieldEnum)[keyof typeof ECenergyTypesOrderByRelevanceFieldEnum]


  export const EChistoryOrderByRelevanceFieldEnum: {
    energy_type_id: 'energy_type_id',
    consumption: 'consumption',
    generation: 'generation',
    status: 'status'
  };

  export type EChistoryOrderByRelevanceFieldEnum = (typeof EChistoryOrderByRelevanceFieldEnum)[keyof typeof EChistoryOrderByRelevanceFieldEnum]


  export const ECrealTimeOrderByRelevanceFieldEnum: {
    energy_type_id: 'energy_type_id',
    current_value: 'current_value',
    total_value: 'total_value',
    unit: 'unit',
    timestamp: 'timestamp',
    status: 'status'
  };

  export type ECrealTimeOrderByRelevanceFieldEnum = (typeof ECrealTimeOrderByRelevanceFieldEnum)[keyof typeof ECrealTimeOrderByRelevanceFieldEnum]


  export const EEBenchmarkRankCardsOrderByRelevanceFieldEnum: {
    name: 'name',
    efficiency: 'efficiency',
    unit: 'unit',
    trend: 'trend'
  };

  export type EEBenchmarkRankCardsOrderByRelevanceFieldEnum = (typeof EEBenchmarkRankCardsOrderByRelevanceFieldEnum)[keyof typeof EEBenchmarkRankCardsOrderByRelevanceFieldEnum]


  export const EEGaugeMetricsOrderByRelevanceFieldEnum: {
    current: 'current',
    target: 'target',
    label: 'label'
  };

  export type EEGaugeMetricsOrderByRelevanceFieldEnum = (typeof EEGaugeMetricsOrderByRelevanceFieldEnum)[keyof typeof EEGaugeMetricsOrderByRelevanceFieldEnum]


  export const EERankingListOrderByRelevanceFieldEnum: {
    enterprise: 'enterprise',
    efficiency: 'efficiency',
    benchmark: 'benchmark',
    delta: 'delta',
    status: 'status'
  };

  export type EERankingListOrderByRelevanceFieldEnum = (typeof EERankingListOrderByRelevanceFieldEnum)[keyof typeof EERankingListOrderByRelevanceFieldEnum]


  export const EETrendChartDataOrderByRelevanceFieldEnum: {
    month: 'month',
    value: 'value',
    benchmark: 'benchmark'
  };

  export type EETrendChartDataOrderByRelevanceFieldEnum = (typeof EETrendChartDataOrderByRelevanceFieldEnum)[keyof typeof EETrendChartDataOrderByRelevanceFieldEnum]


  export const EFSankeyLinksOrderByRelevanceFieldEnum: {
    value: 'value',
    type: 'type'
  };

  export type EFSankeyLinksOrderByRelevanceFieldEnum = (typeof EFSankeyLinksOrderByRelevanceFieldEnum)[keyof typeof EFSankeyLinksOrderByRelevanceFieldEnum]


  export const EFSankeyNodesOrderByRelevanceFieldEnum: {
    name: 'name',
    value: 'value',
    unit: 'unit'
  };

  export type EFSankeyNodesOrderByRelevanceFieldEnum = (typeof EFSankeyNodesOrderByRelevanceFieldEnum)[keyof typeof EFSankeyNodesOrderByRelevanceFieldEnum]


  export const EFSummaryTableOrderByRelevanceFieldEnum: {
    name: 'name',
    total: 'total',
    percentage: 'percentage',
    unit: 'unit'
  };

  export type EFSummaryTableOrderByRelevanceFieldEnum = (typeof EFSummaryTableOrderByRelevanceFieldEnum)[keyof typeof EFSummaryTableOrderByRelevanceFieldEnum]


  export const SCRankingOrderByRelevanceFieldEnum: {
    supplier: 'supplier',
    emission: 'emission',
    intensity: 'intensity',
    compliance: 'compliance'
  };

  export type SCRankingOrderByRelevanceFieldEnum = (typeof SCRankingOrderByRelevanceFieldEnum)[keyof typeof SCRankingOrderByRelevanceFieldEnum]


  export const SCSankeyDataOrderByRelevanceFieldEnum: {
    name: 'name',
    value: 'value',
    co2: 'co2',
    type: 'type'
  };

  export type SCSankeyDataOrderByRelevanceFieldEnum = (typeof SCSankeyDataOrderByRelevanceFieldEnum)[keyof typeof SCSankeyDataOrderByRelevanceFieldEnum]


  export const receiptfcOrderByRelevanceFieldEnum: {
    saleMemberId: 'saleMemberId',
    saleMemberName: 'saleMemberName',
    wasteTypeName: 'wasteTypeName',
    imgUrls: 'imgUrls',
    carNumber: 'carNumber',
    carBrand: 'carBrand'
  };

  export type receiptfcOrderByRelevanceFieldEnum = (typeof receiptfcOrderByRelevanceFieldEnum)[keyof typeof receiptfcOrderByRelevanceFieldEnum]


  export const receiptfgOrderByRelevanceFieldEnum: {
    saleMemberId: 'saleMemberId',
    saleMemberName: 'saleMemberName',
    wasteTypeName: 'wasteTypeName',
    imgUrls: 'imgUrls',
    carNumber: 'carNumber',
    carBrand: 'carBrand'
  };

  export type receiptfgOrderByRelevanceFieldEnum = (typeof receiptfgOrderByRelevanceFieldEnum)[keyof typeof receiptfgOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type CAHoldingsWhereInput = {
    AND?: CAHoldingsWhereInput | CAHoldingsWhereInput[]
    OR?: CAHoldingsWhereInput[]
    NOT?: CAHoldingsWhereInput | CAHoldingsWhereInput[]
    id?: IntFilter<"CAHoldings"> | number
    asset?: StringNullableFilter<"CAHoldings"> | string | null
    quantity?: StringNullableFilter<"CAHoldings"> | string | null
    value?: StringNullableFilter<"CAHoldings"> | string | null
    status?: StringNullableFilter<"CAHoldings"> | string | null
  }

  export type CAHoldingsOrderByWithRelationInput = {
    id?: SortOrder
    asset?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: CAHoldingsOrderByRelevanceInput
  }

  export type CAHoldingsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CAHoldingsWhereInput | CAHoldingsWhereInput[]
    OR?: CAHoldingsWhereInput[]
    NOT?: CAHoldingsWhereInput | CAHoldingsWhereInput[]
    asset?: StringNullableFilter<"CAHoldings"> | string | null
    quantity?: StringNullableFilter<"CAHoldings"> | string | null
    value?: StringNullableFilter<"CAHoldings"> | string | null
    status?: StringNullableFilter<"CAHoldings"> | string | null
  }, "id">

  export type CAHoldingsOrderByWithAggregationInput = {
    id?: SortOrder
    asset?: SortOrderInput | SortOrder
    quantity?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: CAHoldingsCountOrderByAggregateInput
    _avg?: CAHoldingsAvgOrderByAggregateInput
    _max?: CAHoldingsMaxOrderByAggregateInput
    _min?: CAHoldingsMinOrderByAggregateInput
    _sum?: CAHoldingsSumOrderByAggregateInput
  }

  export type CAHoldingsScalarWhereWithAggregatesInput = {
    AND?: CAHoldingsScalarWhereWithAggregatesInput | CAHoldingsScalarWhereWithAggregatesInput[]
    OR?: CAHoldingsScalarWhereWithAggregatesInput[]
    NOT?: CAHoldingsScalarWhereWithAggregatesInput | CAHoldingsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CAHoldings"> | number
    asset?: StringNullableWithAggregatesFilter<"CAHoldings"> | string | null
    quantity?: StringNullableWithAggregatesFilter<"CAHoldings"> | string | null
    value?: StringNullableWithAggregatesFilter<"CAHoldings"> | string | null
    status?: StringNullableWithAggregatesFilter<"CAHoldings"> | string | null
  }

  export type CAMarketCardsWhereInput = {
    AND?: CAMarketCardsWhereInput | CAMarketCardsWhereInput[]
    OR?: CAMarketCardsWhereInput[]
    NOT?: CAMarketCardsWhereInput | CAMarketCardsWhereInput[]
    id?: IntFilter<"CAMarketCards"> | number
    price?: StringNullableFilter<"CAMarketCards"> | string | null
    volume?: StringNullableFilter<"CAMarketCards"> | string | null
    change?: StringNullableFilter<"CAMarketCards"> | string | null
    unit?: StringNullableFilter<"CAMarketCards"> | string | null
  }

  export type CAMarketCardsOrderByWithRelationInput = {
    id?: SortOrder
    price?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _relevance?: CAMarketCardsOrderByRelevanceInput
  }

  export type CAMarketCardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CAMarketCardsWhereInput | CAMarketCardsWhereInput[]
    OR?: CAMarketCardsWhereInput[]
    NOT?: CAMarketCardsWhereInput | CAMarketCardsWhereInput[]
    price?: StringNullableFilter<"CAMarketCards"> | string | null
    volume?: StringNullableFilter<"CAMarketCards"> | string | null
    change?: StringNullableFilter<"CAMarketCards"> | string | null
    unit?: StringNullableFilter<"CAMarketCards"> | string | null
  }, "id">

  export type CAMarketCardsOrderByWithAggregationInput = {
    id?: SortOrder
    price?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    change?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: CAMarketCardsCountOrderByAggregateInput
    _avg?: CAMarketCardsAvgOrderByAggregateInput
    _max?: CAMarketCardsMaxOrderByAggregateInput
    _min?: CAMarketCardsMinOrderByAggregateInput
    _sum?: CAMarketCardsSumOrderByAggregateInput
  }

  export type CAMarketCardsScalarWhereWithAggregatesInput = {
    AND?: CAMarketCardsScalarWhereWithAggregatesInput | CAMarketCardsScalarWhereWithAggregatesInput[]
    OR?: CAMarketCardsScalarWhereWithAggregatesInput[]
    NOT?: CAMarketCardsScalarWhereWithAggregatesInput | CAMarketCardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CAMarketCards"> | number
    price?: StringNullableWithAggregatesFilter<"CAMarketCards"> | string | null
    volume?: StringNullableWithAggregatesFilter<"CAMarketCards"> | string | null
    change?: StringNullableWithAggregatesFilter<"CAMarketCards"> | string | null
    unit?: StringNullableWithAggregatesFilter<"CAMarketCards"> | string | null
  }

  export type CAPieChartWhereInput = {
    AND?: CAPieChartWhereInput | CAPieChartWhereInput[]
    OR?: CAPieChartWhereInput[]
    NOT?: CAPieChartWhereInput | CAPieChartWhereInput[]
    id?: IntFilter<"CAPieChart"> | number
    type?: StringNullableFilter<"CAPieChart"> | string | null
    value?: StringNullableFilter<"CAPieChart"> | string | null
    percentage?: StringNullableFilter<"CAPieChart"> | string | null
  }

  export type CAPieChartOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    _relevance?: CAPieChartOrderByRelevanceInput
  }

  export type CAPieChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CAPieChartWhereInput | CAPieChartWhereInput[]
    OR?: CAPieChartWhereInput[]
    NOT?: CAPieChartWhereInput | CAPieChartWhereInput[]
    type?: StringNullableFilter<"CAPieChart"> | string | null
    value?: StringNullableFilter<"CAPieChart"> | string | null
    percentage?: StringNullableFilter<"CAPieChart"> | string | null
  }, "id">

  export type CAPieChartOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    _count?: CAPieChartCountOrderByAggregateInput
    _avg?: CAPieChartAvgOrderByAggregateInput
    _max?: CAPieChartMaxOrderByAggregateInput
    _min?: CAPieChartMinOrderByAggregateInput
    _sum?: CAPieChartSumOrderByAggregateInput
  }

  export type CAPieChartScalarWhereWithAggregatesInput = {
    AND?: CAPieChartScalarWhereWithAggregatesInput | CAPieChartScalarWhereWithAggregatesInput[]
    OR?: CAPieChartScalarWhereWithAggregatesInput[]
    NOT?: CAPieChartScalarWhereWithAggregatesInput | CAPieChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CAPieChart"> | number
    type?: StringNullableWithAggregatesFilter<"CAPieChart"> | string | null
    value?: StringNullableWithAggregatesFilter<"CAPieChart"> | string | null
    percentage?: StringNullableWithAggregatesFilter<"CAPieChart"> | string | null
  }

  export type CAPriceChartWhereInput = {
    AND?: CAPriceChartWhereInput | CAPriceChartWhereInput[]
    OR?: CAPriceChartWhereInput[]
    NOT?: CAPriceChartWhereInput | CAPriceChartWhereInput[]
    id?: IntFilter<"CAPriceChart"> | number
    date?: StringNullableFilter<"CAPriceChart"> | string | null
    price?: StringNullableFilter<"CAPriceChart"> | string | null
    volume?: StringNullableFilter<"CAPriceChart"> | string | null
  }

  export type CAPriceChartOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    _relevance?: CAPriceChartOrderByRelevanceInput
  }

  export type CAPriceChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CAPriceChartWhereInput | CAPriceChartWhereInput[]
    OR?: CAPriceChartWhereInput[]
    NOT?: CAPriceChartWhereInput | CAPriceChartWhereInput[]
    date?: StringNullableFilter<"CAPriceChart"> | string | null
    price?: StringNullableFilter<"CAPriceChart"> | string | null
    volume?: StringNullableFilter<"CAPriceChart"> | string | null
  }, "id">

  export type CAPriceChartOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    volume?: SortOrderInput | SortOrder
    _count?: CAPriceChartCountOrderByAggregateInput
    _avg?: CAPriceChartAvgOrderByAggregateInput
    _max?: CAPriceChartMaxOrderByAggregateInput
    _min?: CAPriceChartMinOrderByAggregateInput
    _sum?: CAPriceChartSumOrderByAggregateInput
  }

  export type CAPriceChartScalarWhereWithAggregatesInput = {
    AND?: CAPriceChartScalarWhereWithAggregatesInput | CAPriceChartScalarWhereWithAggregatesInput[]
    OR?: CAPriceChartScalarWhereWithAggregatesInput[]
    NOT?: CAPriceChartScalarWhereWithAggregatesInput | CAPriceChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CAPriceChart"> | number
    date?: StringNullableWithAggregatesFilter<"CAPriceChart"> | string | null
    price?: StringNullableWithAggregatesFilter<"CAPriceChart"> | string | null
    volume?: StringNullableWithAggregatesFilter<"CAPriceChart"> | string | null
  }

  export type CBComparisonChartWhereInput = {
    AND?: CBComparisonChartWhereInput | CBComparisonChartWhereInput[]
    OR?: CBComparisonChartWhereInput[]
    NOT?: CBComparisonChartWhereInput | CBComparisonChartWhereInput[]
    id?: IntFilter<"CBComparisonChart"> | number
    month?: StringNullableFilter<"CBComparisonChart"> | string | null
    actual?: StringNullableFilter<"CBComparisonChart"> | string | null
    budget?: StringNullableFilter<"CBComparisonChart"> | string | null
  }

  export type CBComparisonChartOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    actual?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    _relevance?: CBComparisonChartOrderByRelevanceInput
  }

  export type CBComparisonChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CBComparisonChartWhereInput | CBComparisonChartWhereInput[]
    OR?: CBComparisonChartWhereInput[]
    NOT?: CBComparisonChartWhereInput | CBComparisonChartWhereInput[]
    month?: StringNullableFilter<"CBComparisonChart"> | string | null
    actual?: StringNullableFilter<"CBComparisonChart"> | string | null
    budget?: StringNullableFilter<"CBComparisonChart"> | string | null
  }, "id">

  export type CBComparisonChartOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    actual?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    _count?: CBComparisonChartCountOrderByAggregateInput
    _avg?: CBComparisonChartAvgOrderByAggregateInput
    _max?: CBComparisonChartMaxOrderByAggregateInput
    _min?: CBComparisonChartMinOrderByAggregateInput
    _sum?: CBComparisonChartSumOrderByAggregateInput
  }

  export type CBComparisonChartScalarWhereWithAggregatesInput = {
    AND?: CBComparisonChartScalarWhereWithAggregatesInput | CBComparisonChartScalarWhereWithAggregatesInput[]
    OR?: CBComparisonChartScalarWhereWithAggregatesInput[]
    NOT?: CBComparisonChartScalarWhereWithAggregatesInput | CBComparisonChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CBComparisonChart"> | number
    month?: StringNullableWithAggregatesFilter<"CBComparisonChart"> | string | null
    actual?: StringNullableWithAggregatesFilter<"CBComparisonChart"> | string | null
    budget?: StringNullableWithAggregatesFilter<"CBComparisonChart"> | string | null
  }

  export type CBMonthlyDetailsWhereInput = {
    AND?: CBMonthlyDetailsWhereInput | CBMonthlyDetailsWhereInput[]
    OR?: CBMonthlyDetailsWhereInput[]
    NOT?: CBMonthlyDetailsWhereInput | CBMonthlyDetailsWhereInput[]
    id?: IntFilter<"CBMonthlyDetails"> | number
    month?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    energy_budget?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    actual?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    variance?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    status?: StringNullableFilter<"CBMonthlyDetails"> | string | null
  }

  export type CBMonthlyDetailsOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    energy_budget?: SortOrderInput | SortOrder
    actual?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: CBMonthlyDetailsOrderByRelevanceInput
  }

  export type CBMonthlyDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CBMonthlyDetailsWhereInput | CBMonthlyDetailsWhereInput[]
    OR?: CBMonthlyDetailsWhereInput[]
    NOT?: CBMonthlyDetailsWhereInput | CBMonthlyDetailsWhereInput[]
    month?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    energy_budget?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    actual?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    variance?: StringNullableFilter<"CBMonthlyDetails"> | string | null
    status?: StringNullableFilter<"CBMonthlyDetails"> | string | null
  }, "id">

  export type CBMonthlyDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    energy_budget?: SortOrderInput | SortOrder
    actual?: SortOrderInput | SortOrder
    variance?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: CBMonthlyDetailsCountOrderByAggregateInput
    _avg?: CBMonthlyDetailsAvgOrderByAggregateInput
    _max?: CBMonthlyDetailsMaxOrderByAggregateInput
    _min?: CBMonthlyDetailsMinOrderByAggregateInput
    _sum?: CBMonthlyDetailsSumOrderByAggregateInput
  }

  export type CBMonthlyDetailsScalarWhereWithAggregatesInput = {
    AND?: CBMonthlyDetailsScalarWhereWithAggregatesInput | CBMonthlyDetailsScalarWhereWithAggregatesInput[]
    OR?: CBMonthlyDetailsScalarWhereWithAggregatesInput[]
    NOT?: CBMonthlyDetailsScalarWhereWithAggregatesInput | CBMonthlyDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CBMonthlyDetails"> | number
    month?: StringNullableWithAggregatesFilter<"CBMonthlyDetails"> | string | null
    energy_budget?: StringNullableWithAggregatesFilter<"CBMonthlyDetails"> | string | null
    actual?: StringNullableWithAggregatesFilter<"CBMonthlyDetails"> | string | null
    variance?: StringNullableWithAggregatesFilter<"CBMonthlyDetails"> | string | null
    status?: StringNullableWithAggregatesFilter<"CBMonthlyDetails"> | string | null
  }

  export type CBSummaryCardsWhereInput = {
    AND?: CBSummaryCardsWhereInput | CBSummaryCardsWhereInput[]
    OR?: CBSummaryCardsWhereInput[]
    NOT?: CBSummaryCardsWhereInput | CBSummaryCardsWhereInput[]
    id?: IntFilter<"CBSummaryCards"> | number
    total_energy?: StringNullableFilter<"CBSummaryCards"> | string | null
    used?: StringNullableFilter<"CBSummaryCards"> | string | null
    remaining?: StringNullableFilter<"CBSummaryCards"> | string | null
    overrun_rate?: StringNullableFilter<"CBSummaryCards"> | string | null
    unit?: StringNullableFilter<"CBSummaryCards"> | string | null
  }

  export type CBSummaryCardsOrderByWithRelationInput = {
    id?: SortOrder
    total_energy?: SortOrderInput | SortOrder
    used?: SortOrderInput | SortOrder
    remaining?: SortOrderInput | SortOrder
    overrun_rate?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _relevance?: CBSummaryCardsOrderByRelevanceInput
  }

  export type CBSummaryCardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CBSummaryCardsWhereInput | CBSummaryCardsWhereInput[]
    OR?: CBSummaryCardsWhereInput[]
    NOT?: CBSummaryCardsWhereInput | CBSummaryCardsWhereInput[]
    total_energy?: StringNullableFilter<"CBSummaryCards"> | string | null
    used?: StringNullableFilter<"CBSummaryCards"> | string | null
    remaining?: StringNullableFilter<"CBSummaryCards"> | string | null
    overrun_rate?: StringNullableFilter<"CBSummaryCards"> | string | null
    unit?: StringNullableFilter<"CBSummaryCards"> | string | null
  }, "id">

  export type CBSummaryCardsOrderByWithAggregationInput = {
    id?: SortOrder
    total_energy?: SortOrderInput | SortOrder
    used?: SortOrderInput | SortOrder
    remaining?: SortOrderInput | SortOrder
    overrun_rate?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: CBSummaryCardsCountOrderByAggregateInput
    _avg?: CBSummaryCardsAvgOrderByAggregateInput
    _max?: CBSummaryCardsMaxOrderByAggregateInput
    _min?: CBSummaryCardsMinOrderByAggregateInput
    _sum?: CBSummaryCardsSumOrderByAggregateInput
  }

  export type CBSummaryCardsScalarWhereWithAggregatesInput = {
    AND?: CBSummaryCardsScalarWhereWithAggregatesInput | CBSummaryCardsScalarWhereWithAggregatesInput[]
    OR?: CBSummaryCardsScalarWhereWithAggregatesInput[]
    NOT?: CBSummaryCardsScalarWhereWithAggregatesInput | CBSummaryCardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CBSummaryCards"> | number
    total_energy?: StringNullableWithAggregatesFilter<"CBSummaryCards"> | string | null
    used?: StringNullableWithAggregatesFilter<"CBSummaryCards"> | string | null
    remaining?: StringNullableWithAggregatesFilter<"CBSummaryCards"> | string | null
    overrun_rate?: StringNullableWithAggregatesFilter<"CBSummaryCards"> | string | null
    unit?: StringNullableWithAggregatesFilter<"CBSummaryCards"> | string | null
  }

  export type CFDetailsWhereInput = {
    AND?: CFDetailsWhereInput | CFDetailsWhereInput[]
    OR?: CFDetailsWhereInput[]
    NOT?: CFDetailsWhereInput | CFDetailsWhereInput[]
    id?: IntFilter<"CFDetails"> | number
    process?: StringNullableFilter<"CFDetails"> | string | null
    scope?: StringNullableFilter<"CFDetails"> | string | null
    emission?: DecimalNullableFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
    factor?: DecimalNullableFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsOrderByWithRelationInput = {
    id?: SortOrder
    process?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    emission?: SortOrderInput | SortOrder
    factor?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    _relevance?: CFDetailsOrderByRelevanceInput
  }

  export type CFDetailsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CFDetailsWhereInput | CFDetailsWhereInput[]
    OR?: CFDetailsWhereInput[]
    NOT?: CFDetailsWhereInput | CFDetailsWhereInput[]
    process?: StringNullableFilter<"CFDetails"> | string | null
    scope?: StringNullableFilter<"CFDetails"> | string | null
    emission?: DecimalNullableFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
    factor?: DecimalNullableFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type CFDetailsOrderByWithAggregationInput = {
    id?: SortOrder
    process?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    emission?: SortOrderInput | SortOrder
    factor?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    _count?: CFDetailsCountOrderByAggregateInput
    _avg?: CFDetailsAvgOrderByAggregateInput
    _max?: CFDetailsMaxOrderByAggregateInput
    _min?: CFDetailsMinOrderByAggregateInput
    _sum?: CFDetailsSumOrderByAggregateInput
  }

  export type CFDetailsScalarWhereWithAggregatesInput = {
    AND?: CFDetailsScalarWhereWithAggregatesInput | CFDetailsScalarWhereWithAggregatesInput[]
    OR?: CFDetailsScalarWhereWithAggregatesInput[]
    NOT?: CFDetailsScalarWhereWithAggregatesInput | CFDetailsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CFDetails"> | number
    process?: StringNullableWithAggregatesFilter<"CFDetails"> | string | null
    scope?: StringNullableWithAggregatesFilter<"CFDetails"> | string | null
    emission?: DecimalNullableWithAggregatesFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
    factor?: DecimalNullableWithAggregatesFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
    total?: DecimalNullableWithAggregatesFilter<"CFDetails"> | Decimal | DecimalJsLike | number | string | null
  }

  export type CFPieChartWhereInput = {
    AND?: CFPieChartWhereInput | CFPieChartWhereInput[]
    OR?: CFPieChartWhereInput[]
    NOT?: CFPieChartWhereInput | CFPieChartWhereInput[]
    id?: IntFilter<"CFPieChart"> | number
    scope?: StringNullableFilter<"CFPieChart"> | string | null
    value?: StringNullableFilter<"CFPieChart"> | string | null
    percentage?: StringNullableFilter<"CFPieChart"> | string | null
  }

  export type CFPieChartOrderByWithRelationInput = {
    id?: SortOrder
    scope?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    _relevance?: CFPieChartOrderByRelevanceInput
  }

  export type CFPieChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CFPieChartWhereInput | CFPieChartWhereInput[]
    OR?: CFPieChartWhereInput[]
    NOT?: CFPieChartWhereInput | CFPieChartWhereInput[]
    scope?: StringNullableFilter<"CFPieChart"> | string | null
    value?: StringNullableFilter<"CFPieChart"> | string | null
    percentage?: StringNullableFilter<"CFPieChart"> | string | null
  }, "id">

  export type CFPieChartOrderByWithAggregationInput = {
    id?: SortOrder
    scope?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    _count?: CFPieChartCountOrderByAggregateInput
    _avg?: CFPieChartAvgOrderByAggregateInput
    _max?: CFPieChartMaxOrderByAggregateInput
    _min?: CFPieChartMinOrderByAggregateInput
    _sum?: CFPieChartSumOrderByAggregateInput
  }

  export type CFPieChartScalarWhereWithAggregatesInput = {
    AND?: CFPieChartScalarWhereWithAggregatesInput | CFPieChartScalarWhereWithAggregatesInput[]
    OR?: CFPieChartScalarWhereWithAggregatesInput[]
    NOT?: CFPieChartScalarWhereWithAggregatesInput | CFPieChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CFPieChart"> | number
    scope?: StringNullableWithAggregatesFilter<"CFPieChart"> | string | null
    value?: StringNullableWithAggregatesFilter<"CFPieChart"> | string | null
    percentage?: StringNullableWithAggregatesFilter<"CFPieChart"> | string | null
  }

  export type CFTrendChartWhereInput = {
    AND?: CFTrendChartWhereInput | CFTrendChartWhereInput[]
    OR?: CFTrendChartWhereInput[]
    NOT?: CFTrendChartWhereInput | CFTrendChartWhereInput[]
    id?: IntFilter<"CFTrendChart"> | number
    month?: StringNullableFilter<"CFTrendChart"> | string | null
    footprint?: StringNullableFilter<"CFTrendChart"> | string | null
    scope1?: StringNullableFilter<"CFTrendChart"> | string | null
    scope2?: StringNullableFilter<"CFTrendChart"> | string | null
    scope3?: StringNullableFilter<"CFTrendChart"> | string | null
  }

  export type CFTrendChartOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    footprint?: SortOrderInput | SortOrder
    scope1?: SortOrderInput | SortOrder
    scope2?: SortOrderInput | SortOrder
    scope3?: SortOrderInput | SortOrder
    _relevance?: CFTrendChartOrderByRelevanceInput
  }

  export type CFTrendChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CFTrendChartWhereInput | CFTrendChartWhereInput[]
    OR?: CFTrendChartWhereInput[]
    NOT?: CFTrendChartWhereInput | CFTrendChartWhereInput[]
    month?: StringNullableFilter<"CFTrendChart"> | string | null
    footprint?: StringNullableFilter<"CFTrendChart"> | string | null
    scope1?: StringNullableFilter<"CFTrendChart"> | string | null
    scope2?: StringNullableFilter<"CFTrendChart"> | string | null
    scope3?: StringNullableFilter<"CFTrendChart"> | string | null
  }, "id">

  export type CFTrendChartOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    footprint?: SortOrderInput | SortOrder
    scope1?: SortOrderInput | SortOrder
    scope2?: SortOrderInput | SortOrder
    scope3?: SortOrderInput | SortOrder
    _count?: CFTrendChartCountOrderByAggregateInput
    _avg?: CFTrendChartAvgOrderByAggregateInput
    _max?: CFTrendChartMaxOrderByAggregateInput
    _min?: CFTrendChartMinOrderByAggregateInput
    _sum?: CFTrendChartSumOrderByAggregateInput
  }

  export type CFTrendChartScalarWhereWithAggregatesInput = {
    AND?: CFTrendChartScalarWhereWithAggregatesInput | CFTrendChartScalarWhereWithAggregatesInput[]
    OR?: CFTrendChartScalarWhereWithAggregatesInput[]
    NOT?: CFTrendChartScalarWhereWithAggregatesInput | CFTrendChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CFTrendChart"> | number
    month?: StringNullableWithAggregatesFilter<"CFTrendChart"> | string | null
    footprint?: StringNullableWithAggregatesFilter<"CFTrendChart"> | string | null
    scope1?: StringNullableWithAggregatesFilter<"CFTrendChart"> | string | null
    scope2?: StringNullableWithAggregatesFilter<"CFTrendChart"> | string | null
    scope3?: StringNullableWithAggregatesFilter<"CFTrendChart"> | string | null
  }

  export type EAConsumptionTrendWhereInput = {
    AND?: EAConsumptionTrendWhereInput | EAConsumptionTrendWhereInput[]
    OR?: EAConsumptionTrendWhereInput[]
    NOT?: EAConsumptionTrendWhereInput | EAConsumptionTrendWhereInput[]
    id?: IntFilter<"EAConsumptionTrend"> | number
    date?: StringNullableFilter<"EAConsumptionTrend"> | string | null
    total?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    upstream?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    downstream?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    forecast?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendOrderByWithRelationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    upstream?: SortOrderInput | SortOrder
    downstream?: SortOrderInput | SortOrder
    forecast?: SortOrderInput | SortOrder
    _relevance?: EAConsumptionTrendOrderByRelevanceInput
  }

  export type EAConsumptionTrendWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EAConsumptionTrendWhereInput | EAConsumptionTrendWhereInput[]
    OR?: EAConsumptionTrendWhereInput[]
    NOT?: EAConsumptionTrendWhereInput | EAConsumptionTrendWhereInput[]
    date?: StringNullableFilter<"EAConsumptionTrend"> | string | null
    total?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    upstream?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    downstream?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    forecast?: DecimalNullableFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type EAConsumptionTrendOrderByWithAggregationInput = {
    id?: SortOrder
    date?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    upstream?: SortOrderInput | SortOrder
    downstream?: SortOrderInput | SortOrder
    forecast?: SortOrderInput | SortOrder
    _count?: EAConsumptionTrendCountOrderByAggregateInput
    _avg?: EAConsumptionTrendAvgOrderByAggregateInput
    _max?: EAConsumptionTrendMaxOrderByAggregateInput
    _min?: EAConsumptionTrendMinOrderByAggregateInput
    _sum?: EAConsumptionTrendSumOrderByAggregateInput
  }

  export type EAConsumptionTrendScalarWhereWithAggregatesInput = {
    AND?: EAConsumptionTrendScalarWhereWithAggregatesInput | EAConsumptionTrendScalarWhereWithAggregatesInput[]
    OR?: EAConsumptionTrendScalarWhereWithAggregatesInput[]
    NOT?: EAConsumptionTrendScalarWhereWithAggregatesInput | EAConsumptionTrendScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EAConsumptionTrend"> | number
    date?: StringNullableWithAggregatesFilter<"EAConsumptionTrend"> | string | null
    total?: DecimalNullableWithAggregatesFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    upstream?: DecimalNullableWithAggregatesFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    downstream?: DecimalNullableWithAggregatesFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
    forecast?: DecimalNullableWithAggregatesFilter<"EAConsumptionTrend"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryWhereInput = {
    AND?: EAMonthSummaryWhereInput | EAMonthSummaryWhereInput[]
    OR?: EAMonthSummaryWhereInput[]
    NOT?: EAMonthSummaryWhereInput | EAMonthSummaryWhereInput[]
    id?: IntFilter<"EAMonthSummary"> | number
    month?: StringNullableFilter<"EAMonthSummary"> | string | null
    total?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    upstream?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    growth_rate?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    upstream?: SortOrderInput | SortOrder
    growth_rate?: SortOrderInput | SortOrder
    forecast_growth?: SortOrderInput | SortOrder
    _relevance?: EAMonthSummaryOrderByRelevanceInput
  }

  export type EAMonthSummaryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EAMonthSummaryWhereInput | EAMonthSummaryWhereInput[]
    OR?: EAMonthSummaryWhereInput[]
    NOT?: EAMonthSummaryWhereInput | EAMonthSummaryWhereInput[]
    month?: StringNullableFilter<"EAMonthSummary"> | string | null
    total?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    upstream?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    growth_rate?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: DecimalNullableFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type EAMonthSummaryOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    upstream?: SortOrderInput | SortOrder
    growth_rate?: SortOrderInput | SortOrder
    forecast_growth?: SortOrderInput | SortOrder
    _count?: EAMonthSummaryCountOrderByAggregateInput
    _avg?: EAMonthSummaryAvgOrderByAggregateInput
    _max?: EAMonthSummaryMaxOrderByAggregateInput
    _min?: EAMonthSummaryMinOrderByAggregateInput
    _sum?: EAMonthSummarySumOrderByAggregateInput
  }

  export type EAMonthSummaryScalarWhereWithAggregatesInput = {
    AND?: EAMonthSummaryScalarWhereWithAggregatesInput | EAMonthSummaryScalarWhereWithAggregatesInput[]
    OR?: EAMonthSummaryScalarWhereWithAggregatesInput[]
    NOT?: EAMonthSummaryScalarWhereWithAggregatesInput | EAMonthSummaryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EAMonthSummary"> | number
    month?: StringNullableWithAggregatesFilter<"EAMonthSummary"> | string | null
    total?: DecimalNullableWithAggregatesFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    upstream?: DecimalNullableWithAggregatesFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    growth_rate?: DecimalNullableWithAggregatesFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: DecimalNullableWithAggregatesFilter<"EAMonthSummary"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EAStrategyWhereInput = {
    AND?: EAStrategyWhereInput | EAStrategyWhereInput[]
    OR?: EAStrategyWhereInput[]
    NOT?: EAStrategyWhereInput | EAStrategyWhereInput[]
    id?: IntFilter<"EAStrategy"> | number
    title?: StringNullableFilter<"EAStrategy"> | string | null
    description?: StringNullableFilter<"EAStrategy"> | string | null
    impact?: JsonNullableFilter<"EAStrategy">
    action?: StringNullableFilter<"EAStrategy"> | string | null
  }

  export type EAStrategyOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    _relevance?: EAStrategyOrderByRelevanceInput
  }

  export type EAStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EAStrategyWhereInput | EAStrategyWhereInput[]
    OR?: EAStrategyWhereInput[]
    NOT?: EAStrategyWhereInput | EAStrategyWhereInput[]
    title?: StringNullableFilter<"EAStrategy"> | string | null
    description?: StringNullableFilter<"EAStrategy"> | string | null
    impact?: JsonNullableFilter<"EAStrategy">
    action?: StringNullableFilter<"EAStrategy"> | string | null
  }, "id">

  export type EAStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    impact?: SortOrderInput | SortOrder
    action?: SortOrderInput | SortOrder
    _count?: EAStrategyCountOrderByAggregateInput
    _avg?: EAStrategyAvgOrderByAggregateInput
    _max?: EAStrategyMaxOrderByAggregateInput
    _min?: EAStrategyMinOrderByAggregateInput
    _sum?: EAStrategySumOrderByAggregateInput
  }

  export type EAStrategyScalarWhereWithAggregatesInput = {
    AND?: EAStrategyScalarWhereWithAggregatesInput | EAStrategyScalarWhereWithAggregatesInput[]
    OR?: EAStrategyScalarWhereWithAggregatesInput[]
    NOT?: EAStrategyScalarWhereWithAggregatesInput | EAStrategyScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EAStrategy"> | number
    title?: StringNullableWithAggregatesFilter<"EAStrategy"> | string | null
    description?: StringNullableWithAggregatesFilter<"EAStrategy"> | string | null
    impact?: JsonNullableWithAggregatesFilter<"EAStrategy">
    action?: StringNullableWithAggregatesFilter<"EAStrategy"> | string | null
  }

  export type EATypeComparisonWhereInput = {
    AND?: EATypeComparisonWhereInput | EATypeComparisonWhereInput[]
    OR?: EATypeComparisonWhereInput[]
    NOT?: EATypeComparisonWhereInput | EATypeComparisonWhereInput[]
    id?: IntFilter<"EATypeComparison"> | number
    month?: StringNullableFilter<"EATypeComparison"> | string | null
    coal?: DecimalNullableFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
    gas?: DecimalNullableFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
    electric?: DecimalNullableFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    coal?: SortOrderInput | SortOrder
    gas?: SortOrderInput | SortOrder
    electric?: SortOrderInput | SortOrder
    _relevance?: EATypeComparisonOrderByRelevanceInput
  }

  export type EATypeComparisonWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EATypeComparisonWhereInput | EATypeComparisonWhereInput[]
    OR?: EATypeComparisonWhereInput[]
    NOT?: EATypeComparisonWhereInput | EATypeComparisonWhereInput[]
    month?: StringNullableFilter<"EATypeComparison"> | string | null
    coal?: DecimalNullableFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
    gas?: DecimalNullableFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
    electric?: DecimalNullableFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
  }, "id">

  export type EATypeComparisonOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    coal?: SortOrderInput | SortOrder
    gas?: SortOrderInput | SortOrder
    electric?: SortOrderInput | SortOrder
    _count?: EATypeComparisonCountOrderByAggregateInput
    _avg?: EATypeComparisonAvgOrderByAggregateInput
    _max?: EATypeComparisonMaxOrderByAggregateInput
    _min?: EATypeComparisonMinOrderByAggregateInput
    _sum?: EATypeComparisonSumOrderByAggregateInput
  }

  export type EATypeComparisonScalarWhereWithAggregatesInput = {
    AND?: EATypeComparisonScalarWhereWithAggregatesInput | EATypeComparisonScalarWhereWithAggregatesInput[]
    OR?: EATypeComparisonScalarWhereWithAggregatesInput[]
    NOT?: EATypeComparisonScalarWhereWithAggregatesInput | EATypeComparisonScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EATypeComparison"> | number
    month?: StringNullableWithAggregatesFilter<"EATypeComparison"> | string | null
    coal?: DecimalNullableWithAggregatesFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
    gas?: DecimalNullableWithAggregatesFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
    electric?: DecimalNullableWithAggregatesFilter<"EATypeComparison"> | Decimal | DecimalJsLike | number | string | null
  }

  export type EBParamCardsWhereInput = {
    AND?: EBParamCardsWhereInput | EBParamCardsWhereInput[]
    OR?: EBParamCardsWhereInput[]
    NOT?: EBParamCardsWhereInput | EBParamCardsWhereInput[]
    id?: IntFilter<"EBParamCards"> | number
    key?: StringNullableFilter<"EBParamCards"> | string | null
    value?: StringNullableFilter<"EBParamCards"> | string | null
    unit?: StringNullableFilter<"EBParamCards"> | string | null
    trend?: StringNullableFilter<"EBParamCards"> | string | null
  }

  export type EBParamCardsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    _relevance?: EBParamCardsOrderByRelevanceInput
  }

  export type EBParamCardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EBParamCardsWhereInput | EBParamCardsWhereInput[]
    OR?: EBParamCardsWhereInput[]
    NOT?: EBParamCardsWhereInput | EBParamCardsWhereInput[]
    key?: StringNullableFilter<"EBParamCards"> | string | null
    value?: StringNullableFilter<"EBParamCards"> | string | null
    unit?: StringNullableFilter<"EBParamCards"> | string | null
    trend?: StringNullableFilter<"EBParamCards"> | string | null
  }, "id">

  export type EBParamCardsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    _count?: EBParamCardsCountOrderByAggregateInput
    _avg?: EBParamCardsAvgOrderByAggregateInput
    _max?: EBParamCardsMaxOrderByAggregateInput
    _min?: EBParamCardsMinOrderByAggregateInput
    _sum?: EBParamCardsSumOrderByAggregateInput
  }

  export type EBParamCardsScalarWhereWithAggregatesInput = {
    AND?: EBParamCardsScalarWhereWithAggregatesInput | EBParamCardsScalarWhereWithAggregatesInput[]
    OR?: EBParamCardsScalarWhereWithAggregatesInput[]
    NOT?: EBParamCardsScalarWhereWithAggregatesInput | EBParamCardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EBParamCards"> | number
    key?: StringNullableWithAggregatesFilter<"EBParamCards"> | string | null
    value?: StringNullableWithAggregatesFilter<"EBParamCards"> | string | null
    unit?: StringNullableWithAggregatesFilter<"EBParamCards"> | string | null
    trend?: StringNullableWithAggregatesFilter<"EBParamCards"> | string | null
  }

  export type EBPieChartWhereInput = {
    AND?: EBPieChartWhereInput | EBPieChartWhereInput[]
    OR?: EBPieChartWhereInput[]
    NOT?: EBPieChartWhereInput | EBPieChartWhereInput[]
    id?: IntFilter<"EBPieChart"> | number
    type?: StringNullableFilter<"EBPieChart"> | string | null
    value?: StringNullableFilter<"EBPieChart"> | string | null
    color?: StringNullableFilter<"EBPieChart"> | string | null
  }

  export type EBPieChartOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    _relevance?: EBPieChartOrderByRelevanceInput
  }

  export type EBPieChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EBPieChartWhereInput | EBPieChartWhereInput[]
    OR?: EBPieChartWhereInput[]
    NOT?: EBPieChartWhereInput | EBPieChartWhereInput[]
    type?: StringNullableFilter<"EBPieChart"> | string | null
    value?: StringNullableFilter<"EBPieChart"> | string | null
    color?: StringNullableFilter<"EBPieChart"> | string | null
  }, "id">

  export type EBPieChartOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    _count?: EBPieChartCountOrderByAggregateInput
    _avg?: EBPieChartAvgOrderByAggregateInput
    _max?: EBPieChartMaxOrderByAggregateInput
    _min?: EBPieChartMinOrderByAggregateInput
    _sum?: EBPieChartSumOrderByAggregateInput
  }

  export type EBPieChartScalarWhereWithAggregatesInput = {
    AND?: EBPieChartScalarWhereWithAggregatesInput | EBPieChartScalarWhereWithAggregatesInput[]
    OR?: EBPieChartScalarWhereWithAggregatesInput[]
    NOT?: EBPieChartScalarWhereWithAggregatesInput | EBPieChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EBPieChart"> | number
    type?: StringNullableWithAggregatesFilter<"EBPieChart"> | string | null
    value?: StringNullableWithAggregatesFilter<"EBPieChart"> | string | null
    color?: StringNullableWithAggregatesFilter<"EBPieChart"> | string | null
  }

  export type EBResultsWhereInput = {
    AND?: EBResultsWhereInput | EBResultsWhereInput[]
    OR?: EBResultsWhereInput[]
    NOT?: EBResultsWhereInput | EBResultsWhereInput[]
    id?: IntFilter<"EBResults"> | number
    before?: JsonNullableFilter<"EBResults">
    after?: JsonNullableFilter<"EBResults">
    savings?: StringNullableFilter<"EBResults"> | string | null
  }

  export type EBResultsOrderByWithRelationInput = {
    id?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    savings?: SortOrderInput | SortOrder
    _relevance?: EBResultsOrderByRelevanceInput
  }

  export type EBResultsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EBResultsWhereInput | EBResultsWhereInput[]
    OR?: EBResultsWhereInput[]
    NOT?: EBResultsWhereInput | EBResultsWhereInput[]
    before?: JsonNullableFilter<"EBResults">
    after?: JsonNullableFilter<"EBResults">
    savings?: StringNullableFilter<"EBResults"> | string | null
  }, "id">

  export type EBResultsOrderByWithAggregationInput = {
    id?: SortOrder
    before?: SortOrderInput | SortOrder
    after?: SortOrderInput | SortOrder
    savings?: SortOrderInput | SortOrder
    _count?: EBResultsCountOrderByAggregateInput
    _avg?: EBResultsAvgOrderByAggregateInput
    _max?: EBResultsMaxOrderByAggregateInput
    _min?: EBResultsMinOrderByAggregateInput
    _sum?: EBResultsSumOrderByAggregateInput
  }

  export type EBResultsScalarWhereWithAggregatesInput = {
    AND?: EBResultsScalarWhereWithAggregatesInput | EBResultsScalarWhereWithAggregatesInput[]
    OR?: EBResultsScalarWhereWithAggregatesInput[]
    NOT?: EBResultsScalarWhereWithAggregatesInput | EBResultsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EBResults"> | number
    before?: JsonNullableWithAggregatesFilter<"EBResults">
    after?: JsonNullableWithAggregatesFilter<"EBResults">
    savings?: StringNullableWithAggregatesFilter<"EBResults"> | string | null
  }

  export type EBTrendChartWhereInput = {
    AND?: EBTrendChartWhereInput | EBTrendChartWhereInput[]
    OR?: EBTrendChartWhereInput[]
    NOT?: EBTrendChartWhereInput | EBTrendChartWhereInput[]
    id?: IntFilter<"EBTrendChart"> | number
    time?: StringNullableFilter<"EBTrendChart"> | string | null
    generation?: StringNullableFilter<"EBTrendChart"> | string | null
    consumption?: StringNullableFilter<"EBTrendChart"> | string | null
  }

  export type EBTrendChartOrderByWithRelationInput = {
    id?: SortOrder
    time?: SortOrderInput | SortOrder
    generation?: SortOrderInput | SortOrder
    consumption?: SortOrderInput | SortOrder
    _relevance?: EBTrendChartOrderByRelevanceInput
  }

  export type EBTrendChartWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EBTrendChartWhereInput | EBTrendChartWhereInput[]
    OR?: EBTrendChartWhereInput[]
    NOT?: EBTrendChartWhereInput | EBTrendChartWhereInput[]
    time?: StringNullableFilter<"EBTrendChart"> | string | null
    generation?: StringNullableFilter<"EBTrendChart"> | string | null
    consumption?: StringNullableFilter<"EBTrendChart"> | string | null
  }, "id">

  export type EBTrendChartOrderByWithAggregationInput = {
    id?: SortOrder
    time?: SortOrderInput | SortOrder
    generation?: SortOrderInput | SortOrder
    consumption?: SortOrderInput | SortOrder
    _count?: EBTrendChartCountOrderByAggregateInput
    _avg?: EBTrendChartAvgOrderByAggregateInput
    _max?: EBTrendChartMaxOrderByAggregateInput
    _min?: EBTrendChartMinOrderByAggregateInput
    _sum?: EBTrendChartSumOrderByAggregateInput
  }

  export type EBTrendChartScalarWhereWithAggregatesInput = {
    AND?: EBTrendChartScalarWhereWithAggregatesInput | EBTrendChartScalarWhereWithAggregatesInput[]
    OR?: EBTrendChartScalarWhereWithAggregatesInput[]
    NOT?: EBTrendChartScalarWhereWithAggregatesInput | EBTrendChartScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EBTrendChart"> | number
    time?: StringNullableWithAggregatesFilter<"EBTrendChart"> | string | null
    generation?: StringNullableWithAggregatesFilter<"EBTrendChart"> | string | null
    consumption?: StringNullableWithAggregatesFilter<"EBTrendChart"> | string | null
  }

  export type ECenergyFlowRealTimeWhereInput = {
    AND?: ECenergyFlowRealTimeWhereInput | ECenergyFlowRealTimeWhereInput[]
    OR?: ECenergyFlowRealTimeWhereInput[]
    NOT?: ECenergyFlowRealTimeWhereInput | ECenergyFlowRealTimeWhereInput[]
    id?: IntFilter<"ECenergyFlowRealTime"> | number
    device_id?: IntNullableFilter<"ECenergyFlowRealTime"> | number | null
    energy_type_id?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    flow_value?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    temperature?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    pressure?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    timestamp?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
  }

  export type ECenergyFlowRealTimeOrderByWithRelationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    energy_type_id?: SortOrderInput | SortOrder
    flow_value?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    pressure?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _relevance?: ECenergyFlowRealTimeOrderByRelevanceInput
  }

  export type ECenergyFlowRealTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ECenergyFlowRealTimeWhereInput | ECenergyFlowRealTimeWhereInput[]
    OR?: ECenergyFlowRealTimeWhereInput[]
    NOT?: ECenergyFlowRealTimeWhereInput | ECenergyFlowRealTimeWhereInput[]
    device_id?: IntNullableFilter<"ECenergyFlowRealTime"> | number | null
    energy_type_id?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    flow_value?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    temperature?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    pressure?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
    timestamp?: StringNullableFilter<"ECenergyFlowRealTime"> | string | null
  }, "id">

  export type ECenergyFlowRealTimeOrderByWithAggregationInput = {
    id?: SortOrder
    device_id?: SortOrderInput | SortOrder
    energy_type_id?: SortOrderInput | SortOrder
    flow_value?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    pressure?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    _count?: ECenergyFlowRealTimeCountOrderByAggregateInput
    _avg?: ECenergyFlowRealTimeAvgOrderByAggregateInput
    _max?: ECenergyFlowRealTimeMaxOrderByAggregateInput
    _min?: ECenergyFlowRealTimeMinOrderByAggregateInput
    _sum?: ECenergyFlowRealTimeSumOrderByAggregateInput
  }

  export type ECenergyFlowRealTimeScalarWhereWithAggregatesInput = {
    AND?: ECenergyFlowRealTimeScalarWhereWithAggregatesInput | ECenergyFlowRealTimeScalarWhereWithAggregatesInput[]
    OR?: ECenergyFlowRealTimeScalarWhereWithAggregatesInput[]
    NOT?: ECenergyFlowRealTimeScalarWhereWithAggregatesInput | ECenergyFlowRealTimeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ECenergyFlowRealTime"> | number
    device_id?: IntNullableWithAggregatesFilter<"ECenergyFlowRealTime"> | number | null
    energy_type_id?: StringNullableWithAggregatesFilter<"ECenergyFlowRealTime"> | string | null
    flow_value?: StringNullableWithAggregatesFilter<"ECenergyFlowRealTime"> | string | null
    temperature?: StringNullableWithAggregatesFilter<"ECenergyFlowRealTime"> | string | null
    pressure?: StringNullableWithAggregatesFilter<"ECenergyFlowRealTime"> | string | null
    timestamp?: StringNullableWithAggregatesFilter<"ECenergyFlowRealTime"> | string | null
  }

  export type ECenergyTypesWhereInput = {
    AND?: ECenergyTypesWhereInput | ECenergyTypesWhereInput[]
    OR?: ECenergyTypesWhereInput[]
    NOT?: ECenergyTypesWhereInput | ECenergyTypesWhereInput[]
    id?: IntFilter<"ECenergyTypes"> | number
    type?: StringNullableFilter<"ECenergyTypes"> | string | null
    name?: StringNullableFilter<"ECenergyTypes"> | string | null
    unit?: StringNullableFilter<"ECenergyTypes"> | string | null
    icon?: StringNullableFilter<"ECenergyTypes"> | string | null
    conversion_factor?: StringNullableFilter<"ECenergyTypes"> | string | null
    created_at?: StringNullableFilter<"ECenergyTypes"> | string | null
  }

  export type ECenergyTypesOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    conversion_factor?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: ECenergyTypesOrderByRelevanceInput
  }

  export type ECenergyTypesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ECenergyTypesWhereInput | ECenergyTypesWhereInput[]
    OR?: ECenergyTypesWhereInput[]
    NOT?: ECenergyTypesWhereInput | ECenergyTypesWhereInput[]
    type?: StringNullableFilter<"ECenergyTypes"> | string | null
    name?: StringNullableFilter<"ECenergyTypes"> | string | null
    unit?: StringNullableFilter<"ECenergyTypes"> | string | null
    icon?: StringNullableFilter<"ECenergyTypes"> | string | null
    conversion_factor?: StringNullableFilter<"ECenergyTypes"> | string | null
    created_at?: StringNullableFilter<"ECenergyTypes"> | string | null
  }, "id">

  export type ECenergyTypesOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    conversion_factor?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: ECenergyTypesCountOrderByAggregateInput
    _avg?: ECenergyTypesAvgOrderByAggregateInput
    _max?: ECenergyTypesMaxOrderByAggregateInput
    _min?: ECenergyTypesMinOrderByAggregateInput
    _sum?: ECenergyTypesSumOrderByAggregateInput
  }

  export type ECenergyTypesScalarWhereWithAggregatesInput = {
    AND?: ECenergyTypesScalarWhereWithAggregatesInput | ECenergyTypesScalarWhereWithAggregatesInput[]
    OR?: ECenergyTypesScalarWhereWithAggregatesInput[]
    NOT?: ECenergyTypesScalarWhereWithAggregatesInput | ECenergyTypesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ECenergyTypes"> | number
    type?: StringNullableWithAggregatesFilter<"ECenergyTypes"> | string | null
    name?: StringNullableWithAggregatesFilter<"ECenergyTypes"> | string | null
    unit?: StringNullableWithAggregatesFilter<"ECenergyTypes"> | string | null
    icon?: StringNullableWithAggregatesFilter<"ECenergyTypes"> | string | null
    conversion_factor?: StringNullableWithAggregatesFilter<"ECenergyTypes"> | string | null
    created_at?: StringNullableWithAggregatesFilter<"ECenergyTypes"> | string | null
  }

  export type EChistoryWhereInput = {
    AND?: EChistoryWhereInput | EChistoryWhereInput[]
    OR?: EChistoryWhereInput[]
    NOT?: EChistoryWhereInput | EChistoryWhereInput[]
    id?: IntFilter<"EChistory"> | number
    energy_type_id?: StringNullableFilter<"EChistory"> | string | null
    date_time?: DateTimeNullableFilter<"EChistory"> | Date | string | null
    consumption?: StringNullableFilter<"EChistory"> | string | null
    generation?: StringNullableFilter<"EChistory"> | string | null
    status?: StringNullableFilter<"EChistory"> | string | null
  }

  export type EChistoryOrderByWithRelationInput = {
    id?: SortOrder
    energy_type_id?: SortOrderInput | SortOrder
    date_time?: SortOrderInput | SortOrder
    consumption?: SortOrderInput | SortOrder
    generation?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: EChistoryOrderByRelevanceInput
  }

  export type EChistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EChistoryWhereInput | EChistoryWhereInput[]
    OR?: EChistoryWhereInput[]
    NOT?: EChistoryWhereInput | EChistoryWhereInput[]
    energy_type_id?: StringNullableFilter<"EChistory"> | string | null
    date_time?: DateTimeNullableFilter<"EChistory"> | Date | string | null
    consumption?: StringNullableFilter<"EChistory"> | string | null
    generation?: StringNullableFilter<"EChistory"> | string | null
    status?: StringNullableFilter<"EChistory"> | string | null
  }, "id">

  export type EChistoryOrderByWithAggregationInput = {
    id?: SortOrder
    energy_type_id?: SortOrderInput | SortOrder
    date_time?: SortOrderInput | SortOrder
    consumption?: SortOrderInput | SortOrder
    generation?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: EChistoryCountOrderByAggregateInput
    _avg?: EChistoryAvgOrderByAggregateInput
    _max?: EChistoryMaxOrderByAggregateInput
    _min?: EChistoryMinOrderByAggregateInput
    _sum?: EChistorySumOrderByAggregateInput
  }

  export type EChistoryScalarWhereWithAggregatesInput = {
    AND?: EChistoryScalarWhereWithAggregatesInput | EChistoryScalarWhereWithAggregatesInput[]
    OR?: EChistoryScalarWhereWithAggregatesInput[]
    NOT?: EChistoryScalarWhereWithAggregatesInput | EChistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EChistory"> | number
    energy_type_id?: StringNullableWithAggregatesFilter<"EChistory"> | string | null
    date_time?: DateTimeNullableWithAggregatesFilter<"EChistory"> | Date | string | null
    consumption?: StringNullableWithAggregatesFilter<"EChistory"> | string | null
    generation?: StringNullableWithAggregatesFilter<"EChistory"> | string | null
    status?: StringNullableWithAggregatesFilter<"EChistory"> | string | null
  }

  export type ECrealTimeWhereInput = {
    AND?: ECrealTimeWhereInput | ECrealTimeWhereInput[]
    OR?: ECrealTimeWhereInput[]
    NOT?: ECrealTimeWhereInput | ECrealTimeWhereInput[]
    id?: IntFilter<"ECrealTime"> | number
    energy_type_id?: StringNullableFilter<"ECrealTime"> | string | null
    current_value?: StringNullableFilter<"ECrealTime"> | string | null
    total_value?: StringNullableFilter<"ECrealTime"> | string | null
    unit?: StringNullableFilter<"ECrealTime"> | string | null
    timestamp?: StringNullableFilter<"ECrealTime"> | string | null
    status?: StringNullableFilter<"ECrealTime"> | string | null
  }

  export type ECrealTimeOrderByWithRelationInput = {
    id?: SortOrder
    energy_type_id?: SortOrderInput | SortOrder
    current_value?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: ECrealTimeOrderByRelevanceInput
  }

  export type ECrealTimeWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ECrealTimeWhereInput | ECrealTimeWhereInput[]
    OR?: ECrealTimeWhereInput[]
    NOT?: ECrealTimeWhereInput | ECrealTimeWhereInput[]
    energy_type_id?: StringNullableFilter<"ECrealTime"> | string | null
    current_value?: StringNullableFilter<"ECrealTime"> | string | null
    total_value?: StringNullableFilter<"ECrealTime"> | string | null
    unit?: StringNullableFilter<"ECrealTime"> | string | null
    timestamp?: StringNullableFilter<"ECrealTime"> | string | null
    status?: StringNullableFilter<"ECrealTime"> | string | null
  }, "id">

  export type ECrealTimeOrderByWithAggregationInput = {
    id?: SortOrder
    energy_type_id?: SortOrderInput | SortOrder
    current_value?: SortOrderInput | SortOrder
    total_value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    timestamp?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: ECrealTimeCountOrderByAggregateInput
    _avg?: ECrealTimeAvgOrderByAggregateInput
    _max?: ECrealTimeMaxOrderByAggregateInput
    _min?: ECrealTimeMinOrderByAggregateInput
    _sum?: ECrealTimeSumOrderByAggregateInput
  }

  export type ECrealTimeScalarWhereWithAggregatesInput = {
    AND?: ECrealTimeScalarWhereWithAggregatesInput | ECrealTimeScalarWhereWithAggregatesInput[]
    OR?: ECrealTimeScalarWhereWithAggregatesInput[]
    NOT?: ECrealTimeScalarWhereWithAggregatesInput | ECrealTimeScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ECrealTime"> | number
    energy_type_id?: StringNullableWithAggregatesFilter<"ECrealTime"> | string | null
    current_value?: StringNullableWithAggregatesFilter<"ECrealTime"> | string | null
    total_value?: StringNullableWithAggregatesFilter<"ECrealTime"> | string | null
    unit?: StringNullableWithAggregatesFilter<"ECrealTime"> | string | null
    timestamp?: StringNullableWithAggregatesFilter<"ECrealTime"> | string | null
    status?: StringNullableWithAggregatesFilter<"ECrealTime"> | string | null
  }

  export type EEBenchmarkRankCardsWhereInput = {
    AND?: EEBenchmarkRankCardsWhereInput | EEBenchmarkRankCardsWhereInput[]
    OR?: EEBenchmarkRankCardsWhereInput[]
    NOT?: EEBenchmarkRankCardsWhereInput | EEBenchmarkRankCardsWhereInput[]
    id?: IntFilter<"EEBenchmarkRankCards"> | number
    rank?: IntNullableFilter<"EEBenchmarkRankCards"> | number | null
    name?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
    efficiency?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
    unit?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
    trend?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
  }

  export type EEBenchmarkRankCardsOrderByWithRelationInput = {
    id?: SortOrder
    rank?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    _relevance?: EEBenchmarkRankCardsOrderByRelevanceInput
  }

  export type EEBenchmarkRankCardsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EEBenchmarkRankCardsWhereInput | EEBenchmarkRankCardsWhereInput[]
    OR?: EEBenchmarkRankCardsWhereInput[]
    NOT?: EEBenchmarkRankCardsWhereInput | EEBenchmarkRankCardsWhereInput[]
    rank?: IntNullableFilter<"EEBenchmarkRankCards"> | number | null
    name?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
    efficiency?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
    unit?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
    trend?: StringNullableFilter<"EEBenchmarkRankCards"> | string | null
  }, "id">

  export type EEBenchmarkRankCardsOrderByWithAggregationInput = {
    id?: SortOrder
    rank?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    trend?: SortOrderInput | SortOrder
    _count?: EEBenchmarkRankCardsCountOrderByAggregateInput
    _avg?: EEBenchmarkRankCardsAvgOrderByAggregateInput
    _max?: EEBenchmarkRankCardsMaxOrderByAggregateInput
    _min?: EEBenchmarkRankCardsMinOrderByAggregateInput
    _sum?: EEBenchmarkRankCardsSumOrderByAggregateInput
  }

  export type EEBenchmarkRankCardsScalarWhereWithAggregatesInput = {
    AND?: EEBenchmarkRankCardsScalarWhereWithAggregatesInput | EEBenchmarkRankCardsScalarWhereWithAggregatesInput[]
    OR?: EEBenchmarkRankCardsScalarWhereWithAggregatesInput[]
    NOT?: EEBenchmarkRankCardsScalarWhereWithAggregatesInput | EEBenchmarkRankCardsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EEBenchmarkRankCards"> | number
    rank?: IntNullableWithAggregatesFilter<"EEBenchmarkRankCards"> | number | null
    name?: StringNullableWithAggregatesFilter<"EEBenchmarkRankCards"> | string | null
    efficiency?: StringNullableWithAggregatesFilter<"EEBenchmarkRankCards"> | string | null
    unit?: StringNullableWithAggregatesFilter<"EEBenchmarkRankCards"> | string | null
    trend?: StringNullableWithAggregatesFilter<"EEBenchmarkRankCards"> | string | null
  }

  export type EEGaugeMetricsWhereInput = {
    AND?: EEGaugeMetricsWhereInput | EEGaugeMetricsWhereInput[]
    OR?: EEGaugeMetricsWhereInput[]
    NOT?: EEGaugeMetricsWhereInput | EEGaugeMetricsWhereInput[]
    id?: IntFilter<"EEGaugeMetrics"> | number
    current?: StringNullableFilter<"EEGaugeMetrics"> | string | null
    target?: StringNullableFilter<"EEGaugeMetrics"> | string | null
    label?: StringNullableFilter<"EEGaugeMetrics"> | string | null
  }

  export type EEGaugeMetricsOrderByWithRelationInput = {
    id?: SortOrder
    current?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    _relevance?: EEGaugeMetricsOrderByRelevanceInput
  }

  export type EEGaugeMetricsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EEGaugeMetricsWhereInput | EEGaugeMetricsWhereInput[]
    OR?: EEGaugeMetricsWhereInput[]
    NOT?: EEGaugeMetricsWhereInput | EEGaugeMetricsWhereInput[]
    current?: StringNullableFilter<"EEGaugeMetrics"> | string | null
    target?: StringNullableFilter<"EEGaugeMetrics"> | string | null
    label?: StringNullableFilter<"EEGaugeMetrics"> | string | null
  }, "id">

  export type EEGaugeMetricsOrderByWithAggregationInput = {
    id?: SortOrder
    current?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    label?: SortOrderInput | SortOrder
    _count?: EEGaugeMetricsCountOrderByAggregateInput
    _avg?: EEGaugeMetricsAvgOrderByAggregateInput
    _max?: EEGaugeMetricsMaxOrderByAggregateInput
    _min?: EEGaugeMetricsMinOrderByAggregateInput
    _sum?: EEGaugeMetricsSumOrderByAggregateInput
  }

  export type EEGaugeMetricsScalarWhereWithAggregatesInput = {
    AND?: EEGaugeMetricsScalarWhereWithAggregatesInput | EEGaugeMetricsScalarWhereWithAggregatesInput[]
    OR?: EEGaugeMetricsScalarWhereWithAggregatesInput[]
    NOT?: EEGaugeMetricsScalarWhereWithAggregatesInput | EEGaugeMetricsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EEGaugeMetrics"> | number
    current?: StringNullableWithAggregatesFilter<"EEGaugeMetrics"> | string | null
    target?: StringNullableWithAggregatesFilter<"EEGaugeMetrics"> | string | null
    label?: StringNullableWithAggregatesFilter<"EEGaugeMetrics"> | string | null
  }

  export type EERankingListWhereInput = {
    AND?: EERankingListWhereInput | EERankingListWhereInput[]
    OR?: EERankingListWhereInput[]
    NOT?: EERankingListWhereInput | EERankingListWhereInput[]
    id?: IntFilter<"EERankingList"> | number
    enterprise?: StringNullableFilter<"EERankingList"> | string | null
    rank?: IntNullableFilter<"EERankingList"> | number | null
    efficiency?: StringNullableFilter<"EERankingList"> | string | null
    benchmark?: StringNullableFilter<"EERankingList"> | string | null
    delta?: StringNullableFilter<"EERankingList"> | string | null
    status?: StringNullableFilter<"EERankingList"> | string | null
  }

  export type EERankingListOrderByWithRelationInput = {
    id?: SortOrder
    enterprise?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    benchmark?: SortOrderInput | SortOrder
    delta?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _relevance?: EERankingListOrderByRelevanceInput
  }

  export type EERankingListWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EERankingListWhereInput | EERankingListWhereInput[]
    OR?: EERankingListWhereInput[]
    NOT?: EERankingListWhereInput | EERankingListWhereInput[]
    enterprise?: StringNullableFilter<"EERankingList"> | string | null
    rank?: IntNullableFilter<"EERankingList"> | number | null
    efficiency?: StringNullableFilter<"EERankingList"> | string | null
    benchmark?: StringNullableFilter<"EERankingList"> | string | null
    delta?: StringNullableFilter<"EERankingList"> | string | null
    status?: StringNullableFilter<"EERankingList"> | string | null
  }, "id">

  export type EERankingListOrderByWithAggregationInput = {
    id?: SortOrder
    enterprise?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    efficiency?: SortOrderInput | SortOrder
    benchmark?: SortOrderInput | SortOrder
    delta?: SortOrderInput | SortOrder
    status?: SortOrderInput | SortOrder
    _count?: EERankingListCountOrderByAggregateInput
    _avg?: EERankingListAvgOrderByAggregateInput
    _max?: EERankingListMaxOrderByAggregateInput
    _min?: EERankingListMinOrderByAggregateInput
    _sum?: EERankingListSumOrderByAggregateInput
  }

  export type EERankingListScalarWhereWithAggregatesInput = {
    AND?: EERankingListScalarWhereWithAggregatesInput | EERankingListScalarWhereWithAggregatesInput[]
    OR?: EERankingListScalarWhereWithAggregatesInput[]
    NOT?: EERankingListScalarWhereWithAggregatesInput | EERankingListScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EERankingList"> | number
    enterprise?: StringNullableWithAggregatesFilter<"EERankingList"> | string | null
    rank?: IntNullableWithAggregatesFilter<"EERankingList"> | number | null
    efficiency?: StringNullableWithAggregatesFilter<"EERankingList"> | string | null
    benchmark?: StringNullableWithAggregatesFilter<"EERankingList"> | string | null
    delta?: StringNullableWithAggregatesFilter<"EERankingList"> | string | null
    status?: StringNullableWithAggregatesFilter<"EERankingList"> | string | null
  }

  export type EETrendChartDataWhereInput = {
    AND?: EETrendChartDataWhereInput | EETrendChartDataWhereInput[]
    OR?: EETrendChartDataWhereInput[]
    NOT?: EETrendChartDataWhereInput | EETrendChartDataWhereInput[]
    id?: IntFilter<"EETrendChartData"> | number
    month?: StringNullableFilter<"EETrendChartData"> | string | null
    value?: StringNullableFilter<"EETrendChartData"> | string | null
    benchmark?: StringNullableFilter<"EETrendChartData"> | string | null
  }

  export type EETrendChartDataOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    benchmark?: SortOrderInput | SortOrder
    _relevance?: EETrendChartDataOrderByRelevanceInput
  }

  export type EETrendChartDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EETrendChartDataWhereInput | EETrendChartDataWhereInput[]
    OR?: EETrendChartDataWhereInput[]
    NOT?: EETrendChartDataWhereInput | EETrendChartDataWhereInput[]
    month?: StringNullableFilter<"EETrendChartData"> | string | null
    value?: StringNullableFilter<"EETrendChartData"> | string | null
    benchmark?: StringNullableFilter<"EETrendChartData"> | string | null
  }, "id">

  export type EETrendChartDataOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    benchmark?: SortOrderInput | SortOrder
    _count?: EETrendChartDataCountOrderByAggregateInput
    _avg?: EETrendChartDataAvgOrderByAggregateInput
    _max?: EETrendChartDataMaxOrderByAggregateInput
    _min?: EETrendChartDataMinOrderByAggregateInput
    _sum?: EETrendChartDataSumOrderByAggregateInput
  }

  export type EETrendChartDataScalarWhereWithAggregatesInput = {
    AND?: EETrendChartDataScalarWhereWithAggregatesInput | EETrendChartDataScalarWhereWithAggregatesInput[]
    OR?: EETrendChartDataScalarWhereWithAggregatesInput[]
    NOT?: EETrendChartDataScalarWhereWithAggregatesInput | EETrendChartDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EETrendChartData"> | number
    month?: StringNullableWithAggregatesFilter<"EETrendChartData"> | string | null
    value?: StringNullableWithAggregatesFilter<"EETrendChartData"> | string | null
    benchmark?: StringNullableWithAggregatesFilter<"EETrendChartData"> | string | null
  }

  export type EFSankeyLinksWhereInput = {
    AND?: EFSankeyLinksWhereInput | EFSankeyLinksWhereInput[]
    OR?: EFSankeyLinksWhereInput[]
    NOT?: EFSankeyLinksWhereInput | EFSankeyLinksWhereInput[]
    id?: IntFilter<"EFSankeyLinks"> | number
    source?: IntNullableFilter<"EFSankeyLinks"> | number | null
    target?: IntNullableFilter<"EFSankeyLinks"> | number | null
    value?: StringNullableFilter<"EFSankeyLinks"> | string | null
    type?: StringNullableFilter<"EFSankeyLinks"> | string | null
  }

  export type EFSankeyLinksOrderByWithRelationInput = {
    id?: SortOrder
    source?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _relevance?: EFSankeyLinksOrderByRelevanceInput
  }

  export type EFSankeyLinksWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EFSankeyLinksWhereInput | EFSankeyLinksWhereInput[]
    OR?: EFSankeyLinksWhereInput[]
    NOT?: EFSankeyLinksWhereInput | EFSankeyLinksWhereInput[]
    source?: IntNullableFilter<"EFSankeyLinks"> | number | null
    target?: IntNullableFilter<"EFSankeyLinks"> | number | null
    value?: StringNullableFilter<"EFSankeyLinks"> | string | null
    type?: StringNullableFilter<"EFSankeyLinks"> | string | null
  }, "id">

  export type EFSankeyLinksOrderByWithAggregationInput = {
    id?: SortOrder
    source?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: EFSankeyLinksCountOrderByAggregateInput
    _avg?: EFSankeyLinksAvgOrderByAggregateInput
    _max?: EFSankeyLinksMaxOrderByAggregateInput
    _min?: EFSankeyLinksMinOrderByAggregateInput
    _sum?: EFSankeyLinksSumOrderByAggregateInput
  }

  export type EFSankeyLinksScalarWhereWithAggregatesInput = {
    AND?: EFSankeyLinksScalarWhereWithAggregatesInput | EFSankeyLinksScalarWhereWithAggregatesInput[]
    OR?: EFSankeyLinksScalarWhereWithAggregatesInput[]
    NOT?: EFSankeyLinksScalarWhereWithAggregatesInput | EFSankeyLinksScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EFSankeyLinks"> | number
    source?: IntNullableWithAggregatesFilter<"EFSankeyLinks"> | number | null
    target?: IntNullableWithAggregatesFilter<"EFSankeyLinks"> | number | null
    value?: StringNullableWithAggregatesFilter<"EFSankeyLinks"> | string | null
    type?: StringNullableWithAggregatesFilter<"EFSankeyLinks"> | string | null
  }

  export type EFSankeyNodesWhereInput = {
    AND?: EFSankeyNodesWhereInput | EFSankeyNodesWhereInput[]
    OR?: EFSankeyNodesWhereInput[]
    NOT?: EFSankeyNodesWhereInput | EFSankeyNodesWhereInput[]
    id?: IntFilter<"EFSankeyNodes"> | number
    node?: IntNullableFilter<"EFSankeyNodes"> | number | null
    name?: StringNullableFilter<"EFSankeyNodes"> | string | null
    value?: StringNullableFilter<"EFSankeyNodes"> | string | null
    unit?: StringNullableFilter<"EFSankeyNodes"> | string | null
  }

  export type EFSankeyNodesOrderByWithRelationInput = {
    id?: SortOrder
    node?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _relevance?: EFSankeyNodesOrderByRelevanceInput
  }

  export type EFSankeyNodesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EFSankeyNodesWhereInput | EFSankeyNodesWhereInput[]
    OR?: EFSankeyNodesWhereInput[]
    NOT?: EFSankeyNodesWhereInput | EFSankeyNodesWhereInput[]
    node?: IntNullableFilter<"EFSankeyNodes"> | number | null
    name?: StringNullableFilter<"EFSankeyNodes"> | string | null
    value?: StringNullableFilter<"EFSankeyNodes"> | string | null
    unit?: StringNullableFilter<"EFSankeyNodes"> | string | null
  }, "id">

  export type EFSankeyNodesOrderByWithAggregationInput = {
    id?: SortOrder
    node?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: EFSankeyNodesCountOrderByAggregateInput
    _avg?: EFSankeyNodesAvgOrderByAggregateInput
    _max?: EFSankeyNodesMaxOrderByAggregateInput
    _min?: EFSankeyNodesMinOrderByAggregateInput
    _sum?: EFSankeyNodesSumOrderByAggregateInput
  }

  export type EFSankeyNodesScalarWhereWithAggregatesInput = {
    AND?: EFSankeyNodesScalarWhereWithAggregatesInput | EFSankeyNodesScalarWhereWithAggregatesInput[]
    OR?: EFSankeyNodesScalarWhereWithAggregatesInput[]
    NOT?: EFSankeyNodesScalarWhereWithAggregatesInput | EFSankeyNodesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EFSankeyNodes"> | number
    node?: IntNullableWithAggregatesFilter<"EFSankeyNodes"> | number | null
    name?: StringNullableWithAggregatesFilter<"EFSankeyNodes"> | string | null
    value?: StringNullableWithAggregatesFilter<"EFSankeyNodes"> | string | null
    unit?: StringNullableWithAggregatesFilter<"EFSankeyNodes"> | string | null
  }

  export type EFSummaryTableWhereInput = {
    AND?: EFSummaryTableWhereInput | EFSummaryTableWhereInput[]
    OR?: EFSummaryTableWhereInput[]
    NOT?: EFSummaryTableWhereInput | EFSummaryTableWhereInput[]
    id?: IntFilter<"EFSummaryTable"> | number
    name?: StringNullableFilter<"EFSummaryTable"> | string | null
    total?: StringNullableFilter<"EFSummaryTable"> | string | null
    percentage?: StringNullableFilter<"EFSummaryTable"> | string | null
    unit?: StringNullableFilter<"EFSummaryTable"> | string | null
  }

  export type EFSummaryTableOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _relevance?: EFSummaryTableOrderByRelevanceInput
  }

  export type EFSummaryTableWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EFSummaryTableWhereInput | EFSummaryTableWhereInput[]
    OR?: EFSummaryTableWhereInput[]
    NOT?: EFSummaryTableWhereInput | EFSummaryTableWhereInput[]
    name?: StringNullableFilter<"EFSummaryTable"> | string | null
    total?: StringNullableFilter<"EFSummaryTable"> | string | null
    percentage?: StringNullableFilter<"EFSummaryTable"> | string | null
    unit?: StringNullableFilter<"EFSummaryTable"> | string | null
  }, "id">

  export type EFSummaryTableOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    total?: SortOrderInput | SortOrder
    percentage?: SortOrderInput | SortOrder
    unit?: SortOrderInput | SortOrder
    _count?: EFSummaryTableCountOrderByAggregateInput
    _avg?: EFSummaryTableAvgOrderByAggregateInput
    _max?: EFSummaryTableMaxOrderByAggregateInput
    _min?: EFSummaryTableMinOrderByAggregateInput
    _sum?: EFSummaryTableSumOrderByAggregateInput
  }

  export type EFSummaryTableScalarWhereWithAggregatesInput = {
    AND?: EFSummaryTableScalarWhereWithAggregatesInput | EFSummaryTableScalarWhereWithAggregatesInput[]
    OR?: EFSummaryTableScalarWhereWithAggregatesInput[]
    NOT?: EFSummaryTableScalarWhereWithAggregatesInput | EFSummaryTableScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"EFSummaryTable"> | number
    name?: StringNullableWithAggregatesFilter<"EFSummaryTable"> | string | null
    total?: StringNullableWithAggregatesFilter<"EFSummaryTable"> | string | null
    percentage?: StringNullableWithAggregatesFilter<"EFSummaryTable"> | string | null
    unit?: StringNullableWithAggregatesFilter<"EFSummaryTable"> | string | null
  }

  export type SCRankingWhereInput = {
    AND?: SCRankingWhereInput | SCRankingWhereInput[]
    OR?: SCRankingWhereInput[]
    NOT?: SCRankingWhereInput | SCRankingWhereInput[]
    id?: IntFilter<"SCRanking"> | number
    supplier?: StringNullableFilter<"SCRanking"> | string | null
    emission?: StringNullableFilter<"SCRanking"> | string | null
    intensity?: StringNullableFilter<"SCRanking"> | string | null
    rank?: IntNullableFilter<"SCRanking"> | number | null
    compliance?: StringNullableFilter<"SCRanking"> | string | null
  }

  export type SCRankingOrderByWithRelationInput = {
    id?: SortOrder
    supplier?: SortOrderInput | SortOrder
    emission?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    compliance?: SortOrderInput | SortOrder
    _relevance?: SCRankingOrderByRelevanceInput
  }

  export type SCRankingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SCRankingWhereInput | SCRankingWhereInput[]
    OR?: SCRankingWhereInput[]
    NOT?: SCRankingWhereInput | SCRankingWhereInput[]
    supplier?: StringNullableFilter<"SCRanking"> | string | null
    emission?: StringNullableFilter<"SCRanking"> | string | null
    intensity?: StringNullableFilter<"SCRanking"> | string | null
    rank?: IntNullableFilter<"SCRanking"> | number | null
    compliance?: StringNullableFilter<"SCRanking"> | string | null
  }, "id">

  export type SCRankingOrderByWithAggregationInput = {
    id?: SortOrder
    supplier?: SortOrderInput | SortOrder
    emission?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    compliance?: SortOrderInput | SortOrder
    _count?: SCRankingCountOrderByAggregateInput
    _avg?: SCRankingAvgOrderByAggregateInput
    _max?: SCRankingMaxOrderByAggregateInput
    _min?: SCRankingMinOrderByAggregateInput
    _sum?: SCRankingSumOrderByAggregateInput
  }

  export type SCRankingScalarWhereWithAggregatesInput = {
    AND?: SCRankingScalarWhereWithAggregatesInput | SCRankingScalarWhereWithAggregatesInput[]
    OR?: SCRankingScalarWhereWithAggregatesInput[]
    NOT?: SCRankingScalarWhereWithAggregatesInput | SCRankingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SCRanking"> | number
    supplier?: StringNullableWithAggregatesFilter<"SCRanking"> | string | null
    emission?: StringNullableWithAggregatesFilter<"SCRanking"> | string | null
    intensity?: StringNullableWithAggregatesFilter<"SCRanking"> | string | null
    rank?: IntNullableWithAggregatesFilter<"SCRanking"> | number | null
    compliance?: StringNullableWithAggregatesFilter<"SCRanking"> | string | null
  }

  export type SCSankeyDataWhereInput = {
    AND?: SCSankeyDataWhereInput | SCSankeyDataWhereInput[]
    OR?: SCSankeyDataWhereInput[]
    NOT?: SCSankeyDataWhereInput | SCSankeyDataWhereInput[]
    id?: IntFilter<"SCSankeyData"> | number
    node?: IntNullableFilter<"SCSankeyData"> | number | null
    name?: StringNullableFilter<"SCSankeyData"> | string | null
    value?: StringNullableFilter<"SCSankeyData"> | string | null
    source?: IntNullableFilter<"SCSankeyData"> | number | null
    target?: IntNullableFilter<"SCSankeyData"> | number | null
    co2?: StringNullableFilter<"SCSankeyData"> | string | null
    type?: StringNullableFilter<"SCSankeyData"> | string | null
  }

  export type SCSankeyDataOrderByWithRelationInput = {
    id?: SortOrder
    node?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    co2?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _relevance?: SCSankeyDataOrderByRelevanceInput
  }

  export type SCSankeyDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SCSankeyDataWhereInput | SCSankeyDataWhereInput[]
    OR?: SCSankeyDataWhereInput[]
    NOT?: SCSankeyDataWhereInput | SCSankeyDataWhereInput[]
    node?: IntNullableFilter<"SCSankeyData"> | number | null
    name?: StringNullableFilter<"SCSankeyData"> | string | null
    value?: StringNullableFilter<"SCSankeyData"> | string | null
    source?: IntNullableFilter<"SCSankeyData"> | number | null
    target?: IntNullableFilter<"SCSankeyData"> | number | null
    co2?: StringNullableFilter<"SCSankeyData"> | string | null
    type?: StringNullableFilter<"SCSankeyData"> | string | null
  }, "id">

  export type SCSankeyDataOrderByWithAggregationInput = {
    id?: SortOrder
    node?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    co2?: SortOrderInput | SortOrder
    type?: SortOrderInput | SortOrder
    _count?: SCSankeyDataCountOrderByAggregateInput
    _avg?: SCSankeyDataAvgOrderByAggregateInput
    _max?: SCSankeyDataMaxOrderByAggregateInput
    _min?: SCSankeyDataMinOrderByAggregateInput
    _sum?: SCSankeyDataSumOrderByAggregateInput
  }

  export type SCSankeyDataScalarWhereWithAggregatesInput = {
    AND?: SCSankeyDataScalarWhereWithAggregatesInput | SCSankeyDataScalarWhereWithAggregatesInput[]
    OR?: SCSankeyDataScalarWhereWithAggregatesInput[]
    NOT?: SCSankeyDataScalarWhereWithAggregatesInput | SCSankeyDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SCSankeyData"> | number
    node?: IntNullableWithAggregatesFilter<"SCSankeyData"> | number | null
    name?: StringNullableWithAggregatesFilter<"SCSankeyData"> | string | null
    value?: StringNullableWithAggregatesFilter<"SCSankeyData"> | string | null
    source?: IntNullableWithAggregatesFilter<"SCSankeyData"> | number | null
    target?: IntNullableWithAggregatesFilter<"SCSankeyData"> | number | null
    co2?: StringNullableWithAggregatesFilter<"SCSankeyData"> | string | null
    type?: StringNullableWithAggregatesFilter<"SCSankeyData"> | string | null
  }

  export type receiptfcWhereInput = {
    AND?: receiptfcWhereInput | receiptfcWhereInput[]
    OR?: receiptfcWhereInput[]
    NOT?: receiptfcWhereInput | receiptfcWhereInput[]
    id?: IntFilter<"receiptfc"> | number
    saleMemberId?: StringNullableFilter<"receiptfc"> | string | null
    saleMemberName?: StringNullableFilter<"receiptfc"> | string | null
    taxInclu?: DecimalNullableFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: DecimalNullableFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: StringNullableFilter<"receiptfc"> | string | null
    imgUrls?: StringNullableFilter<"receiptfc"> | string | null
    weight?: DecimalNullableFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    orderTime?: DateTimeNullableFilter<"receiptfc"> | Date | string | null
    carNumber?: StringNullableFilter<"receiptfc"> | string | null
    carBrand?: StringNullableFilter<"receiptfc"> | string | null
    createTime?: DateTimeNullableFilter<"receiptfc"> | Date | string | null
    queryDate?: DateTimeNullableFilter<"receiptfc"> | Date | string | null
  }

  export type receiptfcOrderByWithRelationInput = {
    id?: SortOrder
    saleMemberId?: SortOrderInput | SortOrder
    saleMemberName?: SortOrderInput | SortOrder
    taxInclu?: SortOrderInput | SortOrder
    unitpriceIncluTax?: SortOrderInput | SortOrder
    wasteTypeName?: SortOrderInput | SortOrder
    imgUrls?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    orderTime?: SortOrderInput | SortOrder
    carNumber?: SortOrderInput | SortOrder
    carBrand?: SortOrderInput | SortOrder
    createTime?: SortOrderInput | SortOrder
    queryDate?: SortOrderInput | SortOrder
    _relevance?: receiptfcOrderByRelevanceInput
  }

  export type receiptfcWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: receiptfcWhereInput | receiptfcWhereInput[]
    OR?: receiptfcWhereInput[]
    NOT?: receiptfcWhereInput | receiptfcWhereInput[]
    saleMemberId?: StringNullableFilter<"receiptfc"> | string | null
    saleMemberName?: StringNullableFilter<"receiptfc"> | string | null
    taxInclu?: DecimalNullableFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: DecimalNullableFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: StringNullableFilter<"receiptfc"> | string | null
    imgUrls?: StringNullableFilter<"receiptfc"> | string | null
    weight?: DecimalNullableFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    orderTime?: DateTimeNullableFilter<"receiptfc"> | Date | string | null
    carNumber?: StringNullableFilter<"receiptfc"> | string | null
    carBrand?: StringNullableFilter<"receiptfc"> | string | null
    createTime?: DateTimeNullableFilter<"receiptfc"> | Date | string | null
    queryDate?: DateTimeNullableFilter<"receiptfc"> | Date | string | null
  }, "id">

  export type receiptfcOrderByWithAggregationInput = {
    id?: SortOrder
    saleMemberId?: SortOrderInput | SortOrder
    saleMemberName?: SortOrderInput | SortOrder
    taxInclu?: SortOrderInput | SortOrder
    unitpriceIncluTax?: SortOrderInput | SortOrder
    wasteTypeName?: SortOrderInput | SortOrder
    imgUrls?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    orderTime?: SortOrderInput | SortOrder
    carNumber?: SortOrderInput | SortOrder
    carBrand?: SortOrderInput | SortOrder
    createTime?: SortOrderInput | SortOrder
    queryDate?: SortOrderInput | SortOrder
    _count?: receiptfcCountOrderByAggregateInput
    _avg?: receiptfcAvgOrderByAggregateInput
    _max?: receiptfcMaxOrderByAggregateInput
    _min?: receiptfcMinOrderByAggregateInput
    _sum?: receiptfcSumOrderByAggregateInput
  }

  export type receiptfcScalarWhereWithAggregatesInput = {
    AND?: receiptfcScalarWhereWithAggregatesInput | receiptfcScalarWhereWithAggregatesInput[]
    OR?: receiptfcScalarWhereWithAggregatesInput[]
    NOT?: receiptfcScalarWhereWithAggregatesInput | receiptfcScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"receiptfc"> | number
    saleMemberId?: StringNullableWithAggregatesFilter<"receiptfc"> | string | null
    saleMemberName?: StringNullableWithAggregatesFilter<"receiptfc"> | string | null
    taxInclu?: DecimalNullableWithAggregatesFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: DecimalNullableWithAggregatesFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: StringNullableWithAggregatesFilter<"receiptfc"> | string | null
    imgUrls?: StringNullableWithAggregatesFilter<"receiptfc"> | string | null
    weight?: DecimalNullableWithAggregatesFilter<"receiptfc"> | Decimal | DecimalJsLike | number | string | null
    orderTime?: DateTimeNullableWithAggregatesFilter<"receiptfc"> | Date | string | null
    carNumber?: StringNullableWithAggregatesFilter<"receiptfc"> | string | null
    carBrand?: StringNullableWithAggregatesFilter<"receiptfc"> | string | null
    createTime?: DateTimeNullableWithAggregatesFilter<"receiptfc"> | Date | string | null
    queryDate?: DateTimeNullableWithAggregatesFilter<"receiptfc"> | Date | string | null
  }

  export type receiptfgWhereInput = {
    AND?: receiptfgWhereInput | receiptfgWhereInput[]
    OR?: receiptfgWhereInput[]
    NOT?: receiptfgWhereInput | receiptfgWhereInput[]
    id?: IntFilter<"receiptfg"> | number
    saleMemberId?: StringNullableFilter<"receiptfg"> | string | null
    saleMemberName?: StringNullableFilter<"receiptfg"> | string | null
    taxInclu?: DecimalNullableFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: DecimalNullableFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: StringNullableFilter<"receiptfg"> | string | null
    imgUrls?: StringNullableFilter<"receiptfg"> | string | null
    weight?: DecimalNullableFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    orderTime?: DateTimeNullableFilter<"receiptfg"> | Date | string | null
    carNumber?: StringNullableFilter<"receiptfg"> | string | null
    carBrand?: StringNullableFilter<"receiptfg"> | string | null
    createTime?: DateTimeNullableFilter<"receiptfg"> | Date | string | null
    queryDate?: DateTimeNullableFilter<"receiptfg"> | Date | string | null
  }

  export type receiptfgOrderByWithRelationInput = {
    id?: SortOrder
    saleMemberId?: SortOrderInput | SortOrder
    saleMemberName?: SortOrderInput | SortOrder
    taxInclu?: SortOrderInput | SortOrder
    unitpriceIncluTax?: SortOrderInput | SortOrder
    wasteTypeName?: SortOrderInput | SortOrder
    imgUrls?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    orderTime?: SortOrderInput | SortOrder
    carNumber?: SortOrderInput | SortOrder
    carBrand?: SortOrderInput | SortOrder
    createTime?: SortOrderInput | SortOrder
    queryDate?: SortOrderInput | SortOrder
    _relevance?: receiptfgOrderByRelevanceInput
  }

  export type receiptfgWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: receiptfgWhereInput | receiptfgWhereInput[]
    OR?: receiptfgWhereInput[]
    NOT?: receiptfgWhereInput | receiptfgWhereInput[]
    saleMemberId?: StringNullableFilter<"receiptfg"> | string | null
    saleMemberName?: StringNullableFilter<"receiptfg"> | string | null
    taxInclu?: DecimalNullableFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: DecimalNullableFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: StringNullableFilter<"receiptfg"> | string | null
    imgUrls?: StringNullableFilter<"receiptfg"> | string | null
    weight?: DecimalNullableFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    orderTime?: DateTimeNullableFilter<"receiptfg"> | Date | string | null
    carNumber?: StringNullableFilter<"receiptfg"> | string | null
    carBrand?: StringNullableFilter<"receiptfg"> | string | null
    createTime?: DateTimeNullableFilter<"receiptfg"> | Date | string | null
    queryDate?: DateTimeNullableFilter<"receiptfg"> | Date | string | null
  }, "id">

  export type receiptfgOrderByWithAggregationInput = {
    id?: SortOrder
    saleMemberId?: SortOrderInput | SortOrder
    saleMemberName?: SortOrderInput | SortOrder
    taxInclu?: SortOrderInput | SortOrder
    unitpriceIncluTax?: SortOrderInput | SortOrder
    wasteTypeName?: SortOrderInput | SortOrder
    imgUrls?: SortOrderInput | SortOrder
    weight?: SortOrderInput | SortOrder
    orderTime?: SortOrderInput | SortOrder
    carNumber?: SortOrderInput | SortOrder
    carBrand?: SortOrderInput | SortOrder
    createTime?: SortOrderInput | SortOrder
    queryDate?: SortOrderInput | SortOrder
    _count?: receiptfgCountOrderByAggregateInput
    _avg?: receiptfgAvgOrderByAggregateInput
    _max?: receiptfgMaxOrderByAggregateInput
    _min?: receiptfgMinOrderByAggregateInput
    _sum?: receiptfgSumOrderByAggregateInput
  }

  export type receiptfgScalarWhereWithAggregatesInput = {
    AND?: receiptfgScalarWhereWithAggregatesInput | receiptfgScalarWhereWithAggregatesInput[]
    OR?: receiptfgScalarWhereWithAggregatesInput[]
    NOT?: receiptfgScalarWhereWithAggregatesInput | receiptfgScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"receiptfg"> | number
    saleMemberId?: StringNullableWithAggregatesFilter<"receiptfg"> | string | null
    saleMemberName?: StringNullableWithAggregatesFilter<"receiptfg"> | string | null
    taxInclu?: DecimalNullableWithAggregatesFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: DecimalNullableWithAggregatesFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: StringNullableWithAggregatesFilter<"receiptfg"> | string | null
    imgUrls?: StringNullableWithAggregatesFilter<"receiptfg"> | string | null
    weight?: DecimalNullableWithAggregatesFilter<"receiptfg"> | Decimal | DecimalJsLike | number | string | null
    orderTime?: DateTimeNullableWithAggregatesFilter<"receiptfg"> | Date | string | null
    carNumber?: StringNullableWithAggregatesFilter<"receiptfg"> | string | null
    carBrand?: StringNullableWithAggregatesFilter<"receiptfg"> | string | null
    createTime?: DateTimeNullableWithAggregatesFilter<"receiptfg"> | Date | string | null
    queryDate?: DateTimeNullableWithAggregatesFilter<"receiptfg"> | Date | string | null
  }

  export type CAHoldingsCreateInput = {
    asset?: string | null
    quantity?: string | null
    value?: string | null
    status?: string | null
  }

  export type CAHoldingsUncheckedCreateInput = {
    id?: number
    asset?: string | null
    quantity?: string | null
    value?: string | null
    status?: string | null
  }

  export type CAHoldingsUpdateInput = {
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAHoldingsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAHoldingsCreateManyInput = {
    id?: number
    asset?: string | null
    quantity?: string | null
    value?: string | null
    status?: string | null
  }

  export type CAHoldingsUpdateManyMutationInput = {
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAHoldingsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    asset?: NullableStringFieldUpdateOperationsInput | string | null
    quantity?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAMarketCardsCreateInput = {
    price?: string | null
    volume?: string | null
    change?: string | null
    unit?: string | null
  }

  export type CAMarketCardsUncheckedCreateInput = {
    id?: number
    price?: string | null
    volume?: string | null
    change?: string | null
    unit?: string | null
  }

  export type CAMarketCardsUpdateInput = {
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAMarketCardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAMarketCardsCreateManyInput = {
    id?: number
    price?: string | null
    volume?: string | null
    change?: string | null
    unit?: string | null
  }

  export type CAMarketCardsUpdateManyMutationInput = {
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAMarketCardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
    change?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPieChartCreateInput = {
    type?: string | null
    value?: string | null
    percentage?: string | null
  }

  export type CAPieChartUncheckedCreateInput = {
    id?: number
    type?: string | null
    value?: string | null
    percentage?: string | null
  }

  export type CAPieChartUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPieChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPieChartCreateManyInput = {
    id?: number
    type?: string | null
    value?: string | null
    percentage?: string | null
  }

  export type CAPieChartUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPieChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPriceChartCreateInput = {
    date?: string | null
    price?: string | null
    volume?: string | null
  }

  export type CAPriceChartUncheckedCreateInput = {
    id?: number
    date?: string | null
    price?: string | null
    volume?: string | null
  }

  export type CAPriceChartUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPriceChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPriceChartCreateManyInput = {
    id?: number
    date?: string | null
    price?: string | null
    volume?: string | null
  }

  export type CAPriceChartUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CAPriceChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableStringFieldUpdateOperationsInput | string | null
    volume?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBComparisonChartCreateInput = {
    month?: string | null
    actual?: string | null
    budget?: string | null
  }

  export type CBComparisonChartUncheckedCreateInput = {
    id?: number
    month?: string | null
    actual?: string | null
    budget?: string | null
  }

  export type CBComparisonChartUpdateInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBComparisonChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBComparisonChartCreateManyInput = {
    id?: number
    month?: string | null
    actual?: string | null
    budget?: string | null
  }

  export type CBComparisonChartUpdateManyMutationInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBComparisonChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBMonthlyDetailsCreateInput = {
    month?: string | null
    energy_budget?: string | null
    actual?: string | null
    variance?: string | null
    status?: string | null
  }

  export type CBMonthlyDetailsUncheckedCreateInput = {
    id?: number
    month?: string | null
    energy_budget?: string | null
    actual?: string | null
    variance?: string | null
    status?: string | null
  }

  export type CBMonthlyDetailsUpdateInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    energy_budget?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    variance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBMonthlyDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    energy_budget?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    variance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBMonthlyDetailsCreateManyInput = {
    id?: number
    month?: string | null
    energy_budget?: string | null
    actual?: string | null
    variance?: string | null
    status?: string | null
  }

  export type CBMonthlyDetailsUpdateManyMutationInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    energy_budget?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    variance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBMonthlyDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    energy_budget?: NullableStringFieldUpdateOperationsInput | string | null
    actual?: NullableStringFieldUpdateOperationsInput | string | null
    variance?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBSummaryCardsCreateInput = {
    total_energy?: string | null
    used?: string | null
    remaining?: string | null
    overrun_rate?: string | null
    unit?: string | null
  }

  export type CBSummaryCardsUncheckedCreateInput = {
    id?: number
    total_energy?: string | null
    used?: string | null
    remaining?: string | null
    overrun_rate?: string | null
    unit?: string | null
  }

  export type CBSummaryCardsUpdateInput = {
    total_energy?: NullableStringFieldUpdateOperationsInput | string | null
    used?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableStringFieldUpdateOperationsInput | string | null
    overrun_rate?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBSummaryCardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_energy?: NullableStringFieldUpdateOperationsInput | string | null
    used?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableStringFieldUpdateOperationsInput | string | null
    overrun_rate?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBSummaryCardsCreateManyInput = {
    id?: number
    total_energy?: string | null
    used?: string | null
    remaining?: string | null
    overrun_rate?: string | null
    unit?: string | null
  }

  export type CBSummaryCardsUpdateManyMutationInput = {
    total_energy?: NullableStringFieldUpdateOperationsInput | string | null
    used?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableStringFieldUpdateOperationsInput | string | null
    overrun_rate?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CBSummaryCardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    total_energy?: NullableStringFieldUpdateOperationsInput | string | null
    used?: NullableStringFieldUpdateOperationsInput | string | null
    remaining?: NullableStringFieldUpdateOperationsInput | string | null
    overrun_rate?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFDetailsCreateInput = {
    process?: string | null
    scope?: string | null
    emission?: Decimal | DecimalJsLike | number | string | null
    factor?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsUncheckedCreateInput = {
    id?: number
    process?: string | null
    scope?: string | null
    emission?: Decimal | DecimalJsLike | number | string | null
    factor?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsUpdateInput = {
    process?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    process?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsCreateManyInput = {
    id?: number
    process?: string | null
    scope?: string | null
    emission?: Decimal | DecimalJsLike | number | string | null
    factor?: Decimal | DecimalJsLike | number | string | null
    total?: Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsUpdateManyMutationInput = {
    process?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    process?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    factor?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type CFPieChartCreateInput = {
    scope?: string | null
    value?: string | null
    percentage?: string | null
  }

  export type CFPieChartUncheckedCreateInput = {
    id?: number
    scope?: string | null
    value?: string | null
    percentage?: string | null
  }

  export type CFPieChartUpdateInput = {
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFPieChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFPieChartCreateManyInput = {
    id?: number
    scope?: string | null
    value?: string | null
    percentage?: string | null
  }

  export type CFPieChartUpdateManyMutationInput = {
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFPieChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFTrendChartCreateInput = {
    month?: string | null
    footprint?: string | null
    scope1?: string | null
    scope2?: string | null
    scope3?: string | null
  }

  export type CFTrendChartUncheckedCreateInput = {
    id?: number
    month?: string | null
    footprint?: string | null
    scope1?: string | null
    scope2?: string | null
    scope3?: string | null
  }

  export type CFTrendChartUpdateInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    footprint?: NullableStringFieldUpdateOperationsInput | string | null
    scope1?: NullableStringFieldUpdateOperationsInput | string | null
    scope2?: NullableStringFieldUpdateOperationsInput | string | null
    scope3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFTrendChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    footprint?: NullableStringFieldUpdateOperationsInput | string | null
    scope1?: NullableStringFieldUpdateOperationsInput | string | null
    scope2?: NullableStringFieldUpdateOperationsInput | string | null
    scope3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFTrendChartCreateManyInput = {
    id?: number
    month?: string | null
    footprint?: string | null
    scope1?: string | null
    scope2?: string | null
    scope3?: string | null
  }

  export type CFTrendChartUpdateManyMutationInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    footprint?: NullableStringFieldUpdateOperationsInput | string | null
    scope1?: NullableStringFieldUpdateOperationsInput | string | null
    scope2?: NullableStringFieldUpdateOperationsInput | string | null
    scope3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type CFTrendChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    footprint?: NullableStringFieldUpdateOperationsInput | string | null
    scope1?: NullableStringFieldUpdateOperationsInput | string | null
    scope2?: NullableStringFieldUpdateOperationsInput | string | null
    scope3?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EAConsumptionTrendCreateInput = {
    date?: string | null
    total?: Decimal | DecimalJsLike | number | string | null
    upstream?: Decimal | DecimalJsLike | number | string | null
    downstream?: Decimal | DecimalJsLike | number | string | null
    forecast?: Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendUncheckedCreateInput = {
    id?: number
    date?: string | null
    total?: Decimal | DecimalJsLike | number | string | null
    upstream?: Decimal | DecimalJsLike | number | string | null
    downstream?: Decimal | DecimalJsLike | number | string | null
    forecast?: Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendUpdateInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    downstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    downstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendCreateManyInput = {
    id?: number
    date?: string | null
    total?: Decimal | DecimalJsLike | number | string | null
    upstream?: Decimal | DecimalJsLike | number | string | null
    downstream?: Decimal | DecimalJsLike | number | string | null
    forecast?: Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendUpdateManyMutationInput = {
    date?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    downstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAConsumptionTrendUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    date?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    downstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryCreateInput = {
    month?: string | null
    total?: Decimal | DecimalJsLike | number | string | null
    upstream?: Decimal | DecimalJsLike | number | string | null
    growth_rate?: Decimal | DecimalJsLike | number | string | null
    forecast_growth?: Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryUncheckedCreateInput = {
    id?: number
    month?: string | null
    total?: Decimal | DecimalJsLike | number | string | null
    upstream?: Decimal | DecimalJsLike | number | string | null
    growth_rate?: Decimal | DecimalJsLike | number | string | null
    forecast_growth?: Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryUpdateInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    growth_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    growth_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryCreateManyInput = {
    id?: number
    month?: string | null
    total?: Decimal | DecimalJsLike | number | string | null
    upstream?: Decimal | DecimalJsLike | number | string | null
    growth_rate?: Decimal | DecimalJsLike | number | string | null
    forecast_growth?: Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryUpdateManyMutationInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    growth_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAMonthSummaryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    upstream?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    growth_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    forecast_growth?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EAStrategyCreateInput = {
    title?: string | null
    description?: string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: string | null
  }

  export type EAStrategyUncheckedCreateInput = {
    id?: number
    title?: string | null
    description?: string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: string | null
  }

  export type EAStrategyUpdateInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EAStrategyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EAStrategyCreateManyInput = {
    id?: number
    title?: string | null
    description?: string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: string | null
  }

  export type EAStrategyUpdateManyMutationInput = {
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EAStrategyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    impact?: NullableJsonNullValueInput | InputJsonValue
    action?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EATypeComparisonCreateInput = {
    month?: string | null
    coal?: Decimal | DecimalJsLike | number | string | null
    gas?: Decimal | DecimalJsLike | number | string | null
    electric?: Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonUncheckedCreateInput = {
    id?: number
    month?: string | null
    coal?: Decimal | DecimalJsLike | number | string | null
    gas?: Decimal | DecimalJsLike | number | string | null
    electric?: Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonUpdateInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    coal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    electric?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    coal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    electric?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonCreateManyInput = {
    id?: number
    month?: string | null
    coal?: Decimal | DecimalJsLike | number | string | null
    gas?: Decimal | DecimalJsLike | number | string | null
    electric?: Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonUpdateManyMutationInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    coal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    electric?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EATypeComparisonUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    coal?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    gas?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    electric?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
  }

  export type EBParamCardsCreateInput = {
    key?: string | null
    value?: string | null
    unit?: string | null
    trend?: string | null
  }

  export type EBParamCardsUncheckedCreateInput = {
    id?: number
    key?: string | null
    value?: string | null
    unit?: string | null
    trend?: string | null
  }

  export type EBParamCardsUpdateInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBParamCardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBParamCardsCreateManyInput = {
    id?: number
    key?: string | null
    value?: string | null
    unit?: string | null
    trend?: string | null
  }

  export type EBParamCardsUpdateManyMutationInput = {
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBParamCardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    key?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBPieChartCreateInput = {
    type?: string | null
    value?: string | null
    color?: string | null
  }

  export type EBPieChartUncheckedCreateInput = {
    id?: number
    type?: string | null
    value?: string | null
    color?: string | null
  }

  export type EBPieChartUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBPieChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBPieChartCreateManyInput = {
    id?: number
    type?: string | null
    value?: string | null
    color?: string | null
  }

  export type EBPieChartUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBPieChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBResultsCreateInput = {
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: string | null
  }

  export type EBResultsUncheckedCreateInput = {
    id?: number
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: string | null
  }

  export type EBResultsUpdateInput = {
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBResultsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBResultsCreateManyInput = {
    id?: number
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: string | null
  }

  export type EBResultsUpdateManyMutationInput = {
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBResultsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    before?: NullableJsonNullValueInput | InputJsonValue
    after?: NullableJsonNullValueInput | InputJsonValue
    savings?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBTrendChartCreateInput = {
    time?: string | null
    generation?: string | null
    consumption?: string | null
  }

  export type EBTrendChartUncheckedCreateInput = {
    id?: number
    time?: string | null
    generation?: string | null
    consumption?: string | null
  }

  export type EBTrendChartUpdateInput = {
    time?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBTrendChartUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBTrendChartCreateManyInput = {
    id?: number
    time?: string | null
    generation?: string | null
    consumption?: string | null
  }

  export type EBTrendChartUpdateManyMutationInput = {
    time?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EBTrendChartUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    time?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyFlowRealTimeCreateInput = {
    device_id?: number | null
    energy_type_id?: string | null
    flow_value?: string | null
    temperature?: string | null
    pressure?: string | null
    timestamp?: string | null
  }

  export type ECenergyFlowRealTimeUncheckedCreateInput = {
    id?: number
    device_id?: number | null
    energy_type_id?: string | null
    flow_value?: string | null
    temperature?: string | null
    pressure?: string | null
    timestamp?: string | null
  }

  export type ECenergyFlowRealTimeUpdateInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    flow_value?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pressure?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyFlowRealTimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    flow_value?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pressure?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyFlowRealTimeCreateManyInput = {
    id?: number
    device_id?: number | null
    energy_type_id?: string | null
    flow_value?: string | null
    temperature?: string | null
    pressure?: string | null
    timestamp?: string | null
  }

  export type ECenergyFlowRealTimeUpdateManyMutationInput = {
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    flow_value?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pressure?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyFlowRealTimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    device_id?: NullableIntFieldUpdateOperationsInput | number | null
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    flow_value?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableStringFieldUpdateOperationsInput | string | null
    pressure?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyTypesCreateInput = {
    type?: string | null
    name?: string | null
    unit?: string | null
    icon?: string | null
    conversion_factor?: string | null
    created_at?: string | null
  }

  export type ECenergyTypesUncheckedCreateInput = {
    id?: number
    type?: string | null
    name?: string | null
    unit?: string | null
    icon?: string | null
    conversion_factor?: string | null
    created_at?: string | null
  }

  export type ECenergyTypesUpdateInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_factor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyTypesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_factor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyTypesCreateManyInput = {
    id?: number
    type?: string | null
    name?: string | null
    unit?: string | null
    icon?: string | null
    conversion_factor?: string | null
    created_at?: string | null
  }

  export type ECenergyTypesUpdateManyMutationInput = {
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_factor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECenergyTypesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    conversion_factor?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EChistoryCreateInput = {
    energy_type_id?: string | null
    date_time?: Date | string | null
    consumption?: string | null
    generation?: string | null
    status?: string | null
  }

  export type EChistoryUncheckedCreateInput = {
    id?: number
    energy_type_id?: string | null
    date_time?: Date | string | null
    consumption?: string | null
    generation?: string | null
    status?: string | null
  }

  export type EChistoryUpdateInput = {
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EChistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EChistoryCreateManyInput = {
    id?: number
    energy_type_id?: string | null
    date_time?: Date | string | null
    consumption?: string | null
    generation?: string | null
    status?: string | null
  }

  export type EChistoryUpdateManyMutationInput = {
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EChistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    date_time?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    consumption?: NullableStringFieldUpdateOperationsInput | string | null
    generation?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECrealTimeCreateInput = {
    energy_type_id?: string | null
    current_value?: string | null
    total_value?: string | null
    unit?: string | null
    timestamp?: string | null
    status?: string | null
  }

  export type ECrealTimeUncheckedCreateInput = {
    id?: number
    energy_type_id?: string | null
    current_value?: string | null
    total_value?: string | null
    unit?: string | null
    timestamp?: string | null
    status?: string | null
  }

  export type ECrealTimeUpdateInput = {
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_value?: NullableStringFieldUpdateOperationsInput | string | null
    total_value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECrealTimeUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_value?: NullableStringFieldUpdateOperationsInput | string | null
    total_value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECrealTimeCreateManyInput = {
    id?: number
    energy_type_id?: string | null
    current_value?: string | null
    total_value?: string | null
    unit?: string | null
    timestamp?: string | null
    status?: string | null
  }

  export type ECrealTimeUpdateManyMutationInput = {
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_value?: NullableStringFieldUpdateOperationsInput | string | null
    total_value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ECrealTimeUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy_type_id?: NullableStringFieldUpdateOperationsInput | string | null
    current_value?: NullableStringFieldUpdateOperationsInput | string | null
    total_value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    timestamp?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEBenchmarkRankCardsCreateInput = {
    rank?: number | null
    name?: string | null
    efficiency?: string | null
    unit?: string | null
    trend?: string | null
  }

  export type EEBenchmarkRankCardsUncheckedCreateInput = {
    id?: number
    rank?: number | null
    name?: string | null
    efficiency?: string | null
    unit?: string | null
    trend?: string | null
  }

  export type EEBenchmarkRankCardsUpdateInput = {
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEBenchmarkRankCardsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEBenchmarkRankCardsCreateManyInput = {
    id?: number
    rank?: number | null
    name?: string | null
    efficiency?: string | null
    unit?: string | null
    trend?: string | null
  }

  export type EEBenchmarkRankCardsUpdateManyMutationInput = {
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEBenchmarkRankCardsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
    trend?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEGaugeMetricsCreateInput = {
    current?: string | null
    target?: string | null
    label?: string | null
  }

  export type EEGaugeMetricsUncheckedCreateInput = {
    id?: number
    current?: string | null
    target?: string | null
    label?: string | null
  }

  export type EEGaugeMetricsUpdateInput = {
    current?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEGaugeMetricsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    current?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEGaugeMetricsCreateManyInput = {
    id?: number
    current?: string | null
    target?: string | null
    label?: string | null
  }

  export type EEGaugeMetricsUpdateManyMutationInput = {
    current?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EEGaugeMetricsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    current?: NullableStringFieldUpdateOperationsInput | string | null
    target?: NullableStringFieldUpdateOperationsInput | string | null
    label?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EERankingListCreateInput = {
    enterprise?: string | null
    rank?: number | null
    efficiency?: string | null
    benchmark?: string | null
    delta?: string | null
    status?: string | null
  }

  export type EERankingListUncheckedCreateInput = {
    id?: number
    enterprise?: string | null
    rank?: number | null
    efficiency?: string | null
    benchmark?: string | null
    delta?: string | null
    status?: string | null
  }

  export type EERankingListUpdateInput = {
    enterprise?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    delta?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EERankingListUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    enterprise?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    delta?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EERankingListCreateManyInput = {
    id?: number
    enterprise?: string | null
    rank?: number | null
    efficiency?: string | null
    benchmark?: string | null
    delta?: string | null
    status?: string | null
  }

  export type EERankingListUpdateManyMutationInput = {
    enterprise?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    delta?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EERankingListUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    enterprise?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    efficiency?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
    delta?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EETrendChartDataCreateInput = {
    month?: string | null
    value?: string | null
    benchmark?: string | null
  }

  export type EETrendChartDataUncheckedCreateInput = {
    id?: number
    month?: string | null
    value?: string | null
    benchmark?: string | null
  }

  export type EETrendChartDataUpdateInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EETrendChartDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EETrendChartDataCreateManyInput = {
    id?: number
    month?: string | null
    value?: string | null
    benchmark?: string | null
  }

  export type EETrendChartDataUpdateManyMutationInput = {
    month?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EETrendChartDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    month?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    benchmark?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyLinksCreateInput = {
    source?: number | null
    target?: number | null
    value?: string | null
    type?: string | null
  }

  export type EFSankeyLinksUncheckedCreateInput = {
    id?: number
    source?: number | null
    target?: number | null
    value?: string | null
    type?: string | null
  }

  export type EFSankeyLinksUpdateInput = {
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyLinksUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyLinksCreateManyInput = {
    id?: number
    source?: number | null
    target?: number | null
    value?: string | null
    type?: string | null
  }

  export type EFSankeyLinksUpdateManyMutationInput = {
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyLinksUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyNodesCreateInput = {
    node?: number | null
    name?: string | null
    value?: string | null
    unit?: string | null
  }

  export type EFSankeyNodesUncheckedCreateInput = {
    id?: number
    node?: number | null
    name?: string | null
    value?: string | null
    unit?: string | null
  }

  export type EFSankeyNodesUpdateInput = {
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyNodesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyNodesCreateManyInput = {
    id?: number
    node?: number | null
    name?: string | null
    value?: string | null
    unit?: string | null
  }

  export type EFSankeyNodesUpdateManyMutationInput = {
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSankeyNodesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSummaryTableCreateInput = {
    name?: string | null
    total?: string | null
    percentage?: string | null
    unit?: string | null
  }

  export type EFSummaryTableUncheckedCreateInput = {
    id?: number
    name?: string | null
    total?: string | null
    percentage?: string | null
    unit?: string | null
  }

  export type EFSummaryTableUpdateInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSummaryTableUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSummaryTableCreateManyInput = {
    id?: number
    name?: string | null
    total?: string | null
    percentage?: string | null
    unit?: string | null
  }

  export type EFSummaryTableUpdateManyMutationInput = {
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EFSummaryTableUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: NullableStringFieldUpdateOperationsInput | string | null
    total?: NullableStringFieldUpdateOperationsInput | string | null
    percentage?: NullableStringFieldUpdateOperationsInput | string | null
    unit?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCRankingCreateInput = {
    supplier?: string | null
    emission?: string | null
    intensity?: string | null
    rank?: number | null
    compliance?: string | null
  }

  export type SCRankingUncheckedCreateInput = {
    id?: number
    supplier?: string | null
    emission?: string | null
    intensity?: string | null
    rank?: number | null
    compliance?: string | null
  }

  export type SCRankingUpdateInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    compliance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCRankingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    compliance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCRankingCreateManyInput = {
    id?: number
    supplier?: string | null
    emission?: string | null
    intensity?: string | null
    rank?: number | null
    compliance?: string | null
  }

  export type SCRankingUpdateManyMutationInput = {
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    compliance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCRankingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    supplier?: NullableStringFieldUpdateOperationsInput | string | null
    emission?: NullableStringFieldUpdateOperationsInput | string | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    compliance?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCSankeyDataCreateInput = {
    node?: number | null
    name?: string | null
    value?: string | null
    source?: number | null
    target?: number | null
    co2?: string | null
    type?: string | null
  }

  export type SCSankeyDataUncheckedCreateInput = {
    id?: number
    node?: number | null
    name?: string | null
    value?: string | null
    source?: number | null
    target?: number | null
    co2?: string | null
    type?: string | null
  }

  export type SCSankeyDataUpdateInput = {
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    co2?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCSankeyDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    co2?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCSankeyDataCreateManyInput = {
    id?: number
    node?: number | null
    name?: string | null
    value?: string | null
    source?: number | null
    target?: number | null
    co2?: string | null
    type?: string | null
  }

  export type SCSankeyDataUpdateManyMutationInput = {
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    co2?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SCSankeyDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    node?: NullableIntFieldUpdateOperationsInput | number | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    co2?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type receiptfcCreateInput = {
    saleMemberId?: string | null
    saleMemberName?: string | null
    taxInclu?: Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: string | null
    imgUrls?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    orderTime?: Date | string | null
    carNumber?: string | null
    carBrand?: string | null
    createTime?: Date | string | null
    queryDate?: Date | string | null
  }

  export type receiptfcUncheckedCreateInput = {
    id?: number
    saleMemberId?: string | null
    saleMemberName?: string | null
    taxInclu?: Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: string | null
    imgUrls?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    orderTime?: Date | string | null
    carNumber?: string | null
    carBrand?: string | null
    createTime?: Date | string | null
    queryDate?: Date | string | null
  }

  export type receiptfcUpdateInput = {
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfcUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfcCreateManyInput = {
    id?: number
    saleMemberId?: string | null
    saleMemberName?: string | null
    taxInclu?: Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: string | null
    imgUrls?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    orderTime?: Date | string | null
    carNumber?: string | null
    carBrand?: string | null
    createTime?: Date | string | null
    queryDate?: Date | string | null
  }

  export type receiptfcUpdateManyMutationInput = {
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfcUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfgCreateInput = {
    saleMemberId?: string | null
    saleMemberName?: string | null
    taxInclu?: Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: string | null
    imgUrls?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    orderTime?: Date | string | null
    carNumber?: string | null
    carBrand?: string | null
    createTime?: Date | string | null
    queryDate?: Date | string | null
  }

  export type receiptfgUncheckedCreateInput = {
    id?: number
    saleMemberId?: string | null
    saleMemberName?: string | null
    taxInclu?: Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: string | null
    imgUrls?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    orderTime?: Date | string | null
    carNumber?: string | null
    carBrand?: string | null
    createTime?: Date | string | null
    queryDate?: Date | string | null
  }

  export type receiptfgUpdateInput = {
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfgUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfgCreateManyInput = {
    id?: number
    saleMemberId?: string | null
    saleMemberName?: string | null
    taxInclu?: Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: string | null
    imgUrls?: string | null
    weight?: Decimal | DecimalJsLike | number | string | null
    orderTime?: Date | string | null
    carNumber?: string | null
    carBrand?: string | null
    createTime?: Date | string | null
    queryDate?: Date | string | null
  }

  export type receiptfgUpdateManyMutationInput = {
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type receiptfgUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saleMemberId?: NullableStringFieldUpdateOperationsInput | string | null
    saleMemberName?: NullableStringFieldUpdateOperationsInput | string | null
    taxInclu?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    unitpriceIncluTax?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    wasteTypeName?: NullableStringFieldUpdateOperationsInput | string | null
    imgUrls?: NullableStringFieldUpdateOperationsInput | string | null
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    orderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    carNumber?: NullableStringFieldUpdateOperationsInput | string | null
    carBrand?: NullableStringFieldUpdateOperationsInput | string | null
    createTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    queryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type CAHoldingsOrderByRelevanceInput = {
    fields: CAHoldingsOrderByRelevanceFieldEnum | CAHoldingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CAHoldingsCountOrderByAggregateInput = {
    id?: SortOrder
    asset?: SortOrder
    quantity?: SortOrder
    value?: SortOrder
    status?: SortOrder
  }

  export type CAHoldingsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CAHoldingsMaxOrderByAggregateInput = {
    id?: SortOrder
    asset?: SortOrder
    quantity?: SortOrder
    value?: SortOrder
    status?: SortOrder
  }

  export type CAHoldingsMinOrderByAggregateInput = {
    id?: SortOrder
    asset?: SortOrder
    quantity?: SortOrder
    value?: SortOrder
    status?: SortOrder
  }

  export type CAHoldingsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type CAMarketCardsOrderByRelevanceInput = {
    fields: CAMarketCardsOrderByRelevanceFieldEnum | CAMarketCardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CAMarketCardsCountOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    volume?: SortOrder
    change?: SortOrder
    unit?: SortOrder
  }

  export type CAMarketCardsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CAMarketCardsMaxOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    volume?: SortOrder
    change?: SortOrder
    unit?: SortOrder
  }

  export type CAMarketCardsMinOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    volume?: SortOrder
    change?: SortOrder
    unit?: SortOrder
  }

  export type CAMarketCardsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CAPieChartOrderByRelevanceInput = {
    fields: CAPieChartOrderByRelevanceFieldEnum | CAPieChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CAPieChartCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
  }

  export type CAPieChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CAPieChartMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
  }

  export type CAPieChartMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
  }

  export type CAPieChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CAPriceChartOrderByRelevanceInput = {
    fields: CAPriceChartOrderByRelevanceFieldEnum | CAPriceChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CAPriceChartCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    volume?: SortOrder
  }

  export type CAPriceChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CAPriceChartMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    volume?: SortOrder
  }

  export type CAPriceChartMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    price?: SortOrder
    volume?: SortOrder
  }

  export type CAPriceChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CBComparisonChartOrderByRelevanceInput = {
    fields: CBComparisonChartOrderByRelevanceFieldEnum | CBComparisonChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CBComparisonChartCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    actual?: SortOrder
    budget?: SortOrder
  }

  export type CBComparisonChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CBComparisonChartMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    actual?: SortOrder
    budget?: SortOrder
  }

  export type CBComparisonChartMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    actual?: SortOrder
    budget?: SortOrder
  }

  export type CBComparisonChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CBMonthlyDetailsOrderByRelevanceInput = {
    fields: CBMonthlyDetailsOrderByRelevanceFieldEnum | CBMonthlyDetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CBMonthlyDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    energy_budget?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
    status?: SortOrder
  }

  export type CBMonthlyDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CBMonthlyDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    energy_budget?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
    status?: SortOrder
  }

  export type CBMonthlyDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    energy_budget?: SortOrder
    actual?: SortOrder
    variance?: SortOrder
    status?: SortOrder
  }

  export type CBMonthlyDetailsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CBSummaryCardsOrderByRelevanceInput = {
    fields: CBSummaryCardsOrderByRelevanceFieldEnum | CBSummaryCardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CBSummaryCardsCountOrderByAggregateInput = {
    id?: SortOrder
    total_energy?: SortOrder
    used?: SortOrder
    remaining?: SortOrder
    overrun_rate?: SortOrder
    unit?: SortOrder
  }

  export type CBSummaryCardsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CBSummaryCardsMaxOrderByAggregateInput = {
    id?: SortOrder
    total_energy?: SortOrder
    used?: SortOrder
    remaining?: SortOrder
    overrun_rate?: SortOrder
    unit?: SortOrder
  }

  export type CBSummaryCardsMinOrderByAggregateInput = {
    id?: SortOrder
    total_energy?: SortOrder
    used?: SortOrder
    remaining?: SortOrder
    overrun_rate?: SortOrder
    unit?: SortOrder
  }

  export type CBSummaryCardsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type CFDetailsOrderByRelevanceInput = {
    fields: CFDetailsOrderByRelevanceFieldEnum | CFDetailsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CFDetailsCountOrderByAggregateInput = {
    id?: SortOrder
    process?: SortOrder
    scope?: SortOrder
    emission?: SortOrder
    factor?: SortOrder
    total?: SortOrder
  }

  export type CFDetailsAvgOrderByAggregateInput = {
    id?: SortOrder
    emission?: SortOrder
    factor?: SortOrder
    total?: SortOrder
  }

  export type CFDetailsMaxOrderByAggregateInput = {
    id?: SortOrder
    process?: SortOrder
    scope?: SortOrder
    emission?: SortOrder
    factor?: SortOrder
    total?: SortOrder
  }

  export type CFDetailsMinOrderByAggregateInput = {
    id?: SortOrder
    process?: SortOrder
    scope?: SortOrder
    emission?: SortOrder
    factor?: SortOrder
    total?: SortOrder
  }

  export type CFDetailsSumOrderByAggregateInput = {
    id?: SortOrder
    emission?: SortOrder
    factor?: SortOrder
    total?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type CFPieChartOrderByRelevanceInput = {
    fields: CFPieChartOrderByRelevanceFieldEnum | CFPieChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CFPieChartCountOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
  }

  export type CFPieChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CFPieChartMaxOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
  }

  export type CFPieChartMinOrderByAggregateInput = {
    id?: SortOrder
    scope?: SortOrder
    value?: SortOrder
    percentage?: SortOrder
  }

  export type CFPieChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CFTrendChartOrderByRelevanceInput = {
    fields: CFTrendChartOrderByRelevanceFieldEnum | CFTrendChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type CFTrendChartCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    footprint?: SortOrder
    scope1?: SortOrder
    scope2?: SortOrder
    scope3?: SortOrder
  }

  export type CFTrendChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CFTrendChartMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    footprint?: SortOrder
    scope1?: SortOrder
    scope2?: SortOrder
    scope3?: SortOrder
  }

  export type CFTrendChartMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    footprint?: SortOrder
    scope1?: SortOrder
    scope2?: SortOrder
    scope3?: SortOrder
  }

  export type CFTrendChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EAConsumptionTrendOrderByRelevanceInput = {
    fields: EAConsumptionTrendOrderByRelevanceFieldEnum | EAConsumptionTrendOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EAConsumptionTrendCountOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    downstream?: SortOrder
    forecast?: SortOrder
  }

  export type EAConsumptionTrendAvgOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    downstream?: SortOrder
    forecast?: SortOrder
  }

  export type EAConsumptionTrendMaxOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    downstream?: SortOrder
    forecast?: SortOrder
  }

  export type EAConsumptionTrendMinOrderByAggregateInput = {
    id?: SortOrder
    date?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    downstream?: SortOrder
    forecast?: SortOrder
  }

  export type EAConsumptionTrendSumOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    downstream?: SortOrder
    forecast?: SortOrder
  }

  export type EAMonthSummaryOrderByRelevanceInput = {
    fields: EAMonthSummaryOrderByRelevanceFieldEnum | EAMonthSummaryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EAMonthSummaryCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    growth_rate?: SortOrder
    forecast_growth?: SortOrder
  }

  export type EAMonthSummaryAvgOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    growth_rate?: SortOrder
    forecast_growth?: SortOrder
  }

  export type EAMonthSummaryMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    growth_rate?: SortOrder
    forecast_growth?: SortOrder
  }

  export type EAMonthSummaryMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    growth_rate?: SortOrder
    forecast_growth?: SortOrder
  }

  export type EAMonthSummarySumOrderByAggregateInput = {
    id?: SortOrder
    total?: SortOrder
    upstream?: SortOrder
    growth_rate?: SortOrder
    forecast_growth?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EAStrategyOrderByRelevanceInput = {
    fields: EAStrategyOrderByRelevanceFieldEnum | EAStrategyOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EAStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    impact?: SortOrder
    action?: SortOrder
  }

  export type EAStrategyAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EAStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    action?: SortOrder
  }

  export type EAStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    action?: SortOrder
  }

  export type EAStrategySumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EATypeComparisonOrderByRelevanceInput = {
    fields: EATypeComparisonOrderByRelevanceFieldEnum | EATypeComparisonOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EATypeComparisonCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    coal?: SortOrder
    gas?: SortOrder
    electric?: SortOrder
  }

  export type EATypeComparisonAvgOrderByAggregateInput = {
    id?: SortOrder
    coal?: SortOrder
    gas?: SortOrder
    electric?: SortOrder
  }

  export type EATypeComparisonMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    coal?: SortOrder
    gas?: SortOrder
    electric?: SortOrder
  }

  export type EATypeComparisonMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    coal?: SortOrder
    gas?: SortOrder
    electric?: SortOrder
  }

  export type EATypeComparisonSumOrderByAggregateInput = {
    id?: SortOrder
    coal?: SortOrder
    gas?: SortOrder
    electric?: SortOrder
  }

  export type EBParamCardsOrderByRelevanceInput = {
    fields: EBParamCardsOrderByRelevanceFieldEnum | EBParamCardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EBParamCardsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    trend?: SortOrder
  }

  export type EBParamCardsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBParamCardsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    trend?: SortOrder
  }

  export type EBParamCardsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    unit?: SortOrder
    trend?: SortOrder
  }

  export type EBParamCardsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBPieChartOrderByRelevanceInput = {
    fields: EBPieChartOrderByRelevanceFieldEnum | EBPieChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EBPieChartCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    color?: SortOrder
  }

  export type EBPieChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBPieChartMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    color?: SortOrder
  }

  export type EBPieChartMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    value?: SortOrder
    color?: SortOrder
  }

  export type EBPieChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBResultsOrderByRelevanceInput = {
    fields: EBResultsOrderByRelevanceFieldEnum | EBResultsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EBResultsCountOrderByAggregateInput = {
    id?: SortOrder
    before?: SortOrder
    after?: SortOrder
    savings?: SortOrder
  }

  export type EBResultsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBResultsMaxOrderByAggregateInput = {
    id?: SortOrder
    savings?: SortOrder
  }

  export type EBResultsMinOrderByAggregateInput = {
    id?: SortOrder
    savings?: SortOrder
  }

  export type EBResultsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBTrendChartOrderByRelevanceInput = {
    fields: EBTrendChartOrderByRelevanceFieldEnum | EBTrendChartOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EBTrendChartCountOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    generation?: SortOrder
    consumption?: SortOrder
  }

  export type EBTrendChartAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EBTrendChartMaxOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    generation?: SortOrder
    consumption?: SortOrder
  }

  export type EBTrendChartMinOrderByAggregateInput = {
    id?: SortOrder
    time?: SortOrder
    generation?: SortOrder
    consumption?: SortOrder
  }

  export type EBTrendChartSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ECenergyFlowRealTimeOrderByRelevanceInput = {
    fields: ECenergyFlowRealTimeOrderByRelevanceFieldEnum | ECenergyFlowRealTimeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ECenergyFlowRealTimeCountOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    energy_type_id?: SortOrder
    flow_value?: SortOrder
    temperature?: SortOrder
    pressure?: SortOrder
    timestamp?: SortOrder
  }

  export type ECenergyFlowRealTimeAvgOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type ECenergyFlowRealTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    energy_type_id?: SortOrder
    flow_value?: SortOrder
    temperature?: SortOrder
    pressure?: SortOrder
    timestamp?: SortOrder
  }

  export type ECenergyFlowRealTimeMinOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
    energy_type_id?: SortOrder
    flow_value?: SortOrder
    temperature?: SortOrder
    pressure?: SortOrder
    timestamp?: SortOrder
  }

  export type ECenergyFlowRealTimeSumOrderByAggregateInput = {
    id?: SortOrder
    device_id?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ECenergyTypesOrderByRelevanceInput = {
    fields: ECenergyTypesOrderByRelevanceFieldEnum | ECenergyTypesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ECenergyTypesCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    icon?: SortOrder
    conversion_factor?: SortOrder
    created_at?: SortOrder
  }

  export type ECenergyTypesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ECenergyTypesMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    icon?: SortOrder
    conversion_factor?: SortOrder
    created_at?: SortOrder
  }

  export type ECenergyTypesMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    unit?: SortOrder
    icon?: SortOrder
    conversion_factor?: SortOrder
    created_at?: SortOrder
  }

  export type ECenergyTypesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EChistoryOrderByRelevanceInput = {
    fields: EChistoryOrderByRelevanceFieldEnum | EChistoryOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EChistoryCountOrderByAggregateInput = {
    id?: SortOrder
    energy_type_id?: SortOrder
    date_time?: SortOrder
    consumption?: SortOrder
    generation?: SortOrder
    status?: SortOrder
  }

  export type EChistoryAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EChistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    energy_type_id?: SortOrder
    date_time?: SortOrder
    consumption?: SortOrder
    generation?: SortOrder
    status?: SortOrder
  }

  export type EChistoryMinOrderByAggregateInput = {
    id?: SortOrder
    energy_type_id?: SortOrder
    date_time?: SortOrder
    consumption?: SortOrder
    generation?: SortOrder
    status?: SortOrder
  }

  export type EChistorySumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ECrealTimeOrderByRelevanceInput = {
    fields: ECrealTimeOrderByRelevanceFieldEnum | ECrealTimeOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type ECrealTimeCountOrderByAggregateInput = {
    id?: SortOrder
    energy_type_id?: SortOrder
    current_value?: SortOrder
    total_value?: SortOrder
    unit?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type ECrealTimeAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ECrealTimeMaxOrderByAggregateInput = {
    id?: SortOrder
    energy_type_id?: SortOrder
    current_value?: SortOrder
    total_value?: SortOrder
    unit?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type ECrealTimeMinOrderByAggregateInput = {
    id?: SortOrder
    energy_type_id?: SortOrder
    current_value?: SortOrder
    total_value?: SortOrder
    unit?: SortOrder
    timestamp?: SortOrder
    status?: SortOrder
  }

  export type ECrealTimeSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EEBenchmarkRankCardsOrderByRelevanceInput = {
    fields: EEBenchmarkRankCardsOrderByRelevanceFieldEnum | EEBenchmarkRankCardsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EEBenchmarkRankCardsCountOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    name?: SortOrder
    efficiency?: SortOrder
    unit?: SortOrder
    trend?: SortOrder
  }

  export type EEBenchmarkRankCardsAvgOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type EEBenchmarkRankCardsMaxOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    name?: SortOrder
    efficiency?: SortOrder
    unit?: SortOrder
    trend?: SortOrder
  }

  export type EEBenchmarkRankCardsMinOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
    name?: SortOrder
    efficiency?: SortOrder
    unit?: SortOrder
    trend?: SortOrder
  }

  export type EEBenchmarkRankCardsSumOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type EEGaugeMetricsOrderByRelevanceInput = {
    fields: EEGaugeMetricsOrderByRelevanceFieldEnum | EEGaugeMetricsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EEGaugeMetricsCountOrderByAggregateInput = {
    id?: SortOrder
    current?: SortOrder
    target?: SortOrder
    label?: SortOrder
  }

  export type EEGaugeMetricsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EEGaugeMetricsMaxOrderByAggregateInput = {
    id?: SortOrder
    current?: SortOrder
    target?: SortOrder
    label?: SortOrder
  }

  export type EEGaugeMetricsMinOrderByAggregateInput = {
    id?: SortOrder
    current?: SortOrder
    target?: SortOrder
    label?: SortOrder
  }

  export type EEGaugeMetricsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EERankingListOrderByRelevanceInput = {
    fields: EERankingListOrderByRelevanceFieldEnum | EERankingListOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EERankingListCountOrderByAggregateInput = {
    id?: SortOrder
    enterprise?: SortOrder
    rank?: SortOrder
    efficiency?: SortOrder
    benchmark?: SortOrder
    delta?: SortOrder
    status?: SortOrder
  }

  export type EERankingListAvgOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type EERankingListMaxOrderByAggregateInput = {
    id?: SortOrder
    enterprise?: SortOrder
    rank?: SortOrder
    efficiency?: SortOrder
    benchmark?: SortOrder
    delta?: SortOrder
    status?: SortOrder
  }

  export type EERankingListMinOrderByAggregateInput = {
    id?: SortOrder
    enterprise?: SortOrder
    rank?: SortOrder
    efficiency?: SortOrder
    benchmark?: SortOrder
    delta?: SortOrder
    status?: SortOrder
  }

  export type EERankingListSumOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type EETrendChartDataOrderByRelevanceInput = {
    fields: EETrendChartDataOrderByRelevanceFieldEnum | EETrendChartDataOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EETrendChartDataCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    value?: SortOrder
    benchmark?: SortOrder
  }

  export type EETrendChartDataAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EETrendChartDataMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    value?: SortOrder
    benchmark?: SortOrder
  }

  export type EETrendChartDataMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    value?: SortOrder
    benchmark?: SortOrder
  }

  export type EETrendChartDataSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EFSankeyLinksOrderByRelevanceInput = {
    fields: EFSankeyLinksOrderByRelevanceFieldEnum | EFSankeyLinksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EFSankeyLinksCountOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    target?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type EFSankeyLinksAvgOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    target?: SortOrder
  }

  export type EFSankeyLinksMaxOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    target?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type EFSankeyLinksMinOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    target?: SortOrder
    value?: SortOrder
    type?: SortOrder
  }

  export type EFSankeyLinksSumOrderByAggregateInput = {
    id?: SortOrder
    source?: SortOrder
    target?: SortOrder
  }

  export type EFSankeyNodesOrderByRelevanceInput = {
    fields: EFSankeyNodesOrderByRelevanceFieldEnum | EFSankeyNodesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EFSankeyNodesCountOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type EFSankeyNodesAvgOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
  }

  export type EFSankeyNodesMaxOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type EFSankeyNodesMinOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    name?: SortOrder
    value?: SortOrder
    unit?: SortOrder
  }

  export type EFSankeyNodesSumOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
  }

  export type EFSummaryTableOrderByRelevanceInput = {
    fields: EFSummaryTableOrderByRelevanceFieldEnum | EFSummaryTableOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type EFSummaryTableCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total?: SortOrder
    percentage?: SortOrder
    unit?: SortOrder
  }

  export type EFSummaryTableAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EFSummaryTableMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total?: SortOrder
    percentage?: SortOrder
    unit?: SortOrder
  }

  export type EFSummaryTableMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total?: SortOrder
    percentage?: SortOrder
    unit?: SortOrder
  }

  export type EFSummaryTableSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type SCRankingOrderByRelevanceInput = {
    fields: SCRankingOrderByRelevanceFieldEnum | SCRankingOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SCRankingCountOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    emission?: SortOrder
    intensity?: SortOrder
    rank?: SortOrder
    compliance?: SortOrder
  }

  export type SCRankingAvgOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type SCRankingMaxOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    emission?: SortOrder
    intensity?: SortOrder
    rank?: SortOrder
    compliance?: SortOrder
  }

  export type SCRankingMinOrderByAggregateInput = {
    id?: SortOrder
    supplier?: SortOrder
    emission?: SortOrder
    intensity?: SortOrder
    rank?: SortOrder
    compliance?: SortOrder
  }

  export type SCRankingSumOrderByAggregateInput = {
    id?: SortOrder
    rank?: SortOrder
  }

  export type SCSankeyDataOrderByRelevanceInput = {
    fields: SCSankeyDataOrderByRelevanceFieldEnum | SCSankeyDataOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type SCSankeyDataCountOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    name?: SortOrder
    value?: SortOrder
    source?: SortOrder
    target?: SortOrder
    co2?: SortOrder
    type?: SortOrder
  }

  export type SCSankeyDataAvgOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    source?: SortOrder
    target?: SortOrder
  }

  export type SCSankeyDataMaxOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    name?: SortOrder
    value?: SortOrder
    source?: SortOrder
    target?: SortOrder
    co2?: SortOrder
    type?: SortOrder
  }

  export type SCSankeyDataMinOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    name?: SortOrder
    value?: SortOrder
    source?: SortOrder
    target?: SortOrder
    co2?: SortOrder
    type?: SortOrder
  }

  export type SCSankeyDataSumOrderByAggregateInput = {
    id?: SortOrder
    node?: SortOrder
    source?: SortOrder
    target?: SortOrder
  }

  export type receiptfcOrderByRelevanceInput = {
    fields: receiptfcOrderByRelevanceFieldEnum | receiptfcOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type receiptfcCountOrderByAggregateInput = {
    id?: SortOrder
    saleMemberId?: SortOrder
    saleMemberName?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    wasteTypeName?: SortOrder
    imgUrls?: SortOrder
    weight?: SortOrder
    orderTime?: SortOrder
    carNumber?: SortOrder
    carBrand?: SortOrder
    createTime?: SortOrder
    queryDate?: SortOrder
  }

  export type receiptfcAvgOrderByAggregateInput = {
    id?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    weight?: SortOrder
  }

  export type receiptfcMaxOrderByAggregateInput = {
    id?: SortOrder
    saleMemberId?: SortOrder
    saleMemberName?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    wasteTypeName?: SortOrder
    imgUrls?: SortOrder
    weight?: SortOrder
    orderTime?: SortOrder
    carNumber?: SortOrder
    carBrand?: SortOrder
    createTime?: SortOrder
    queryDate?: SortOrder
  }

  export type receiptfcMinOrderByAggregateInput = {
    id?: SortOrder
    saleMemberId?: SortOrder
    saleMemberName?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    wasteTypeName?: SortOrder
    imgUrls?: SortOrder
    weight?: SortOrder
    orderTime?: SortOrder
    carNumber?: SortOrder
    carBrand?: SortOrder
    createTime?: SortOrder
    queryDate?: SortOrder
  }

  export type receiptfcSumOrderByAggregateInput = {
    id?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    weight?: SortOrder
  }

  export type receiptfgOrderByRelevanceInput = {
    fields: receiptfgOrderByRelevanceFieldEnum | receiptfgOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type receiptfgCountOrderByAggregateInput = {
    id?: SortOrder
    saleMemberId?: SortOrder
    saleMemberName?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    wasteTypeName?: SortOrder
    imgUrls?: SortOrder
    weight?: SortOrder
    orderTime?: SortOrder
    carNumber?: SortOrder
    carBrand?: SortOrder
    createTime?: SortOrder
    queryDate?: SortOrder
  }

  export type receiptfgAvgOrderByAggregateInput = {
    id?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    weight?: SortOrder
  }

  export type receiptfgMaxOrderByAggregateInput = {
    id?: SortOrder
    saleMemberId?: SortOrder
    saleMemberName?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    wasteTypeName?: SortOrder
    imgUrls?: SortOrder
    weight?: SortOrder
    orderTime?: SortOrder
    carNumber?: SortOrder
    carBrand?: SortOrder
    createTime?: SortOrder
    queryDate?: SortOrder
  }

  export type receiptfgMinOrderByAggregateInput = {
    id?: SortOrder
    saleMemberId?: SortOrder
    saleMemberName?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    wasteTypeName?: SortOrder
    imgUrls?: SortOrder
    weight?: SortOrder
    orderTime?: SortOrder
    carNumber?: SortOrder
    carBrand?: SortOrder
    createTime?: SortOrder
    queryDate?: SortOrder
  }

  export type receiptfgSumOrderByAggregateInput = {
    id?: SortOrder
    taxInclu?: SortOrder
    unitpriceIncluTax?: SortOrder
    weight?: SortOrder
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}